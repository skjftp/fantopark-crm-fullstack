
<!-- CRM Version:FIELD-MAPPING-FIXED-20250630 -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<link rel="icon" type="image/x-icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>FanToPark CRM Pro</title>
<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://cdn.tailwindcss.com"></script>
<!-- Load all constant files -->
<script src="constants/config.js"></script>
<script src="constants/status-config.js"></script>
<script src="constants/user-roles.js"></script>
<script src="constants/form-config.js"></script>
<script src="constants/default-data.js"></script>
<!-- Utility Functions -->
<script src="utils/api.js"></script>
<script src="utils/permissions.js"></script>
<script src="utils/helpers.js"></script>
<!-- Component Files -->
<script src="components/assignment-rules.js"></script>
<script src="components/my-actions.js"></script>
<script src="components/leads.js"></script>
<script src="components/dashboard.js"></script>  
<script src="components/content-router.js"></script>
<script src="components/inventory.js"></script>
<script src="components/financials.js"></script>
<script src="components/orders.js"></script> 
<script src="components/user-management.js"></script>
<script src="components/stadiums.js"></script> 
<script src="components/delivery.js"></script>
<script src="components/sports-calendar.js"></script> 
<script src="components/reminders.js"></script>
<script src="components/inventory-form.js"></script>
<script src="components/lead-form.js"></script> 
<script src="components/lead-detail.js"></script>
<script src="components/payment-form.js"></script>
<script src="components/inventory-detail.js"></script>
<script src="components/order-detail-modal.js"></script>
<script src="components/user-form.js"></script>
<script src="components/gst-invoice-preview.js"></script>
<script src="components/assign-form.js"></script>
<script src="components/bulk-assign-modal.js"></script>
<script src="components/choice-modal.js"></script> 
<script src="components/status-progress-modal.js"></script>
<script src="components/allocation-management.js"></script>
<script src="components/help-guide.js"></script>  
<script src="components/stadium-form.js"></script>
<script src="components/payment-post-service-form.js"></script>
<script src="components/edit-order-form.js"></script>
<script src="components/client-detail-modal.js"></script>
<script src="components/payment-submit-handler.js"></script>
<script src="components/inventory-form-submit-handler.js"></script>
<script src="components/delete-handler.js"></script>
<script src="components/test-mode-system.js"></script>
<script src="components/csv-upload-system.js"></script>
<script src="components/form-handlers.js"></script>  
<script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>  

<!-- API Configuration--->
<script>
// Configure API endpoint

// Global function to handle proceed from preview
window.handleProceedFromPreview = () => {
if (window.currentUploadFile) {
console.log("üöÄ Starting upload with file:", window.currentUploadFile.name);

// Close any open modals by clicking cancel/close buttons
const cancelBtn = Array.from(document.querySelectorAll("button")).find(b => b.textContent === "Cancel");
if (cancelBtn) cancelBtn.click();

// Trigger the upload with the stored file
const formData = new FormData();
formData.append("file", window.currentUploadFile);
fetch(window.API_CONFIG.API_URL + "/upload/leads/csv", {
method: "POST",
headers: { Authorization: authToken ? "Bearer " + authToken : undefined },
body: formData
}).then(response => response.json()).then(result => {
console.log("‚úÖ Upload successful:", result);
alert("‚úÖ Upload successful: " + result.message);
window.currentUploadFile = null;
location.reload();
}).catch(error => {
console.error("‚ùå Upload failed:", error);
alert("‚ùå Upload failed: " + error.message);
});
} else {
alert("No file selected for upload");
}
};


console.log("üîó window.API_CONFIG.API_URL set to:", window.API_CONFIG.API_URL);
console.log("üîó window.API_CONFIG.API_URL:", window.API_CONFIG.API_URL);
// Get stored auth token
let authToken = localStorage.getItem("crm_auth_token");

// Update authToken if found in localStorage
if (authToken) {
console.log("Auth token loaded from localStorage");
}

</script>

<style>
/* Dark mode base styles */
.dark {
color-scheme: dark;
}

.dark body {
background-color: #111827;
color: #f3f4f6;
}

/* Dark mode for main containers */
.dark .bg-white {
background-color: #1f2937 !important;
}

.dark .bg-gray-50 {
background-color: #111827 !important;
}

.dark .bg-gray-100 {
background-color: #0f172a !important;
}

/* Dark mode for text */
.dark .text-gray-900 {
color: #f3f4f6 !important;
}

.dark .text-gray-800 {
color: #e5e7eb !important;
}

.dark .text-gray-700 {
color: #d1d5db !important;
}

.dark .text-gray-600 {
color: #9ca3af !important;
}

.dark .text-gray-500 {
color: #6b7280 !important;
}

/* Dark mode for borders */
.dark .border-gray-200 {
border-color: #374151 !important;
}

.dark .border-gray-300 {
border-color: #4b5563 !important;
}

.dark .border-b {
border-color: #374151 !important;
}

/* Dark mode for inputs and forms */
.dark input, .dark select, .dark textarea {
background-color: #374151 !important;
border-color: #4b5563 !important;
color: #f3f4f6 !important;
}

.dark input:focus, .dark select:focus, .dark textarea:focus {
border-color: #3b82f6 !important;
background-color: #4b5563 !important;
}

/* Dark mode for hover states */
.dark .hover\:bg-gray-50:hover {
background-color: #374151 !important;
}

.dark .hover\:bg-gray-100:hover {
background-color: #4b5563 !important;
}

/* Dark mode for tables */
.dark table {
background-color: #1f2937 !important;
}

.dark thead {
background-color: #111827 !important;
}

.dark tbody tr:hover {
background-color: #374151 !important;
}

/* Dark mode for modals */
.dark .bg-black.bg-opacity-50 {
background-color: rgba(0, 0, 0, 0.75) !important;
}

/* Dark mode for shadows */
.dark .shadow-sm {
box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.5) !important;
}

.dark .shadow-md {
box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5) !important;
}

/* Dark mode for sidebar */
.dark .bg-gray-900 {
background-color: #0f172a !important;
}

/* Dark mode scrollbars */
.dark ::-webkit-scrollbar {
background-color: #1f2937;
}

.dark ::-webkit-scrollbar-thumb {
background-color: #4b5563;
}

.dark ::-webkit-scrollbar-thumb:hover {
background-color: #6b7280;
}


/* Invoice Styles - Updated to match invoice module */
.invoice-preview {
background: white;
border: 2px solid #000;
font-family: Arial, sans-serif;
font-size: 10px;
line-height: 1.2;
margin: 0 auto;
max-width: 210mm;
height: fit-content;
padding: 8mm;
box-sizing: border-box;
display: block;
overflow: hidden;
}
.invoice-header-row {
display: grid;
grid-template-columns: 300px 1fr auto;
padding: 10px 8px;
border-bottom: 2px solid #000;
align-items: center;
margin-bottom: 10px;
background: #f8f9fa;
}
.company-logo {
width: 210px;
height: 150px;
margin: 0;
}
.company-logo img {
max-width: 210px;
max-height: 150px;
object-fit: contain;
}
.invoice-title {
text-align: right;
font-size: 16px;
font-weight: bold;
padding-top: 10px;
color: #2c3e50;
}
.invoice-meta {
display: grid;
grid-template-columns: 1fr 1fr;
padding: 8px;
border-bottom: 1px solid #000;
font-size: 10px;
margin-bottom: 10px;
background: #f8f9fa;
}
.customer-section {
padding: 10px 8px;
border-bottom: 1px solid #000;
margin-bottom: 12px;
background: #f8f9fa;
}
.customer-title {
font-weight: bold;
margin-bottom: 4px;
font-size: 10px;
}
.invoice-table {
width: 100%;
border-collapse: collapse;
font-size: 10px;
margin-bottom: 12px;
}
.invoice-table th {
background: #2c3e50;
color: white;
padding: 6px 4px;
text-align: left;
border: 1px solid #000;
font-weight: bold;
font-size: 10px;
}
.invoice-table td {
padding: 6px 4px;
border: 1px solid #000;
text-align: left;
background: white;
}
.totals-table {
width: 100%;
border-collapse: collapse;
font-size: 10px;
margin-bottom: 12px;
}
.totals-table td {
padding: 4px;
border: 1px solid #000;
}
.bank-details {
display: grid;
grid-template-columns: 1fr 1fr;
padding: 10px 8px;
border: 2px solid #2c3e50;
font-size: 9px;
gap: 10px;
background: #f8f9fa;
margin-top: 10px;
}
.bank-info h4 {
margin-bottom: 6px;
font-size: 10px;
color: #2c3e50;
border-bottom: 1px solid #2c3e50;
padding-bottom: 2px;
}
.bank-info div {
margin-bottom: 2px;
line-height: 1.1;
}
.payment-qr {
text-align: center;
}
.payment-qr img {
width: 120px;
height: 120px;
border: 2px solid #ddd;
padding: 5px;
background: white;
}
.invoice-footer {
margin-top: 10px;
text-align: center;
font-size: 8px;
color: #666;
}
.company-info-section {
background: white;
padding: 8px;
border: 1px solid #ddd;
border-radius: 3px;
margin-bottom: 8px;
}
.company-info-section h4 {
color: #2c3e50;
margin-bottom: 6px;
border-bottom: 1px solid #2c3e50;
padding-bottom: 2px;
text-align: center;
font-size: 9px;
}
@media print {
body { background: white; padding: 0; margin: 0; }
.invoice-preview { border: none; box-shadow: none; margin: 0; padding: 5mm; }
.modal-backdrop { display: none; }
.sticky { position: relative !important; }
@page { margin: 10mm; size: A4; }
}
/* Fix for action buttons */
.action-buttons button {
position: relative;
z-index: 10;
cursor: pointer;
}
td .flex button {
position: relative;
z-index: 10;
}

/* Logout button fix */
.logout-button-fix {
position: relative !important;
width: auto !important;
height: auto !important;
}

/* Prevent invisible overlays */
button:not(:hover) {
z-index: auto !important;
}

/* Ensure sidebar stays contained */
.sidebar-container {
overflow: hidden;
}


/* Logout button area fix */
.sidebar-logout {
margin-top: auto;
padding: 1rem;
border-top: 1px solid #e5e7eb;
}

.sidebar-logout button {
width: 100%;
max-width: 200px;
margin: 0 auto;
display: flex;
align-items: center;
padding: 0.75rem 1rem;
border-radius: 0.375rem;
transition: background-color 0.2s;
}

.sidebar-logout button:hover {
background-color: #f9fafb;
}

/* Prevent any overlay issues */
.sidebar-container > div:last-child {
position: relative !important;
bottom: auto !important;
left: auto !important;
right: auto !important;
}

</style>

<style>
.test-mode-active {
border: 4px solid #dc2626 !important;
box-shadow: inset 0 0 0 4px #dc2626;
}

/* Logout button fix */
.logout-button-fix {
position: relative !important;
width: auto !important;
height: auto !important;
}

/* Prevent invisible overlays */
button:not(:hover) {
z-index: auto !important;
}

/* Ensure sidebar stays contained */
.sidebar-container {
overflow: hidden;
}


/* Logout button area fix */
.sidebar-logout {
margin-top: auto;
padding: 1rem;
border-top: 1px solid #e5e7eb;
}

.sidebar-logout button {
width: 100%;
max-width: 200px;
margin: 0 auto;
display: flex;
align-items: center;
padding: 0.75rem 1rem;
border-radius: 0.375rem;
transition: background-color 0.2s;
}

.sidebar-logout button:hover {
background-color: #f9fafb;
}

/* Prevent any overlay issues */
.sidebar-container > div:last-child {
position: relative !important;
bottom: auto !important;
left: auto !important;
right: auto !important;
}

</style>
</head>
<body>
<div id="test-mode-indicator" style="display:none; background:#dc2626; color:white; text-align:center; padding:10px; font-weight:bold;">
üß™ TEST MODE ACTIVE - Delete All buttons enabled
</div>
<script>if(localStorage.getItem('testMode')==='true') document.getElementById('test-mode-indicator').style.display='block';</script>
<div id="root"></div>
<div id="error-message" style="position: fixed; top: 20px; right: 20px; background: #ef4444; color: white; padding: 12px 20px; border-radius: 6px; display: none; z-index: 9999;"></div>
<script>


// Show previous logs on page load
window.addEventListener('load', () => {
const logs = JSON.parse(sessionStorage.getItem('debugLogs') || '[]');
if (logs.length > 0) {
console.log('=== Previous Session Logs ===');
logs.forEach(log => console.log('[' + (log.time) + '] ' + (log.key) + ':', log.data));
console.log('=== End Previous Logs ===');
}
});

// Clear logs button (press Ctrl+Shift+L)
document.addEventListener('keydown', (e) => {
if (e.ctrlKey && e.shiftKey && e.key === 'L') {
sessionStorage.removeItem('debugLogs');
console.log('Debug logs cleared');
}
});

const { useState, useEffect, useRef } = React;


// Helper function to display user names instead of emails


// Helper function to get proper role display label
window.getRoleDisplayLabel = function(roleName) {
// Map of role names to display labels
const roleLabels = {
'super_admin': 'Super Admin',
'admin': 'Admin', 
'sales_manager': 'Sales Manager',
'sales_executive': 'Sales Executive',
'supply_manager': 'Supply Manager', // Legacy
'supply_sales_service_manager': 'Supply Sales Service Manager', // Updated
'finance_manager': 'Finance Manager',
'viewer': 'Viewer'
};



return roleLabels[roleName] || roleName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
};



// Helper function to format date for display (DD/MM/YYYY)
const formatDateForDisplay = (dateValue) => {
if (!dateValue) return 'Not Set';

try {
let date;

if (dateValue instanceof Date) {
date = dateValue;
} else if (typeof dateValue === 'string' && dateValue.includes('T')) {
date = new Date(dateValue);
} else if (typeof dateValue === 'string') {
date = new Date(dateValue);
} else if (typeof dateValue === 'object' && dateValue._seconds) {
date = new Date(dateValue._seconds * 1000);
} else {
return 'Invalid Date';
}

if (isNaN(date.getTime())) {
return 'Invalid Date';
}

const day = String(date.getDate()).padStart(2, '0');
const month = String(date.getMonth() + 1).padStart(2, '0');
const year = date.getFullYear();

return `${day}/${month}/${year}`;
} catch (error) {
return 'Error';
}
};


// Replace existing calculateGST function

// Helper function to get lead temperature (preserves temperature through parallel stages)
const getLeadTemperature = (lead) => {
// If current status has temperature, use it
if (window.LEAD_STATUSES[lead.status]?.temperature) {
return window.LEAD_STATUSES[lead.status].temperature;
}

// If it's a parallel stage, get temperature from lead data
if (lead.temperature) {
return lead.temperature;
}

// Fallback to status if it's a temperature status
if (['hot', 'warm', 'cold'].includes(lead.status)) {
return lead.status;
}

return null;
};



// Helper function to get display temperature for dashboard
const getDisplayTemperature = (lead) => {
const temp = getLeadTemperature(lead);
if (temp && ['hot', 'warm', 'cold'].includes(temp)) {
return temp;
}
// For quote_requested, check if it was previously hot/warm/cold
if (lead.status === 'quote_requested' && lead.temperature) {
return lead.temperature;
}
return null;
};



function App() {
// Authentication states
const [isLoggedIn, setIsLoggedIn] = useState(false);
const [testMode, setTestMode] = useState(() => {
return localStorage.getItem('testMode') === 'true';
});
const [user, setUser] = useState(null);
const [email, setEmail] = useState('');
const [password, setPassword] = useState('');
const [activeTab, setActiveTab] = useState(() => {
const savedTab = localStorage.getItem('crm_active_tab');
return savedTab || 'dashboard';
});
const [loading, setLoading] = useState(false);

// Users management

// Initialize empty, will fetch from API
const [leads, setLeads] = useState([]);
const [inventory, setInventory] = useState([]);
// Add this line near other useState declarations
const [editingInventory, setEditingInventory] = useState(null);
const [showInventoryForm, setShowInventoryForm] = useState(false);
const [orders, setOrders] = useState([]);
const [orderToAssign, setOrderToAssign] = useState(null);
const [reminders, setReminders] = useState([]);
const [showReminderDashboard, setShowReminderDashboard] = useState(false);
const [reminderStats, setReminderStats] = useState({
total: 0,
overdue: 0,
due_today: 0,
pending: 0
}); 
const [sportsEvents, setSportsEvents] = useState([]);
const [showEventForm, setShowEventForm] = useState(false);
const [showEventDetail, setShowEventDetail] = useState(false);
const [currentEvent, setCurrentEvent] = useState(null);
const [eventFormData, setEventFormData] = useState({
title: "",
date: "",
time: "",
venue: "",
category: "cricket",
description: "",
ticket_available: false,
fantopark_package: ""
});
const [calendarView, setCalendarView] = useState("month");
const [selectedDate, setSelectedDate] = useState(new Date());
const [showOrderAssignModal, setShowOrderAssignModal] = useState(false);
const [showAllocationManagement, setShowAllocationManagement] = React.useState(false);
const [showInventoryDetail, setShowInventoryDetail] = useState(false);
const [currentInventoryDetail, setCurrentInventoryDetail] = useState(null);
const [currentAllocations, setCurrentAllocations] = React.useState([]);
const [showOrderForm, setShowOrderForm] = useState(false);
const [inventoryEventTypeFilter, setInventoryEventTypeFilter] = useState('all');
const [inventorySortField, setInventorySortField] = useState('event_date');
const [inventorySortDirection, setInventorySortDirection] = useState('desc'); // 'asc' or 'desc'
const [allocationManagementInventory, setAllocationManagementInventory] = React.useState(null);
const [leadsSourceFilter, setLeadsSourceFilter] = useState('all');
const [leadsBusinessTypeFilter, setLeadsBusinessTypeFilter] = useState('all');
const [leadsEventFilter, setLeadsEventFilter] = useState('all');
const [leadsSortField, setLeadsSortField] = useState('date_of_enquiry');
const [leadsSortDirection, setLeadsSortDirection] = useState('desc');
const [showBulkAssignModal, setShowBulkAssignModal] = useState(false);
const [bulkAssignSelections, setBulkAssignSelections] = useState({});
const [bulkAssignLoading, setBulkAssignLoading] = useState(false);
const [selectedStatusFilters, setSelectedStatusFilters] = useState([]);
const [showStatusFilterDropdown, setShowStatusFilterDropdown] = useState(false);
const statusDropdownRef = React.useRef(null);
const [stadiums, setStadiums] = useState([]);
const [showStadiumForm, setShowStadiumForm] = useState(false);
const [editingStadium, setEditingStadium] = useState(null);
const [stadiumFormData, setStadiumFormData] = useState({});
const [stadiumSortField, setStadiumSortField] = useState('name');
const [stadiumSortDirection, setStadiumSortDirection] = useState('asc');
const [stadiumSearchQuery, setStadiumSearchQuery] = useState('');
const [stadiumSportFilter, setStadiumSportFilter] = useState('all');
const [dynamicRoles, setDynamicRoles] = useState({});
const [rolesLoaded, setRolesLoaded] = useState(false);
const [viewMode, setViewMode] = useState('leads'); // 'leads' or 'clients'
const [clients, setClients] = useState([]);
const [clientsLoading, setClientsLoading] = useState(false);
const [selectedClient, setSelectedClient] = useState(null);
const [showClientDetail, setShowClientDetail] = useState(false);
const [phoneCheckLoading, setPhoneCheckLoading] = useState(false);
const [clientSuggestion, setClientSuggestion] = useState(null);
const [showClientSuggestion, setShowClientSuggestion] = useState(false);
const [phoneCheckTimeout, setPhoneCheckTimeout] = useState(null);
const [showStatusProgressModal, setShowStatusProgressModal] = useState(false);
const [statusProgressOptions, setStatusProgressOptions] = useState([]);
const [selectedStatus, setSelectedStatus] = useState('');
const [followUpDate, setFollowUpDate] = useState('');
const [followUpNotes, setFollowUpNotes] = useState('');
const [uploadPreview, setUploadPreview] = useState(null);
const [showPreview, setShowPreview] = useState(false);
const [proceedAfterPreview, setProceedAfterPreview] = useState(false);
const [previewLoading, setPreviewLoading] = useState(false);
const [clientDetectionResults, setClientDetectionResults] = useState([]);
const [showClientDetectionResults, setShowClientDetectionResults] = useState(false);
const [calendarFilters, setCalendarFilters] = React.useState({});
const [showImportModal, setShowImportModal] = React.useState(false);



// 1. Enhanced Customer Type Classification
const [paymentData, setPaymentData] = useState({
legal_name: '',
gstin: '',
registered_address: '',
category_of_sale: 'Corporate',
type_of_sale: 'Tour',
indian_state: 'Haryana',
is_outside_india: false,

// NEW: Enhanced customer classification
customer_type: 'indian', // 'indian', 'nri', 'foreigner'
event_location: 'india', // 'india', 'outside_india'
payment_currency: 'INR', // 'INR', 'USD', 'EUR', 'GBP'

advance_amount: '',
payment_method: 'bank_transfer',
transaction_id: '',
payment_date: new Date().toISOString().split('T')[0],
payment_proof: '',
notes: '',
gst_certificate: '',
pan_card: '',

invoice_items: [
{
description: '',
additional_info: '',
quantity: 1,
rate: 0
}
],

service_fee_amount: '',
gst_rate: 5,

// NEW: TCS fields
tcs_applicable: false,
tcs_rate: 5, // Default to 5%
tcs_amount: 0,
tcs_rate_editable: true, // Allow manual override
});

const addInvoiceItem = () => {
const newItems = [...(paymentData.invoice_items || [])];
newItems.push({
description: '',
additional_info: '',
quantity: 1,
rate: 0
});
handlePaymentInputChange('invoice_items', newItems);
};



const removeInvoiceItem = (index) => {
if (paymentData.invoice_items.length <= 1) {
alert('At least one invoice item is required');
return;
}
const newItems = paymentData.invoice_items.filter((_, i) => i !== index);
handlePaymentInputChange('invoice_items', newItems);
};



// Fixed version for post-deployment input issues
const updateInvoiceItem = (index, field, value) => {
// Create a completely new array to ensure React detects the change
const newItems = JSON.parse(JSON.stringify(paymentData.invoice_items || []));
newItems[index][field] = value;

// Force a state update with new reference
setPaymentData(prevData => ({
...prevData,
invoice_items: newItems
}));
}; 

// Enhanced GST and TCS Calculation Function
const calculateGSTAndTCS = (baseAmount, paymentData) => {
const isIntraState = paymentData.indian_state === 'Haryana' && !paymentData.is_outside_india;
const isOutsideIndia = paymentData.event_location === 'outside_india';
const isIndian = paymentData.customer_type === 'indian';
const isNRIOrForeigner = ['nri', 'foreigner'].includes(paymentData.customer_type);
const isINRPayment = paymentData.payment_currency === 'INR';
const isCorporate = paymentData.category_of_sale === 'Corporate';
const isServiceFee = paymentData.type_of_sale === 'Service Fee';

let gstApplicable = false;
let gstRate = 0;
let tcsApplicable = false;
let tcsRate = paymentData.tcs_rate || 5; // Standard TCS rate

// TCS Logic: CORRECTED
if (isOutsideIndia) {
// Event outside India
if (isIndian) {
// All Indian clients pay TCS for events outside India
tcsApplicable = true;
} else if (isNRIOrForeigner && isINRPayment) {
// NRI/Foreigner pay TCS only if they pay in INR
tcsApplicable = true;
}
}
// If event is in India, NO ONE pays TCS

// GST Logic: CORRECTED with Service Fee handling
if (isServiceFee) {
// Service Fee: Always 18% GST regardless of customer type or location
gstApplicable = true;
gstRate = 18;
} else {
// Tour Package: Variable rates based on customer type and location
if (isIndian) {
// Domestic clients (Indian)
if (isCorporate) {
// B2B: Always 18% regardless of event location
gstApplicable = true;
gstRate = 18;
} else {
// B2C: Always 5% regardless of event location  
gstApplicable = true;
gstRate = 5;
}
} else if (isNRIOrForeigner) {
// International clients (NRI/Foreigner)
if (!isOutsideIndia) {
// Event in India: Always 5% GST for international clients
gstApplicable = true;
gstRate = 5;
} else {
// Event outside India
if (isINRPayment) {
// Pay in INR: 5% GST
gstApplicable = true;
gstRate = 5;
} else {
// Pay in foreign currency: No GST
gstApplicable = false;
}
}
}
}

// Calculate amounts
const gstAmount = gstApplicable ? (baseAmount * gstRate) / 100 : 0;
const cgstAmount = gstApplicable && isIntraState ? gstAmount / 2 : 0;
const sgstAmount = gstApplicable && isIntraState ? gstAmount / 2 : 0;
const igstAmount = gstApplicable && !isIntraState ? gstAmount : 0;

const tcsAmount = tcsApplicable ? (baseAmount * tcsRate) / 100 : 0;

return {
gst: {
applicable: gstApplicable,
rate: gstRate,
cgst: cgstAmount,
sgst: sgstAmount,
igst: igstAmount,
total: gstAmount
},
tcs: {
applicable: tcsApplicable,
rate: tcsRate,
amount: tcsAmount
},
finalAmount: baseAmount + gstAmount + tcsAmount
};


};



const formatCurrency = (amount) => {
return amount.toLocaleString('en-IN', {
minimumFractionDigits: 2,
maximumFractionDigits: 2
});
};



// Safe number formatting helper
const safeFormatNumber = (value) => {
const num = parseFloat(value) || 0;
return num.toLocaleString('en-IN');
};



const handlePaymentInputChange = (field, value) => {
  setPaymentData(prev => {
    const updated = { ...prev, [field]: value };
    
    // Auto-update GST rate based on type_of_sale
    if (field === 'type_of_sale') {
      if (value === 'Service Fee') {
        updated.gst_rate = 18;
      } else if (value === 'Tour') {
        updated.gst_rate = 5;
      } else {
        updated.gst_rate = 18;
      }
    }
    
    // Handle TCS rate changes manually
    if (field === 'tcs_rate') {
      const baseAmount = window.getBaseAmount(updated);
      const newTcsAmount = updated.tcs_applicable ? (baseAmount * parseFloat(value)) / 100 : 0;
      updated.tcs_amount = newTcsAmount;
      // Mark that rate was manually selected
      updated.tcs_rate_manual = true;
    }
    
    // Auto-determine TCS applicability when customer type or currency changes
    if (['customer_type', 'event_location', 'payment_currency'].includes(field)) {
      const baseAmount = window.getBaseAmount(updated);
      const calculation = calculateGSTAndTCS(baseAmount, updated);
      updated.tcs_applicable = calculation.tcs.applicable;
      
      // Only update TCS rate if it wasn't manually set, or if customer type changed
      if (!updated.tcs_rate_manual || field === 'customer_type') {
        updated.tcs_rate = calculation.tcs.rate;
        updated.tcs_rate_manual = false; // Reset manual flag when customer type changes
      }
      
      // Recalculate TCS amount with current (possibly manual) rate
      const currentTcsRate = updated.tcs_rate || calculation.tcs.rate;
      updated.tcs_amount = calculation.tcs.applicable ? (baseAmount * currentTcsRate) / 100 : 0;
    }
    
    // Recalculate TCS when invoice items or service fee amount changes
    if (['invoice_items', 'service_fee_amount'].includes(field)) {
      const baseAmount = window.getBaseAmount(updated);
      if (updated.tcs_applicable) {
        const currentTcsRate = updated.tcs_rate || 5;
        updated.tcs_amount = (baseAmount * currentTcsRate) / 100;
      }
    }
    
    return updated;
  });
};



// Edit order function - in App scope
const openEditOrderForm = (order) => {
if (!order) {
alert('Order data not found');
return;
}

if (!window.hasPermission('orders', 'write')) {
alert('You do not have permission to edit orders');
return;
}

setCurrentOrderForEdit(order);
setOrderEditData({
...order,
status: order.status || 'pending_approval',
rejection_reason: order.rejection_reason || '',
assigned_to: order.assigned_to || ''
});
setShowEditOrderForm(true);
};


const fetchClients = async () => {
setClientsLoading(true);
try {
const response = await window.apicall('/clients');
setClients(response.data || []);
console.log(`Fetched ${response.data?.length || 0} clients`);
} catch (error) {
console.error('Failed to fetch clients:', error);
alert('Failed to load clients: ' + error.message);
} finally {
setClientsLoading(false);
}
};



const fetchUserRoles = async () => {
try {
const response = await window.apicall('/roles');
const roleMap = {};

// Convert API roles to permission format
response.data.forEach(role => {
roleMap[role.name] = {
label: role.label,
permissions: role.permissions
};


});

setDynamicRoles(roleMap);
setRolesLoaded(true);
} catch (error) {
console.error('Failed to fetch roles:', error);
// Fallback to hardcoded roles if API fails
setDynamicRoles(window.USER_ROLES);
setRolesLoaded(true);
}
};



const handleStatusFilterToggle = (status) => {
setSelectedStatusFilters(prev => {
if (prev.includes(status)) {
return prev.filter(s => s !== status);
} else {
return [...prev, status];
}
});
};



const handleSelectAllStatuses = () => {
if (selectedStatusFilters.length === Object.keys(window.LEAD_STATUSES).length) {
setSelectedStatusFilters([]);
} else {
setSelectedStatusFilters(Object.keys(window.LEAD_STATUSES));
}
};



// Add this function for checking phone numbers
const checkPhoneForClient = async (phone) => {
if (!phone || phone.length < 10) {
setClientSuggestion(null);
setShowClientSuggestion(false);
return;
}

// Normalize phone number (remove spaces, +91, etc.)
const normalizedPhone = phone.replace(/[\s\-\+]/g, '').replace(/^91/, '');

if (normalizedPhone.length < 10) {
setClientSuggestion(null);
setShowClientSuggestion(false);
return;
}

setPhoneCheckLoading(true);
try {
const response = await window.apicall(`/leads/check-phone/${normalizedPhone}`);
if (response.exists && response.suggestion) {
setClientSuggestion(response.suggestion);
setShowClientSuggestion(true);
} else {
setClientSuggestion(null);
setShowClientSuggestion(false);
}
} catch (error) {
console.error('Error checking phone:', error);
setClientSuggestion(null);
setShowClientSuggestion(false);
} finally {
setPhoneCheckLoading(false);
}
};



// Add this function to handle phone input changes with debouncing
const handlePhoneChange = (value) => {
setLeadFormData(prev => ({ ...prev, phone: value }));

// Clear existing timeout
if (phoneCheckTimeout) {
clearTimeout(phoneCheckTimeout);
}

// Set new timeout for phone check (debounce)
const newTimeout = setTimeout(() => {
checkPhoneForClient(value);
}, 500); // Check after 500ms of no typing

setPhoneCheckTimeout(newTimeout);
};



// Add this function to apply client suggestions
const applyClientSuggestion = () => {
if (clientSuggestion) {
setLeadFormData(prev => ({
...prev,
assigned_to: clientSuggestion.suggested_assigned_to,
company: clientSuggestion.client_history[0]?.company || prev.company,
city_of_residence: clientSuggestion.client_history[0]?.city_of_residence || prev.city_of_residence,
country_of_residence: clientSuggestion.client_history[0]?.country_of_residence || prev.country_of_residence,
business_type: clientSuggestion.client_history[0]?.business_type || prev.business_type,
annual_income_bracket: clientSuggestion.client_history[0]?.annual_income_bracket || prev.annual_income_bracket
}));
setShowClientSuggestion(false);
alert('Client information applied! This lead will be linked to the existing client.');
}
};



const handleClearAllStatuses = () => {
setSelectedStatusFilters([]);
};



const getStatusFilterDisplayText = () => {
if (selectedStatusFilters.length === 0) {
return 'All Statuses';
} else if (selectedStatusFilters.length === 1) {
return window.LEAD_STATUSES[selectedStatusFilters[0]].label;
} else if (selectedStatusFilters.length === Object.keys(window.LEAD_STATUSES).length) {
return 'All Statuses';
} else {
return `${selectedStatusFilters.length} statuses selected`;
}
}; 

// Form helpers
const openStadiumForm = (stadium = null) => {
setEditingStadium(stadium);
setStadiumFormData(stadium || {});
setShowStadiumForm(true);
};



const closeStadiumForm = () => {
setShowStadiumForm(false);
setEditingStadium(null);
setStadiumFormData({});
};



const handleStadiumInputChange = (name, value) => {
setStadiumFormData(prev => ({
...prev,
[name]: value
}));
};




const updateOrderStatus = async (orderId, newStatus, rejectionReason = '') => {
setLoading(true);
try {
const updateData = {
status: newStatus,
updated_date: new Date().toISOString(),
updated_by: user.name
};



// Add specific fields based on status
if (newStatus === 'rejected' && rejectionReason) {
updateData.rejection_reason = rejectionReason;
updateData.rejected_date = new Date().toISOString();
updateData.rejected_by = user.name;
} else if (newStatus === 'approved') {
updateData.approved_date = new Date().toISOString();
updateData.approved_by = user.name;

// Generate invoice if needed
const order = orders.find(o => o.id === orderId);
if (order && (order.requires_gst_invoice || order.gstin)) {
const invoiceNumber = 'STTS/INV/' + (new Date().getFullYear()) + '/' + (String(Date.now()).slice(-6));
updateData.invoice_number = invoiceNumber;
updateData.invoice_id = Date.now();
}
} else if (newStatus === 'pending_approval') {
// Clear rejection/approval data when moving back to pending
updateData.rejection_reason = null;
updateData.rejected_date = null;
updateData.rejected_by = null;
updateData.approved_date = null;
updateData.approved_by = null;
}

// Update in backend
await window.apicall('/orders/' + (orderId), {
method: 'PUT',
body: JSON.stringify(updateData)
});

// Update local state
setOrders(prev => 
prev.map(order => 
order.id === orderId 
? { ...order, ...updateData }
: order
)
);

alert('Order status updated to: ' + (newStatus));
} catch (error) {
console.error('Error updating order status:', error);
alert('Failed to update order status');
} finally {
setLoading(false);
}
}

const [invoices, setInvoices] = useState([]);
const [deliveries, setDeliveries] = useState([]);
const [receivables, setReceivables] = useState([]);
const [emailNotifications, setEmailNotifications] = useState([]);
const [allUsers, setAllUsers] = useState([]);
const [users, setUsers] = useState([]);
const [myLeads, setMyLeads] = useState([]);
const [myQuoteRequested, setMyQuoteRequested] = useState([]);
const [myOrders, setMyOrders] = useState([]);
const [myDeliveries, setMyDeliveries] = useState([]);
const [myReceivables, setMyReceivables] = useState([]);

// Add data fetching function
const fetchData = async () => {
if (!isLoggedIn || !authToken) return;

try {
const [leadsData, inventoryData, ordersData, invoicesData, deliveriesData, clientsData] = await Promise.all([
window.apicall('/leads').catch(() => ({ data: [] })),
window.apicall('/inventory').catch(() => ({ data: [] })),
window.apicall('/orders').catch(() => ({ data: [] })),
window.apicall('/invoices').catch(() => ({ data: [] })),
window.apicall('/deliveries').catch(() => ({ data: [] })),
window.apicall('/clients').catch(() => ({ data: [] }))
]);

setLeads(leadsData.data || []);
setInventory(inventoryData.data || []);
setOrders(ordersData.data || []);
setInvoices(invoicesData.data || []);
setDeliveries(deliveriesData.data || []);
setClients(clientsData.data || []);
} catch (error) {
console.error('Error fetching data:', error);
}
};



// Fetch data when logged in
useEffect(() => {
if (isLoggedIn) {
fetchData();
}


// Fetch My Actions data
console.log('useEffect triggered - activeTab:', activeTab, 'isLoggedIn:', isLoggedIn);
if (activeTab === 'myactions') {
} else if (activeTab === 'finance') {
console.log('Finance tab active, fetching financial data...');
fetchFinancialData();
console.log('My Actions tab is active, calling fetchMyActions...');
fetchMyActions();
}
}, [isLoggedIn, activeTab]);

useEffect(() => {
if (isLoggedIn) {
fetchReminders();
// Set up auto-refresh every 5 minutes
const interval = setInterval(fetchReminders, 5 * 60 * 1000);
return () => clearInterval(interval);
}
}, [isLoggedIn]);


useEffect(() => {
if (viewMode === 'clients' && isLoggedIn) {
fetchClients();
}
}, [viewMode, isLoggedIn]);




// Add after other state variables

const [searchQuery, setSearchQuery] = useState('');
const [statusFilter, setStatusFilter] = useState('all');
// Google Cloud Storage Integration
// Google Cloud Storage Integration


const [showOrderDetail, setShowOrderDetail] = useState(false);
const [selectedOrderForAssignment, setSelectedOrderForAssignment] = useState(null);
const [showOrderAssignmentModal, setShowOrderAssignmentModal] = useState(false);
const [showEditOrderForm, setShowEditOrderForm] = useState(false);
const [currentOrderForEdit, setCurrentOrderForEdit] = useState(null);
const [orderEditData, setOrderEditData] = useState({});
const [inventoryDueDateFilter, setInventoryDueDateFilter] = useState('all');
const [inventoryEventFilter, setInventoryEventFilter] = useState('all');
const [currentLeadsPage, setCurrentLeadsPage] = useState(1);
const [currentInventoryPage, setCurrentInventoryPage] = useState(1);
const [itemsPerPage] = useState(10);
const [currentOrderDetail, setCurrentOrderDetail] = useState(null);

// Form states
const [showAddForm, setShowAddForm] = useState(false);
const [showEditForm, setShowEditForm] = useState(false);
const [showAssignForm, setShowAssignForm] = useState(false);
const [showPaymentForm, setShowPaymentForm] = useState(false);
const [showLeadDetail, setShowLeadDetail] = useState(false);
const [showAllocationForm, setShowAllocationForm] = useState(false);
const [showEditInventoryForm, setShowEditInventoryForm] = useState(false);
const [showUserManagement, setShowUserManagement] = useState(false);
const [showUserForm, setShowUserForm] = useState(false);
const [roles, setRoles] = useState([]);
const [showRoleForm, setShowRoleForm] = useState(false);
const [rolesInitialized, setRolesInitialized] = useState(false);

// Financials state
const [financialData, setFinancialData] = useState({
activeSales: [],
sales: [],
receivables: [],
payables: [],
expiringInventory: []
});
const [financialFilters, setFinancialFilters] = useState({
clientName: '',
assignedPerson: '',
dateFrom: '',
dateTo: '',
status: 'all',
expiringDays: 7,
clientName: '',
assignedPerson: '',
dateFrom: '',
dateTo: '',
status: 'all'
});
const [activeFinancialTab, setActiveFinancialTab] = useState('sales');
const [financialStats, setFinancialStats] = useState({
totalSales: 0,
totalReceivables: 0,
totalPayables: 0,
expiringValue: 0
});
const [editingRole, setEditingRole] = useState(null);
const [roleFormData, setRoleFormData] = useState({
name: '',
label: '',
description: '',
permissions: {
dashboard: { read: false, write: false, delete: false, manage_users: false },
leads: { read: false, write: false, delete: false, assign: false, progress: false },
inventory: { read: false, write: false, delete: false, allocate: false },
orders: { read: false, write: false, delete: false, approve: false, assign: false },
finance: { read: false, write: false, delete: false, approve: false },
delivery: { read: false, write: false, delete: false },
users: { read: false, write: false, delete: false, manage_roles: false }
}
});
const [editingUser, setEditingUser] = useState(null);
const [showCSVUploadModal, setShowCSVUploadModal] = useState(false);
const [availableRoles, setAvailableRoles] = useState([]);
const [csvUploadType, setCSVUploadType] = useState('');
const [currentForm, setCurrentForm] = useState('');
const [currentLead, setCurrentLead] = useState(null);
const [currentInventory, setCurrentInventory] = useState(null);
const [darkMode, setDarkMode] = useState(() => {
return localStorage.getItem('crm_dark_mode') === 'true';
});
const [currentUser, setCurrentUser] = useState(null);
const [formData, setFormData] = useState({});
const [allocationData, setAllocationData] = useState({});
const [userFormData, setUserFormData] = useState({});
const [showInvoicePreview, setShowInvoicePreview] = useState(false);
const [currentInvoice, setCurrentInvoice] = useState(null);
const [showDeliveryForm, setShowDeliveryForm] = useState(false);
const [currentDelivery, setCurrentDelivery] = useState(null);
const [deliveryFormData, setDeliveryFormData] = useState({});
const [showPaymentPostServiceForm, setShowPaymentPostServiceForm] = useState(false);
const [showHelpGuide, setShowHelpGuide] = useState(false);
const [paymentPostServiceData, setPaymentPostServiceData] = useState({});
const [showChoiceModal, setShowChoiceModal] = useState(false);
const [currentLeadForChoice, setCurrentLeadForChoice] = useState(null);
const [choiceOptions, setChoiceOptions] = useState([]);


// Dashboard stats
const [dashboardStats, setDashboardStats] = useState({
totalLeads: 0,
activeDeals: 0,
thisMonthRevenue: 0,
pendingDeliveries: 0,
inventoryValue: 0
});

// Dashboard filter states for pie charts
const [dashboardFilter, setDashboardFilter] = useState('overall');
const [selectedSalesPerson, setSelectedSalesPerson] = useState('');
const [selectedEvent, setSelectedEvent] = useState('');
const [events, setEvents] = useState([]);
const [salesPeople, setSalesPeople] = useState([]);
const [chartInstances, setChartInstances] = useState({
leadSplit: null,
tempCount: null,
tempValue: null
});


// Permission check function
// Updated Permission check function with dynamic roles
window.hasPermission = function(module, action) {
if (user?.role === 'super_admin') return true;
if (!user || !user.role) {
console.log('No user or role found');
return false;
}

// Use dynamic roles if loaded, otherwise fallback to hardcoded
const availableRoles = rolesLoaded ? dynamicRoles : window.USER_ROLES;
const userRole = availableRoles[user.role];

if (!userRole) {
console.log('Role not found in available roles:', user.role);
console.log('Available roles:', Object.keys(availableRoles));
return false;
}

const modulePermissions = userRole.permissions[module];
if (!modulePermissions) {
console.log('Module permissions not found:', module);
return false;
}

const hasAccess = modulePermissions[action] === true;
console.log(`Permission check: ${user.role} -> ${module}.${action} = ${hasAccess}`);
return hasAccess;
};



const canAccessTab = (tabId) => {
if (!user) return false;
// My Actions is available to all logged-in users
if (tabId === 'myactions') return true;
// Reminders available to users who can read leads
if (tabId === 'reminders') return window.hasPermission('leads', 'read');
// Sports Calendar available to users who can read leads (for now, or adjust as needed)
if (tabId === 'sports-calendar') return window.hasPermission('leads', 'read');
return window.hasPermission(tabId, 'read');
};




// Test mode logging
useEffect(() => {
console.log('Test mode state:', testMode);
console.log('Current user:', currentUser);
console.log('Is super admin:', currentUser?.role === 'super_admin');
console.log('User object:', JSON.stringify(currentUser));

// Force re-render when user changes
if (currentUser && currentUser.role === 'super_admin') {
console.log('Super admin logged in - test mode toggle should be visible');
}
}, [testMode, currentUser]);

React.useEffect(() => {
if (isLoggedIn) {
fetchData();
fetchStadiums(); // Add this line
}
}, [isLoggedIn]); 

// Persist authentication state
useEffect(() => {
try {
const savedUser = localStorage.getItem('crm_user');
const savedLoginState = localStorage.getItem('crm_auth_token');

if (savedUser && savedLoginState) {
const userData = JSON.parse(savedUser);
setUser(userData);
setCurrentUser(userData);
authToken = savedLoginState;
setIsLoggedIn(true);
// Fetch users for dropdowns
fetchUsers();
// Clear any cached user management data
setUsers([]);
}
} catch (e) {
console.log('Failed to restore auth state:', e);
}
}, []);

useEffect(() => {
localStorage.setItem('crm_active_tab', activeTab);
}, [activeTab]);


// Calculate dashboard stats
// Initialize dashboard stats
useEffect(() => {
if (isLoggedIn) {
calculateDashboardStats();
}
}, [isLoggedIn]);

useEffect(() => {
const handleClickOutside = (event) => {
if (statusDropdownRef.current && !statusDropdownRef.current.contains(event.target)) {
setShowStatusFilterDropdown(false);
}
};


document.addEventListener('mousedown', handleClickOutside);
return () => document.removeEventListener('mousedown', handleClickOutside);
}, []);

// Add useEffect to extract filter data when leads or users change
useEffect(() => {
if (leads.length > 0 || users.length > 0) {
extractFiltersData();
}
}, [leads, users]);

const getFilteredLeads = () => {
let filteredLeads = [...leads];

if (dashboardFilter === 'salesperson' && selectedSalesPerson) {
filteredLeads = filteredLeads.filter(lead => lead.assigned_to === selectedSalesPerson);
}

if (dashboardFilter === 'event' && selectedEvent) {
filteredLeads = filteredLeads.filter(lead => lead.lead_for_event === selectedEvent);
}

return filteredLeads;
};    

// Update stats when filter changes
useEffect(() => {
if (leads.length > 0) {
calculateDashboardStats();
}
}, [dashboardFilter, selectedSalesPerson, selectedEvent, leads]);

useEffect(() => {
console.log('Chart initialization useEffect triggered', {
activeTab,
leadsCount: leads.length,
chartExists: typeof Chart !== 'undefined'
});

if (activeTab === 'dashboard' && leads.length > 0 && typeof Chart !== 'undefined') {
// Wait a bit longer for DOM to be ready and add additional checks
const timeoutId = setTimeout(() => {
console.log('Attempting to initialize charts...');

// Check if canvas elements exist
const canvas1 = document.getElementById('leadSplitChart');
const canvas2 = document.getElementById('tempCountChart');  
const canvas3 = document.getElementById('tempValueChart');

console.log('Canvas elements found:', {
leadSplit: !!canvas1,
tempCount: !!canvas2,
tempValue: !!canvas3
});

if (canvas1 && canvas2 && canvas3) {
initializeChartsAdvanced();

// Then update with current data
setTimeout(() => {
const filteredLeads = getFilteredLeads();
updateCharts(filteredLeads);
}, 100);
} else {
console.log('Canvas elements not ready yet, retrying...');
// Retry after another delay
setTimeout(() => {
initializeChartsAdvanced();
const filteredLeads = getFilteredLeads();
updateCharts(filteredLeads);
}, 500);
}
}, 200); // Increased delay

return () => clearTimeout(timeoutId);
}

// Cleanup when leaving dashboard
if (activeTab !== 'dashboard') {
if (chartInstances.leadSplit) {
chartInstances.leadSplit.destroy();
chartInstances.leadSplit = null;
}
if (chartInstances.tempCount) {
chartInstances.tempCount.destroy();
chartInstances.tempCount = null;
}
if (chartInstances.tempValue) {
chartInstances.tempValue.destroy();
chartInstances.tempValue = null;
}
}
}, [activeTab, leads.length]); // Include leads.length to ensure data is available


// Add useEffect to update stats when filter changes
useEffect(() => {
if (leads.length > 0) {
calculateDashboardStats();
}
}, [dashboardFilter, selectedSalesPerson, selectedEvent]);

// Apply dark mode on mount
useEffect(() => {
if (darkMode) {
document.documentElement.classList.add('dark');
} else {
document.documentElement.classList.remove('dark');
}
}, [darkMode]);
// Chart initialization
useEffect(() => {
if (isLoggedIn && window.hasPermission('finance', 'read')) {
const chartElement = document.getElementById('receivablesPieChart');
if (chartElement && receivables.filter(r => r.status === 'pending').length > 0) {
const ctx = chartElement.getContext('2d');

// Destroy existing chart if any
if (window.receivablesChart) {
window.receivablesChart.destroy();
}

// Group receivables by salesperson
const receivablesBySalesperson = {};
receivables
.filter(r => r.status === 'pending')
.forEach(receivable => {
const salesperson = receivable.assigned_to || 'Unassigned';
receivablesBySalesperson[salesperson] = (receivablesBySalesperson[salesperson] || 0) + receivable.expected_amount;
});

window.receivablesChart = new Chart(ctx, {
type: 'pie',
data: {
labels: Object.keys(receivablesBySalesperson),
datasets: [{
data: Object.values(receivablesBySalesperson),
backgroundColor: [
'#3B82F6', '#EF4444', '#10B981', '#F59E0B', 
'#8B5CF6', '#EC4899', '#14B8A6', '#F97316'
]
}]
},
options: {
responsive: true,
maintainAspectRatio: false
}
});
}
}
}, [isLoggedIn, receivables, user]);
// Add this useEffect to handle scheduled notifications
useEffect(() => {
const checkScheduledNotifications = () => {
const now = new Date();
emailNotifications
.filter(n => n.status === 'scheduled' && new Date(n.scheduled_date) <= now)
.forEach(notification => {
sendEmailNotification(notification);
});
};



const interval = setInterval(checkScheduledNotifications, 60000); // Check every minute
return () => clearInterval(interval);
}, [emailNotifications]);

// ADD this new useEffect after your existing ones:
useEffect(() => {
if (users.length === 0) {
setUsers(window.DEFAULT_USERS);
}
}, []);
// Fetch all users on app initialization
useEffect(() => {
if (isLoggedIn && allUsers.length === 0) {
fetchUsers();
}
}, [isLoggedIn]);


useEffect(() => {
try {
localStorage.setItem('crm_deliveries', JSON.stringify(deliveries));
} catch (e) {
console.log('Failed to save deliveries:', e);
}
}, [deliveries]);

useEffect(() => {
try {
localStorage.setItem('crm_receivables', JSON.stringify(receivables));
} catch (e) {
console.log('Failed to save receivables:', e);
}
}, [receivables]);

useEffect(() => {
try {
localStorage.setItem('crm_email_notifications', JSON.stringify(emailNotifications));
} catch (e) {
console.log('Failed to save notifications:', e);
}
}, [emailNotifications]);


const assignOrderToService = async (orderId, assignee) => {

const openEditOrderForm = (order) => {
alert(`Edit Order: ${order.order_number}

Client: ${order.client_name}
Email: ${order.client_email}
Event: ${order.event_name || 'N/A'}
Tickets: ${order.tickets_allocated || 0}
Amount: ‚Çπ${order.total_amount || 0}

Status: ${order.status}`);
};


setLoading(true);
try {
const updateData = {
assigned_to: assignee, // This will now be an email
status: 'service_assigned',
assigned_date: new Date().toISOString()
};



await window.apicall('/orders/' + (orderId), {
method: 'PUT',
body: JSON.stringify(updateData)
});

setOrders(prev => 
prev.map(order => 
order.id === orderId 
? { ...order, ...updateData }
: order
)
);

const openOrderForm = () => {
setShowOrderForm(true);
// Initialize any form data if needed
};



// Create delivery entry when assigning to supply team
const order = orders.find(o => o.id === orderId);
if (order) {
const newDelivery = {
// id will be generated by Firestore
order_id: orderId,
order_number: order.order_number,
client_name: order.client_name,
client_email: order.client_email,
client_phone: order.client_phone,
event_name: order.event_name || 'N/A',
event_date: order.event_date || new Date().toISOString().split('T')[0],
tickets_count: order.tickets_allocated || 0,
amount: order.total_amount || 0,

// Delivery form fields
delivery_type: 'offline',
pickup_location: '',
pickup_date: '',
pickup_time: '',
delivery_location: order.delivery_address || order.client_address || '',
delivery_date: '',
delivery_time: '',
delivery_person: assignee,
delivery_notes: '',
online_platform: '',
online_link: '',

// Status and metadata
assigned_to: assignee, // This will now be an email
status: 'pending',
created_date: new Date().toISOString().split('T')[0],
created_by: user.name
};



// Add to deliveries state
setDeliveries(prev => [...prev, newDelivery]);

console.log('Delivery entry created:', newDelivery);

// Save delivery to backend
try {
const deliveryResponse = await window.apicall('/deliveries', {
method: 'POST',
body: JSON.stringify(newDelivery)
});
console.log('Delivery saved to backend:', deliveryResponse);
// Update local state with backend response if it has an ID
if (deliveryResponse && deliveryResponse.data && deliveryResponse.data.id) {
setDeliveries(prev => prev.map(d => 
d.id === newDelivery.id ? { ...d, id: deliveryResponse.data.id } : d
));
}
} catch (error) {
console.error('Failed to save delivery to backend:', error);
}
}

alert('Order assigned to ' + (assignee) + ' successfully!');
} catch (error) {
console.error('Error assigning order:', error);
alert('Failed to assign order');
} finally {
setLoading(false);
}
};



const fetchReminders = async () => {
if (!isLoggedIn) return;

try {
const response = await window.apicall('/reminders');
if (response.data) {
const userReminders = response.data.filter(r => 
r.assigned_to === user.email || 
['sales_manager', 'admin', 'super_admin'].includes(user.role)
);

setReminders(userReminders);

// Calculate stats
const now = new Date();
const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

const stats = {
total: userReminders.length,
overdue: userReminders.filter(r => new Date(r.due_date) < now && r.status === 'pending').length,
due_today: userReminders.filter(r => {
const dueDate = new Date(r.due_date);
return dueDate >= today && dueDate < new Date(today.getTime() + 24*60*60*1000) && r.status === 'pending';
}).length,
pending: userReminders.filter(r => r.status === 'pending').length
};



setReminderStats(stats);
}
} catch (error) {
console.error('Error fetching reminders:', error);
}
};



// Complete a reminder
const completeReminder = async (reminderId, notes = '') => {
try {
await window.apicall(`/reminders/${reminderId}/complete`, {
method: 'POST',
body: JSON.stringify({ notes })
});

setReminders(prev => prev.map(r => 
r.id === reminderId 
? { ...r, status: 'completed', completed_date: new Date().toISOString() }
: r
));

alert('‚úÖ Reminder completed successfully!');
await fetchReminders();
} catch (error) {
console.error('Error completing reminder:', error);
alert('‚ùå Failed to complete reminder');
}
};



// Snooze a reminder
const snoozeReminder = async (reminderId, hours = 24) => {
try {
const snoozeUntil = new Date();
snoozeUntil.setHours(snoozeUntil.getHours() + hours);

await window.apicall(`/reminders/${reminderId}/snooze`, {
method: 'POST',
body: JSON.stringify({ snooze_until: snoozeUntil.toISOString() })
});

alert(`‚è∞ Reminder snoozed for ${hours} hours`);
await fetchReminders();
} catch (error) {
console.error('Error snoozing reminder:', error);
alert('‚ùå Failed to snooze reminder');
}
};



const deleteReminder = async (reminderId) => {
// Confirm before deleting
if (!confirm('Are you sure you want to delete this reminder? This action cannot be undone.')) {
return;
}

try {
await window.apicall(`/reminders/${reminderId}`, {
method: 'DELETE'
});

// Update local state to remove the deleted reminder
setReminders(prevReminders => 
prevReminders.filter(r => r.id !== reminderId)
);

// Update reminder stats
await fetchReminders();

alert('üóëÔ∏è Reminder deleted successfully!');
} catch (error) {
console.error('Error deleting reminder:', error);
alert('‚ùå Failed to delete reminder: ' + error.message);
}
}; 

// Helper functions
const formatRelativeTime = (dateString) => {
const date = new Date(dateString);
const now = new Date();
const diffMs = date - now;
const diffHours = Math.round(diffMs / (1000 * 60 * 60));
const diffDays = Math.round(diffMs / (1000 * 60 * 60 * 24));

if (diffMs < 0) {
const pastHours = Math.abs(diffHours);
const pastDays = Math.abs(diffDays);

if (pastDays > 0) {
return `${pastDays} day${pastDays > 1 ? 's' : ''} overdue`;
} else {
return `${pastHours} hour${pastHours > 1 ? 's' : ''} overdue`;
}
} else {
if (diffDays > 0) {
return `in ${diffDays} day${diffDays > 1 ? 's' : ''}`;
} else if (diffHours > 0) {
return `in ${diffHours} hour${diffHours > 1 ? 's' : ''}`;
} else {
return 'now';
}
}
};



const getPriorityColor = (priority) => {
switch (priority) {
case 'urgent': return 'text-red-600 bg-red-100';
case 'high': return 'text-orange-600 bg-orange-100';
case 'medium': return 'text-blue-600 bg-blue-100';
case 'low': return 'text-gray-600 bg-gray-100';
default: return 'text-gray-600 bg-gray-100';
}
};



const openOrderDetail = (order) => {
setCurrentOrderDetail(order);
setShowOrderDetail(true);
};

const renderOrderAssignmentModal = () => {
if (!showOrderAssignmentModal || !selectedOrderForAssignment) return null;

const supplyTeamUsers = (users || []).filter(u => 
['supply_executive', 'supply_sales_service_manager'].includes(u.role)
);

return React.createElement('div', { 
className: 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50',
onClick: (e) => {
if (e.target === e.currentTarget) {
setShowOrderAssignmentModal(false);
setSelectedOrderForAssignment(null);
}
}
},
React.createElement('div', { className: 'bg-white dark:bg-gray-800 rounded-lg p-6 max-w-md w-full' },
React.createElement('h3', { className: 'text-lg font-semibold mb-4' }, 
'Assign Order to Supply Team'
),
React.createElement('div', { className: 'space-y-2' },
supplyTeamUsers.map(user =>
React.createElement('button', {
key: user.email,
className: 'w-full text-left px-4 py-2 rounded hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors',
onClick: () => {
assignOrderToService(selectedOrderForAssignment.id, user.email);
setShowOrderAssignmentModal(false);
setSelectedOrderForAssignment(null);
}
},
React.createElement('div', { className: 'font-medium' }, user.name),
React.createElement('div', { className: 'text-sm text-gray-500' }, user.role)
)
)
),
React.createElement('button', {
className: 'mt-4 w-full text-center text-gray-500 hover:text-gray-700',
onClick: () => {
setShowOrderAssignmentModal(false);
setSelectedOrderForAssignment(null);
}
}, 'Cancel')
)
);
};


;

const getInventoryDueInDays = (eventDate) => {
const today = new Date();
const event = new Date(eventDate);
const diffTime = event - today;
const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
return diffDays;
};




const calculateDashboardStats = () => {
let filteredLeads = leads;

// Apply filters
if (dashboardFilter === 'salesPerson' && selectedSalesPerson) {
filteredLeads = leads.filter(l => l.assigned_to === selectedSalesPerson);
} else if (dashboardFilter === 'event' && selectedEvent) {
filteredLeads = leads.filter(l => l.lead_for_event === selectedEvent);
}

const stats = {
totalLeads: filteredLeads.length,
activeDeals: filteredLeads.filter(l => ['hot', 'warm', 'qualified'].includes(l.status)).length,
thisMonthRevenue: 0,
pendingDeliveries: deliveries.filter(d => d.status === 'pending').length,
inventoryValue: inventory.reduce((sum, item) => sum + (item.price * item.quantity), 0)
};


setDashboardStats(stats);

// Update charts with filtered data
updateCharts(filteredLeads);
};



// HOW TO FIX THE DUPLICATE FUNCTION ERRORS

// The problem: You have these functions declared TWICE in your code:
// 1. extractFiltersData
// 2. updateCharts

// SOLUTION:

// Step 1: Use your text editor's search function (Ctrl+F or Cmd+F)
// Search for each of these function names:

// Search for: "const extractFiltersData"
// You'll find 2 occurrences - DELETE ONE OF THEM

// Search for: "const updateCharts" 
// You'll find 2 occurrences - DELETE ONE OF THEM

// Step 2: Make sure you keep only ONE instance of each function
// The functions should look like this (KEEP ONLY ONE OF EACH):

// ===== KEEP ONLY ONE extractFiltersData =====
const extractFiltersData = () => {
// Extract unique events from leads
const uniqueEvents = [...new Set(leads.map(l => l.lead_for_event).filter(e => e))];
setEvents(uniqueEvents);

// Extract sales people from users
const salesUsers = users.filter(u => 
u.role === 'sales_executive' || u.role === 'sales_manager'
);
setSalesPeople(salesUsers);
};



// ===== KEEP ONLY ONE updateCharts =====
const updateCharts = (filteredLeads) => {
console.log('Updating charts with', filteredLeads.length, 'leads');

// Lead Split Chart (Qualified vs Junk)
const qualifiedCount = filteredLeads.filter(l => l.status === 'qualified').length;
const junkCount = filteredLeads.filter(l => l.status === 'junk').length;
console.log('Lead Split:', { qualified: qualifiedCount, junk: junkCount });

// Temperature Count
// Temperature Count (including parallel stages)
const hotCount = filteredLeads.filter(l => getDisplayTemperature(l) === 'hot').length;
const warmCount = filteredLeads.filter(l => getDisplayTemperature(l) === 'warm').length;
const coldCount = filteredLeads.filter(l => getDisplayTemperature(l) === 'cold').length;
console.log('Temperature Count:', { hot: hotCount, warm: warmCount, cold: coldCount });

// Temperature Value
// Temperature Value (including parallel stages)
const hotValue = filteredLeads.filter(l => getDisplayTemperature(l) === 'hot')
.reduce((sum, l) => sum + (l.potential_value || 0), 0);
const warmValue = filteredLeads.filter(l => getDisplayTemperature(l) === 'warm')
.reduce((sum, l) => sum + (l.potential_value || 0), 0);
const coldValue = filteredLeads.filter(l => getDisplayTemperature(l) === 'cold')
.reduce((sum, l) => sum + (l.potential_value || 0), 0);
console.log('Temperature Value:', { hot: hotValue, warm: warmValue, cold: coldValue });

// Update charts if they exist
if (chartInstances.leadSplit) {
chartInstances.leadSplit.data.datasets[0].data = [qualifiedCount, junkCount];
chartInstances.leadSplit.update();
console.log('Lead Split chart updated');
} else {
console.log('Lead Split chart not found!');
}

if (chartInstances.tempCount) {
chartInstances.tempCount.data.datasets[0].data = [hotCount, warmCount, coldCount];
chartInstances.tempCount.update();
console.log('Temp Count chart updated');
} else {
console.log('Temp Count chart not found!');
}

if (chartInstances.tempValue) {
chartInstances.tempValue.data.datasets[0].data = [hotValue, warmValue, coldValue];
chartInstances.tempValue.update();
console.log('Temp Value chart updated');
} else {
console.log('Temp Value chart not found!');
}
};




// Function to initialize charts
const initializeChartsAdvanced = () => {
console.log('Initializing advanced charts...');

// Destroy existing charts first
Object.keys(chartInstances).forEach(key => {
if (chartInstances[key]) {
chartInstances[key].destroy();
chartInstances[key] = null;
}
});

// Lead Split Chart 
const ctx1 = document.getElementById('leadSplitChart');
if (ctx1) {
try {
chartInstances.leadSplit = new Chart(ctx1, {
type: 'pie',
data: {
labels: ['Qualified', 'Junk'],
datasets: [{
data: [0, 0],
backgroundColor: ['#10b981', '#ef4444'],
borderWidth: 2,
borderColor: '#ffffff'
}]
},
options: {
responsive: true,
maintainAspectRatio: false,
plugins: {
legend: {
position: 'bottom',
labels: {
padding: 15,
font: { size: 12, weight: 'bold' },
usePointStyle: true,
pointStyle: 'circle'
}
},
tooltip: {
backgroundColor: 'rgba(0, 0, 0, 0.8)',
titleColor: '#ffffff',
bodyColor: '#ffffff',
borderColor: '#ffffff',
borderWidth: 1,
cornerRadius: 8,
displayColors: true,
callbacks: {
title: function(context) {
return 'Lead Split Analysis';
},
label: function(context) {
const label = context.label || '';
const value = context.parsed || 0;
const total = context.dataset.data.reduce((a, b) => a + b, 0);
const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
return [
`Status: ${label}`,
`Count: ${value} leads`,
`Percentage: ${percentage}%`
];
}
}
}
}
}
});
} catch (error) {
console.error('Error creating advanced Lead Split chart:', error);
}
}

// Temperature Count Chart
const ctx2 = document.getElementById('tempCountChart');
if (ctx2) {
try {
chartInstances.tempCount = new Chart(ctx2, {
type: 'pie',
data: {
labels: ['Hot', 'Warm', 'Cold'],
datasets: [{
data: [0, 0, 0],
backgroundColor: ['#ef4444', '#f59e0b', '#3b82f6'],
borderWidth: 2,
borderColor: '#ffffff'
}]
},
options: {
responsive: true,
maintainAspectRatio: false,
plugins: {
legend: {
position: 'bottom',
labels: {
padding: 15,
font: { size: 12, weight: 'bold' },
usePointStyle: true,
pointStyle: 'circle'
}
},
tooltip: {
backgroundColor: 'rgba(0, 0, 0, 0.8)',
titleColor: '#ffffff',
bodyColor: '#ffffff',
borderColor: '#ffffff',
borderWidth: 1,
cornerRadius: 8,
displayColors: true,
callbacks: {
title: function(context) {
return 'Lead Temperature Count';
},
label: function(context) {
const label = context.label || '';
const value = context.parsed || 0;
const total = context.dataset.data.reduce((a, b) => a + b, 0);
const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
return [
`Temperature: ${label}`,
`Count: ${value} leads`,
`Percentage: ${percentage}%`
];
}
}
}
}
}
});
} catch (error) {
console.error('Error creating advanced Temp Count chart:', error);
}
}

// Temperature Value Chart
const ctx3 = document.getElementById('tempValueChart');
if (ctx3) {
try {
chartInstances.tempValue = new Chart(ctx3, {
type: 'pie',
data: {
labels: ['Hot', 'Warm', 'Cold'],
datasets: [{
data: [0, 0, 0],
backgroundColor: ['#ef4444', '#f59e0b', '#3b82f6'],
borderWidth: 2,
borderColor: '#ffffff'
}]
},
options: {
responsive: true,
maintainAspectRatio: false,
plugins: {
legend: {
position: 'bottom',
labels: {
padding: 15,
font: { size: 12, weight: 'bold' },
usePointStyle: true,
pointStyle: 'circle'
}
},
tooltip: {
backgroundColor: 'rgba(0, 0, 0, 0.8)',
titleColor: '#ffffff',
bodyColor: '#ffffff',
borderColor: '#ffffff',
borderWidth: 1,
cornerRadius: 8,
displayColors: true,
callbacks: {
title: function(context) {
return 'Lead Temperature Value';
},
label: function(context) {
const label = context.label || '';
const value = context.parsed || 0;
const total = context.dataset.data.reduce((a, b) => a + b, 0);
const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;

// Format value in Lacs with better formatting
let formattedValue;
if (value >= 10000000) { // 1 Crore
formattedValue = (value / 10000000).toFixed(2) + ' Cr';
} else if (value >= 100000) { // 1 Lac
formattedValue = (value / 100000).toFixed(2) + ' L';
} else if (value >= 1000) { // 1 Thousand
formattedValue = (value / 1000).toFixed(1) + ' K';
} else {
formattedValue = value.toString();
}

return [
`Temperature: ${label}`,
`Value: ‚Çπ${formattedValue}`,
`Percentage: ${percentage}%`
];
}
}
}
}
}
});
} catch (error) {
console.error('Error creating advanced Temp Value chart:', error);
}
}

console.log('Advanced chart initialization complete');
};



const formatValueInLacs = (value) => {
if (value >= 100000) {
return (value / 100000).toFixed(2) + 'L';
} else if (value >= 1000) {
return (value / 1000).toFixed(1) + 'K';
} else {
return value.toString();
}
};




// Authentication
const handleLogin = async (e) => {
debugLog('LOGIN_START', { email, timestamp: Date.now() });
e.preventDefault();
setLoading(true);

try {
const response = await window.apicall('/auth/login', {
method: 'POST',
body: JSON.stringify({ email, password })
});
debugLog('LOGIN_RESPONSE', { 
response, 
hasToken: response?.token !== undefined,
hasUser: response?.user !== undefined,
responseType: typeof response
});

console.log("Login response structure:", response);
console.log("Response type:", typeof response);
console.log("Has token?", response.token !== undefined);
console.log("Has user?", response.user !== undefined);
if (response.token && response.user) {
authToken = response.token;  // Update global authToken variable
localStorage.setItem('crm_auth_token', response.token);
localStorage.setItem('crm_user', JSON.stringify(response.user));
setUser(response.user);
debugLog('LOGIN_SUCCESS', { user: response.user });
setIsLoggedIn(true);
await fetchUserRoles();
// Clear any cached user management data
setUsers([]);
setEmail('');
setPassword('');
}
} catch (error) {
debugLog('LOGIN_ERROR', { error: error.message, stack: error.stack });
console.error("Login failed:", error.message || "Invalid credentials");
console.error("Full error:", error);
} finally {
setLoading(false);
}
};




const handleLogout = () => {
setIsLoggedIn(false);
setUser(null);
setCurrentUser(null);
setEmail('');
setPassword('');
setActiveTab('dashboard');
try {
localStorage.removeItem('crm_user');
localStorage.removeItem('crm_auth_token');
authToken = null;  // Clear the global authToken variable
authToken = null;  // Clear the global authToken variable
} catch (e) {
console.log('Failed to clear auth state:', e);
}
};



// User Management Functions
const openUserManagement = () => {
if (!window.hasPermission('users', 'read')) {
alert('You do not have permission to access user management');
return;
}
setShowUserManagement(true);
};



const openUserForm = (editUser = null) => {
if (editUser && !window.hasPermission('users', 'write')) {
alert('You do not have permission to edit users');
return;
}
if (!editUser && !window.hasPermission('users', 'write')) {
alert('You do not have permission to create users');
return;
}

setCurrentUser(editUser);
if (editUser) {
// Editing existing user
setUserFormData({
name: editUser.name,
email: editUser.email,
role: editUser.role,
status: editUser.status || 'active'
});
} else {
// Creating new user
setUserFormData({
name: '',
email: '',
role: '',
password: '',
status: 'active'
});
}
setShowUserForm(true);
};



const handleDeleteUser = async (userId, userName) => {
if (!window.hasPermission('users', 'delete')) {
alert('You do not have permission to delete users');
return;
}

if (!confirm(`Are you sure you want to delete user "${userName}"? This action cannot be undone.`)) {
return;
}

setLoading(true);
try {
await window.apicall(`/users/${userId}`, { method: 'DELETE' });
console.log('User deleted successfully');

// Remove user from the list
setUsers(prev => prev.filter(u => u.id !== userId));
showNotification('User deleted successfully', 'success');
} catch (error) {
console.error('Error deleting user:', error);
showNotification(error.message || 'Failed to delete user', 'error');
} finally {
setLoading(false);
}
};




const closeUserForm = () => {
setShowUserForm(false);
setEditingUser(null);
setUserFormData({
name: '',
email: '',
password: '',
role: 'viewer',
department: '',
status: 'active'
});
};


const fetchUsers = async () => {
try {
const response = await window.apicall('/users');
if (response.data) {
setUsers(response.data);
}
} catch (error) {
console.error('Failed to fetch users:', error);
}
};



// Enhanced handleMarkAsPaid function with inventory integration
const handleMarkAsPaid = async (payableId) => {
try {
console.log('handleMarkAsPaid called with payableId:', payableId);

const payable = financialData.payables?.find(p => p.id === payableId);

if (!payable) {
console.error('Payable not found:', payableId);
alert('Payable not found.');
return;
}

console.log('Found payable:', payable);

// If linked to inventory, open inventory edit form
if (payable.inventoryId) {
console.log('Payable is linked to inventory:', payable.inventoryId);

const inventoryItem = inventory.find(inv => inv.id === payable.inventoryId);

if (!inventoryItem) {
console.error('Related inventory item not found:', payable.inventoryId);
alert('Related inventory item not found. Please refresh and try again.');
await fetchInventory();
return;
}

console.log('Found inventory item:', inventoryItem);
console.log('Opening inventory edit form for payable payment...');

// Set up for editing with payment focus
// Pre-fill form data with payment context
const inventoryWithContext = {
...inventoryItem,
_payableContext: {
payableId: payable.id,
payableAmount: payable.amount,
fromPayables: true
}
};



setEditingInventory(inventoryWithContext);

// Pre-fill form data for payment
// Calculate correct payment amounts
// When coming from payables, we're paying off the pending balance
const currentTotal = parseFloat(inventoryItem.totalPurchaseAmount || 0);
const currentPaid = parseFloat(inventoryItem.amountPaid || 0);
const pendingBalance = parseFloat(payable.amount || 0); // What we owe

console.log('Payable form pre-fill calculation:', {
currentTotal,
currentPaid,
pendingBalance,
action: 'Setting form to mark as fully paid'
});

// Pre-fill form to mark as FULLY PAID by default
setFormData({
...inventoryItem,
totalPurchaseAmount: currentTotal, // Keep original total
amountPaid: currentTotal, // Set paid amount = total amount (fully paid)
paymentStatus: 'paid' // Mark as paid by default
});

setShowInventoryForm(true);

return;
}

// For non-inventory payables, use traditional mark as paid
console.log('Processing non-inventory payable...');
const confirmPaid = confirm(`Mark payable of ‚Çπ${payable.amount} as paid?`);
if (!confirmPaid) return;

setLoading(true);

const response = await window.apicall(`/finance/payables/${payableId}`, {
method: 'PUT',
body: JSON.stringify({
status: 'paid',
paid_date: new Date().toISOString(),
payment_notes: 'Marked as paid manually'
})
});

if (response.error) {
throw new Error(response.error);
}

console.log('Payable marked as paid successfully');
alert('Payable marked as paid!');
await fetchFinancialData();

} catch (error) {
console.error('Error handling mark as paid:', error);
alert('Failed to process payment: ' + error.message);
} finally {
setLoading(false);
}
};



const fetchFinancialData = async () => {
try {
console.log('Fetching financial data...');
const [ordersRes, invoicesRes, payablesRes, inventoryRes, receivablesRes] = await Promise.all([
window.apicall('/orders'),
window.apicall('/invoices'),
window.apicall('/payables'),
window.apicall('/inventory'),
window.apicall('/receivables').catch(() => ({ data: [] }))
]);

const ordersData = ordersRes.data || [];
const invoicesData = invoicesRes.data || [];
const payablesData = payablesRes.data || [];
const inventoryData = inventoryRes.data || [];
const receivablesData = receivablesRes.data || [];

console.log('Raw receivables data:', receivablesData);

const today = new Date();
today.setHours(0, 0, 0, 0);

// FIXED: Process active sales (orders in progress with event date in future)
const activeSalesData = ordersData
.filter(order => {
// Include orders that are approved OR in service/delivery process
const validStatuses = ['approved', 'service_assigned', 'in_progress', 'delivery_scheduled', 'pending_delivery'];

if (!validStatuses.includes(order.status)) {
// Skip completed, cancelled, rejected orders
console.log(`Skipping order ${order.id} with status: ${order.status}`);
return false;
}

// Only include if event date is in future
if (!order.event_date) {
console.log(`Skipping order ${order.id} - no event date`);
return false;
}

const eventDate = new Date(order.event_date);
eventDate.setHours(0, 0, 0, 0);
const isEventInFuture = eventDate >= today;

console.log(`Order ${order.id}: status=${order.status}, eventDate=${order.event_date}, inFuture=${isEventInFuture}`);
return isEventInFuture;
})
.map(order => ({
id: order.id,
date: order.created_at || order.created_date || new Date().toISOString(),
invoice_number: order.invoice_number || 'INV-' + order.id,
clientName: order.lead_name || order.client_name || 'N/A',
assignedTo: order.assigned_to || order.sales_person || order.created_by || 'Unassigned',
amount: parseFloat(order.final_amount || order.total_amount || 0),
status: 'active',
event_date: order.event_date,
payment_status: order.payment_status || 'pending',
order_type: order.order_type,
order_status: order.status // Keep original status for reference
}));

// FIXED: Process completed sales - orders that are completed OR have past event dates
const salesData = ordersData
.filter(order => {
// Include if explicitly completed or delivered
if (order.status === 'completed' || order.status === 'delivered') {
console.log(`Including completed order ${order.id} with status: ${order.status}`);
return true;
}

// Include if event date has passed (regardless of status, except rejected/cancelled)
if (order.status !== 'rejected' && order.status !== 'cancelled' && order.event_date) {
const eventDate = new Date(order.event_date);
eventDate.setHours(0, 0, 0, 0);
const isEventPast = eventDate < today;

if (isEventPast) {
console.log(`Including past event order ${order.id}: eventDate=${order.event_date}, status=${order.status}`);
return true;
}
}

return false;
})
.map(order => ({
id: order.id,
date: order.created_at || order.created_date || new Date().toISOString(),
invoice_number: order.invoice_number || 'INV-' + order.id,
clientName: order.lead_name || order.client_name || 'N/A',
assignedTo: order.assigned_to || order.sales_person || order.created_by || 'Unassigned',
amount: parseFloat(order.final_amount || order.total_amount || 0),
status: order.payment_status === 'paid' ? 'paid' : 'completed',
event_date: order.event_date,
payment_status: order.payment_status || 'pending'
}));

// Process receivables - ensure all fields are properly mapped
const processedReceivables = receivablesData.map(r => {
console.log('Processing receivable:', r);
return {
...r,
// Ensure all required fields are present
amount: parseFloat(r.expected_amount || r.amount || 0),
balance_amount: parseFloat(r.balance_amount || r.expected_amount || r.amount || 0),
invoice_number: r.invoice_number || r.invoice_id || 'N/A',
due_date: r.due_date || r.expected_payment_date || new Date().toISOString(),
client_name: r.client_name || 'N/A',
assigned_to: r.assigned_to || 'Unassigned',
status: r.status || 'pending'
};


});

console.log('Processed receivables:', processedReceivables);

// Filter only unpaid receivables
const unpaidReceivables = processedReceivables.filter(r => r.status !== 'paid');

console.log('Unpaid receivables to display:', unpaidReceivables);

// Calculate totals
const totalActiveSales = activeSalesData.reduce((sum, sale) => sum + sale.amount, 0);
const totalSales = salesData.reduce((sum, sale) => sum + sale.amount, 0);
const totalReceivables = unpaidReceivables.reduce((sum, rec) => 
sum + (rec.balance_amount || rec.amount || 0), 0
);
const totalPayables = payablesData.reduce((sum, pay) => 
sum + parseFloat(pay.amount || 0), 0
);

// Log the results
console.log('=== FINANCIAL DATA SUMMARY ===');
console.log(`Active Sales: ${activeSalesData.length} orders, Total: ‚Çπ${totalActiveSales.toLocaleString()}`);
console.log(`Completed Sales: ${salesData.length} orders, Total: ‚Çπ${totalSales.toLocaleString()}`);
console.log(`Receivables: ${unpaidReceivables.length} entries, Total: ‚Çπ${totalReceivables.toLocaleString()}`);
console.log(`Payables: ${payablesData.length} entries, Total: ‚Çπ${totalPayables.toLocaleString()}`);

// Update state
setFinancialData({
activeSales: activeSalesData,
sales: salesData,
receivables: unpaidReceivables,
payables: payablesData,
expiringInventory: inventoryData.filter(item => {
if (!item.event_date || item.allocated) return false;
const days = Math.ceil((new Date(item.event_date) - new Date()) / (1000 * 60 * 60 * 24));
return days <= 7 && days >= 0;
})
});

console.log('Financial data set:', {
activeSales: activeSalesData.length,
sales: salesData.length,
receivables: unpaidReceivables.length,
payables: payablesData.length
});

} catch (error) {
console.error('Error fetching financial data:', error);
alert('Failed to load financial data. Please refresh the page.');
}
};




// Record payment for receivable
const recordPayment = async (receivableId) => {
const paymentAmount = prompt('Enter payment amount:');
if (!paymentAmount) return;

const paymentMode = prompt('Enter payment mode (bank_transfer/cash/cheque):', 'bank_transfer');
const transactionId = prompt('Enter transaction ID (optional):');

try {
setLoading(true);
const response = await window.apicall('/receivables/record-payment/' + (receivableId), 'PUT', {
payment_amount: parseFloat(paymentAmount),
payment_date: new Date().toISOString(),
payment_mode: paymentMode,
transaction_id: transactionId
});

alert('Payment recorded successfully!');
fetchFinancialData(); // Refresh data
} catch (error) {
console.error('Error recording payment:', error);
alert('Failed to record payment');
} finally {
setLoading(false);
}
};




const fetchMyActions = async () => {
console.log('===== fetchMyActions CALLED =====');
console.log('Timestamp:', new Date().toISOString());
console.log('Current user:', user);
console.log('User email:', user?.email);
console.log('User role:', user?.role);
console.log('Is logged in:', isLoggedIn);
console.log('Loading state:', loading);

if (!user) {
console.error('No user object - cannot fetch actions');
return;
}

if (!user) {
console.log('No user logged in');
return;
}

try {
setLoading(true);
console.log('Fetching actions for:', user.name, '(' + user.email + ')');

// Fetch all data in parallel
const [leadsResponse, ordersResponse, deliveriesResponse, receivablesResponse] = await Promise.all([
window.apicall('/leads').catch(err => { console.error('Failed to fetch leads:', err); return { data: [] }; }),
window.apicall('/orders').catch(err => { console.error('Failed to fetch orders:', err); return { data: [] }; }),
window.apicall('/deliveries').catch(err => { console.error('Failed to fetch deliveries:', err); return { data: [] }; }),
window.apicall('/receivables').catch(err => { console.error('Failed to fetch receivables:', err); return { data: [] }; })
]);

// Debug: Log all API responses
console.log('=== API RESPONSES RECEIVED ===');
console.log('Leads response:', leadsResponse);
console.log('Number of leads:', leadsResponse?.data?.length || 0);
if (leadsResponse?.data?.length > 0) {
console.log('First lead full data:', leadsResponse.data[0]);
console.log('Lead assignment field:', leadsResponse.data[0].assigned_to || leadsResponse.data[0].assignedTo || 'NOT FOUND');
}

// Filter leads assigned to me
// Filter leads assigned to me
if (leadsResponse && leadsResponse.data) {
const assignedLeads = leadsResponse.data.filter(lead => {
console.log('\n--- Checking Lead ---');
console.log('Lead:', lead);
console.log('Lead name:', lead.name);
console.log('Lead assigned_to:', lead.assigned_to);
console.log('Lead assignedTo:', lead.assignedTo);
console.log('My email:', user.email);

const isAssigned = lead.assigned_to === user.email;
console.log('Match result:', isAssigned);

return isAssigned;
});

// Filter quote requested leads for supply managers and supply sales service managers
const quoteRequestedLeads = leadsResponse.data.filter(lead => {
if (lead.status === 'quote_requested') {
// Check if user is supply_manager or has supply_sales_service role
return (user.role === 'supply_manager' || 
user.role === 'supply_sales_service_manager' ||
lead.quote_assigned_to === user.email);
}
return false;
});

console.log('\n=== FILTER RESULTS ===');
console.log('Total leads:', leadsResponse.data.length);
console.log('Assigned to me:', assignedLeads.length);
console.log('Quote requested for me:', quoteRequestedLeads.length);
console.log('Assigned leads:', assignedLeads);
console.log('Quote requested leads:', quoteRequestedLeads);

setMyLeads(assignedLeads);
setMyQuoteRequested(quoteRequestedLeads);
} else {
setMyLeads([]);
setMyQuoteRequested([]);
}

// Filter orders based on role
if (ordersResponse && ordersResponse.data) {
let assignedOrders = [];

if (user.role === 'supply_sales_service_manager' || user.role === 'supply_executive') {
assignedOrders = ordersResponse.data.filter(order => 
order.status === 'approved' && order.assigned_to === user.email
);
} else if (user.role === 'finance_manager' || user.role === 'finance_executive') {
assignedOrders = ordersResponse.data.filter(order => 
order.status === 'pending_approval'
);
}

console.log('My orders:', assignedOrders.length);
setMyOrders(assignedOrders);
} else {
setMyOrders([]);
}

// Filter deliveries
if (deliveriesResponse && deliveriesResponse.data) {
const assignedDeliveries = deliveriesResponse.data.filter(delivery => 
delivery.assigned_to === user.email
);
console.log('My deliveries:', assignedDeliveries.length);
setMyDeliveries(assignedDeliveries);
} else {
setMyDeliveries([]);
}

// Get overdue receivables
if (receivablesResponse && receivablesResponse.data) {
const today = new Date();
const overdueReceivables = receivablesResponse.data.filter(rec => {
if (rec.status === 'paid') return false;
const dueDate = new Date(rec.due_date);
return dueDate < today;
});
console.log('Overdue receivables:', overdueReceivables.length);
setMyReceivables(overdueReceivables);
} else {
setMyReceivables([]);
}

setLoading(false);
} catch (error) {
console.error('Error in fetchMyActions:', error);
setLoading(false);
}
};



window.chartInstances = chartInstances;
window.calculateDashboardStats = calculateDashboardStats;
window.debugCharts = () => {
console.log('=== Chart Debug Info ===');
console.log('Canvas elements:', {
leadSplit: document.getElementById('leadSplitChart'),
tempCount: document.getElementById('tempCountChart'),
tempValue: document.getElementById('tempValueChart')
});
console.log('Chart instances:', window.chartInstances);
console.log('Current leads:', leads);
console.log('Lead statuses:', leads.map(l => ({ name: l.name, status: l.status })));
};



// 5. Function to manually initialize charts:
window.forceInitCharts = () => {
console.log('Force initializing charts...');
initializeChartsAdvanced();
};    

window.debugDashboard = () => {
console.log('=== Dashboard Debug ===');
console.log('Active tab:', activeTab);
console.log('Leads count:', leads.length);
console.log('Chart.js loaded:', typeof Chart !== 'undefined');
console.log('Canvas elements in DOM:', {
leadSplit: !!document.getElementById('leadSplitChart'),
tempCount: !!document.getElementById('tempCountChart'),
tempValue: !!document.getElementById('tempValueChart')
});
console.log('Chart instances:', {
leadSplit: !!chartInstances.leadSplit,
tempCount: !!chartInstances.tempCount,
tempValue: !!chartInstances.tempValue
});

// Try to reinitialize
if (activeTab === 'dashboard') {
console.log('Attempting manual chart initialization...');
initializeChartsAdvanced();
}
};



// Enhanced lead progression function with permission check
// Status update function with permission check
const updateLeadStatus = async (leadId, newStatus) => {
if (!window.hasPermission('leads', 'progress')) {
alert('You do not have permission to progress leads');
return;
}

try {
setLoading(true);

// CRITICAL: Get the full lead object first
const currentLead = leads.find(l => l.id === leadId);
if (!currentLead) {
alert('Lead not found');
setLoading(false);
return;
}

// Include ALL fields from current lead
const updateData = {
...currentLead,  // This includes EVERYTHING
status: newStatus,
last_contact_date: new Date().toISOString(),
[(newStatus) + '_date']: new Date().toISOString(),
updated_date: new Date().toISOString()
};



console.log('Updating lead with full data:', updateData);

// API call to update lead status
const response = await window.apicall('/leads/' + (leadId), {
method: 'PUT',
body: JSON.stringify(updateData)
});

// Update local state with response from server
console.log("Status update response:", response);
setLeads(prevLeads => 
prevLeads.map(lead => 
lead.id === leadId ? response.data : lead
)
);

// Update current lead if in detail view
if (showLeadDetail && currentLead?.id === leadId) {
setCurrentLead(response.data);
}

setLoading(false);
alert('Lead status updated successfully!');
} catch (error) {
console.error('Error updating lead status:', error);
setLoading(false);
alert('Failed to update lead status: ' + error.message);
}
};


const handleLeadProgression = (lead) => {
if (!window.hasPermission('leads', 'progress')) {
alert('You do not have permission to progress leads');
return;
}

const currentStatus = lead.status;
const nextOptions = window.LEAD_STATUSES[currentStatus]?.next || [];

if (nextOptions.length === 0) {
alert('This lead is already at the final stage.');
return;
}

// Check if any of the next options require follow-up date (like pickup_later)
const hasFollowUpOptions = nextOptions.some(status => 
window.LEAD_STATUSES[status]?.requires_followup_date
);

if (nextOptions.length === 1) {
const nextStatus = nextOptions[0];

// Handle pickup_later status (requires follow-up date)
if (nextStatus === 'pickup_later') {
setCurrentLead(lead);
setShowStatusProgressModal(true);
setStatusProgressOptions([{
value: 'pickup_later',
label: window.LEAD_STATUSES['pickup_later'].label,
color: window.LEAD_STATUSES['pickup_later'].color,
requires_followup_date: true
}]);
return;
}

// Handle payment status (existing logic)
if (nextStatus === 'payment') {
if (currentStatus === 'payment_post_service') {
// Coming from payment_post_service, collect payment
const receivable = receivables.find(r => r.lead_id === lead.id && r.status === 'pending');
if (receivable) {
collectPostServicePayment(receivable);
} else {
openPaymentForm(lead);
}
} else {
openPaymentForm(lead);
}
return;
}

// For other single status transitions (including attempts)
updateLeadStatus(lead.id, nextStatus);
} else {
// Multiple options available - need to show choice modal

// Handle special case for converted status with payment options (existing logic)
if (currentStatus === 'converted' && 
nextOptions.includes('payment') && 
nextOptions.includes('payment_post_service')) {

// Check if pickup_later is also an option
if (nextOptions.includes('pickup_later')) {
// Show enhanced choice modal with pickup_later option
setCurrentLeadForChoice(lead);
setChoiceOptions([
{ value: 'payment', label: 'Collect Payment Now', icon: 'üí≥' },
{ value: 'payment_post_service', label: 'Payment Post Service', icon: 'üìÖ' },
{ value: 'pickup_later', label: 'Pick Up Later', icon: '‚è∞', requires_followup_date: true }
]);
setShowChoiceModal(true);
} else {
// Original logic for payment choices
setCurrentLeadForChoice(lead);
setChoiceOptions([
{ value: 'payment', label: 'Collect Payment Now', icon: 'üí≥' },
{ value: 'payment_post_service', label: 'Payment Post Service', icon: 'üìÖ' }
]);
setShowChoiceModal(true);
}
} 
// If any option requires follow-up date, use the enhanced modal
else if (hasFollowUpOptions) {
setCurrentLead(lead);
setShowStatusProgressModal(true);
setStatusProgressOptions(nextOptions.map(status => ({
value: status,
label: window.LEAD_STATUSES[status].label,
color: window.LEAD_STATUSES[status].color,
requires_followup_date: window.LEAD_STATUSES[status].requires_followup_date,
icon: window.getStatusIcon(status) // Helper function for icons
})));
} 
// Otherwise use the existing choice modal (this handles attempts and all other flows)
else {
setCurrentLeadForChoice(lead);
setChoiceOptions(nextOptions.map(status => ({
value: status,
label: window.LEAD_STATUSES[status].label,
icon: window.getStatusIcon(status)
})));
setShowChoiceModal(true);
}
}
};



const handleQuoteRequestStage = async (lead, newStatus) => {
try {
setLoading(true);

// Preserve temperature when moving to quote_requested
const currentTemperature = getLeadTemperature(lead);

const updateData = {
...lead,
status: newStatus,
temperature: currentTemperature, // Preserve the temperature
quote_requested_date: new Date().toISOString(),
last_contact_date: new Date().toISOString(),
updated_date: new Date().toISOString(),
// Dual assignment: keep original assignee and add sales service manager
quote_assigned_to: user.role === 'supply_manager' ? user.email : 'supply.service@fantopark.com', // Auto-assign based on role
dual_assignment: true
};



const response = await window.apicall(`/leads/${lead.id}`, {
method: 'PUT',
body: JSON.stringify(updateData)
});

// Update local state
setLeads(prevLeads => 
prevLeads.map(l => 
l.id === lead.id ? response.data : l
)
);

// Update current lead if in detail view
if (showLeadDetail && currentLead?.id === lead.id) {
setCurrentLead(response.data);
}

setLoading(false);
alert('Lead moved to Quote Requested stage and assigned to Sales Service Manager!');
} catch (error) {
console.error('Error updating lead to quote requested:', error);
setLoading(false);
alert('Failed to update lead status: ' + error.message);
}
};



// Enhanced Choice Modal Handler to support pickup_later
const handleChoiceSelection = async (choice) => {
try {
setLoading(true);

// If choice requires follow-up date, switch to the enhanced modal
if (choice.requires_followup_date) {
setShowChoiceModal(false);
setCurrentLead(currentLeadForChoice);
setShowStatusProgressModal(true);
setStatusProgressOptions([{
value: choice.value,
label: choice.label,
color: window.LEAD_STATUSES[choice.value]?.color || 'bg-gray-100 text-gray-800',
requires_followup_date: true
}]);
setLoading(false);
return;
}

// Handle payment choices (existing logic)
if (choice.value === 'payment') {
setShowChoiceModal(false);
openPaymentForm(currentLeadForChoice);
setLoading(false);
return;
}

if (choice.value === 'payment_post_service') {
setShowChoiceModal(false);
openPaymentPostServiceForm(currentLeadForChoice);
setLoading(false);
return;
}

// For regular status updates
await updateLeadStatus(currentLeadForChoice.id, choice.value);
setShowChoiceModal(false);
setLoading(false);
} catch (error) {
console.error('Error handling choice selection:', error);
setLoading(false);
alert('Failed to update lead status: ' + error.message);
}
};





// Form handlers with permission checks
const openAddForm = (type) => {
if (!window.hasPermission(type === 'lead' ? 'leads' : (type === 'order' ? 'orders' : type), 'write')) {
alert('You do not have permission to create ' + (type) + 's');
return;
}
setCurrentForm(type);
setFormData({});
setShowAddForm(true);
};



const openEditForm = (lead) => {
if (!window.hasPermission('leads', 'write')) {
alert('You do not have permission to edit leads');
return;
}

setCurrentLead(lead);

// ‚úÖ FIXED: Convert date format for HTML date input
const processedLead = { ...lead };
if (processedLead.date_of_enquiry) {
try {
const date = new Date(processedLead.date_of_enquiry);
if (!isNaN(date.getTime())) {
// Convert to YYYY-MM-DD format for HTML date input
processedLead.date_of_enquiry = date.toISOString().split('T')[0];
}
} catch (error) {
console.warn('Could not parse date:', processedLead.date_of_enquiry);
// Set to current date as fallback
const now = new Date();
processedLead.date_of_enquiry = now.toISOString().split('T')[0];
}
}

setFormData(processedLead);
setShowEditForm(true);
};



const openAssignForm = (lead) => {
if (!window.hasPermission('leads', 'assign')) {
alert('You do not have permission to assign leads');
return;
}
setCurrentLead(lead);
setFormData({ assigned_team: 'sales', assigned_to: '' });
setShowAssignForm(true);
};



const openPaymentForm = (lead) => {
  if (!window.hasPermission('leads', 'write')) {
    alert('You do not have permission to manage payments');
    return;
  }
  
  setCurrentLead(lead);
  
  // Initialize payment data with defaults
  const initialPaymentData = {
    // Basic payment details
    advance_amount: '', // Changed from payment_amount
    payment_method: 'bank_transfer', // ADD: Default payment method
    transaction_id: '',
    payment_date: new Date().toISOString().split('T')[0],
    payment_proof: '',
    notes: '',
    
    // NEW: Enhanced customer classification
    customer_type: 'indian', // 'indian', 'nri', 'foreigner'
    event_location: 'india', // 'india', 'outside_india'
    payment_currency: 'INR', // 'INR', 'USD', 'EUR', 'GBP'
    
    // NEW: TCS fields with enhanced support
    tcs_applicable: false,
    tcs_rate: 5, // Default to 5%
    tcs_amount: 0,
    tcs_rate_manual: false, // Track if rate was manually selected
    
    // GST and Legal details
    gstin: lead.gstin || '', // ADD: Get from lead if available
    legal_name: lead.legal_name || lead.name || '', // CHANGE: Prioritize legal_name
    category_of_sale: lead.business_type === 'B2B' ? 'Corporate' : 'Retail', // CHANGE: Map to Corporate/Retail
    type_of_sale: 'Tour', // Tour or Service Fee
    registered_address: lead.registered_address || '', // ADD: Get from lead if available
    indian_state: 'Haryana',
    is_outside_india: false,
    gst_certificate: null,
    pan_card: null,
    
    // ENHANCED: Multi-row invoice items with additional info support
    invoice_items: [{
      description: lead.lead_for_event || 'Travel Package',
      additional_info: '', // NEW: For bracket info like (Lorem Ipsum)
      quantity: lead.number_of_people || 1,
      rate: lead.last_quoted_price || 0
    }],
    
    // GST calculations
    gst_rate: 5, // Default to 5% for Tour packages
    service_fee_amount: 0, // Only for Service Fee type
    
    // ADD: Missing fields for receivables and post-service payments
    from_receivable: false,
    payment_post_service: false,
    receivable_id: null,
    receivable_amount: 0
  };
  
  // Calculate initial TCS applicability and rate
  const baseAmount = lead.last_quoted_price * (lead.number_of_people || 1) || 0;
  if (baseAmount > 0) {
    const calculation = calculateGSTAndTCS(baseAmount, initialPaymentData);
    initialPaymentData.tcs_applicable = calculation.tcs.applicable;
    initialPaymentData.tcs_rate = calculation.tcs.rate;
    initialPaymentData.tcs_amount = calculation.tcs.amount;
  }
  
  setPaymentData(initialPaymentData);
  setShowPaymentForm(true);
};



const handleMarkPaymentFromReceivable = async (receivable) => {
console.log('Mark Payment clicked for receivable:', receivable);

// Check different possible field names for lead ID
const leadId = receivable.lead_id || receivable.leadId || receivable.lead;

if (!leadId) {
// If still no lead ID, check if there's an order we can get the lead from
if (receivable.order_id) {
const order = orders.find(o => o.id === receivable.order_id);
if (order && order.lead_id) {
const lead = leads.find(l => l.id === order.lead_id);
if (lead) {
setCurrentLead(lead);
openPaymentForm(lead);
setPaymentData(prev => ({
...prev,
payment_post_service: true,
advance_amount: receivable.balance_amount || receivable.expected_amount || receivable.amount || ''
,
from_receivable: true,
receivable_id: receivable.id,
receivable_amount: receivable.balance_amount || receivable.expected_amount || receivable.amount || 0
}));
return;
}
}
}

alert('Cannot find associated lead for this receivable.');
console.error('Receivable structure:', receivable);
return;
}

// Continue with normal flow if lead_id exists
const lead = leads.find(l => l.id === leadId);

if (!lead) {
try {
console.log('Fetching lead from API:', leadId);
const response = await window.apicall('/leads/' + leadId);
const leadData = response.data || response;

setCurrentLead(leadData);
openPaymentForm(leadData);
setPaymentData(prev => ({
...prev,
payment_post_service: true,
advance_amount: receivable.balance_amount || receivable.expected_amount || receivable.amount || ''
,
from_receivable: true,
receivable_id: receivable.id,
receivable_amount: receivable.balance_amount || receivable.expected_amount || receivable.amount || 0
}));
} catch (error) {
console.error('Error fetching lead:', error);
alert('Could not find associated lead: ' + error.message);
}
} else {
setCurrentLead(lead);
openPaymentForm(lead);
setPaymentData(prev => ({
...prev,
payment_post_service: true,
advance_amount: receivable.balance_amount || receivable.expected_amount || receivable.amount || ''
,
from_receivable: true,
receivable_id: receivable.id,
receivable_amount: receivable.balance_amount || receivable.expected_amount || receivable.amount || 0
}));
}
};



const openLeadDetail = (lead) => {
setCurrentLead(lead);
setShowLeadDetail(true);
};



const openAllocationForm = (inventoryItem) => {
if (!window.hasPermission('inventory', 'allocate')) {
alert('You do not have permission to allocate inventory');
return;
}
setCurrentInventory(inventoryItem);
setAllocationData({
lead_id: '',
tickets_allocated: 1,
allocation_date: new Date().toISOString().split('T')[0],
notes: ''
});
setShowAllocationForm(true);
};



const openEditInventoryForm = (inventoryItem) => {
if (!window.hasPermission('inventory', 'write')) {
alert('You do not have permission to edit inventory');
return;
}
setCurrentInventory(inventoryItem);
setFormData(inventoryItem);
setShowEditInventoryForm(true);
};



// Add this right after the openEditInventoryForm function
const handleEditInventory = async (inventoryData) => {
try {
setLoading(true);

console.log('Updating inventory with data:', inventoryData);

// Validate payment amounts
const totalAmount = parseFloat(inventoryData.totalPurchaseAmount || 0);
const amountPaid = parseFloat(inventoryData.amountPaid || 0);

if (amountPaid > totalAmount) {
alert('Amount paid cannot be greater than total purchase amount.');
setLoading(false);
return;
}

// Auto-set payment status
if (amountPaid >= totalAmount) {
inventoryData.paymentStatus = 'paid';
} else if (amountPaid > 0) {
inventoryData.paymentStatus = 'partial';
} else {
inventoryData.paymentStatus = 'pending';
}

// Update inventory (this will automatically sync payables via backend)
const response = await window.apicall(`/inventory/${editingInventory.id}`, {
method: 'PUT',
body: JSON.stringify(inventoryData)
});

if (response.error) {
throw new Error(response.error);
}

// Update local state
setInventory(prev => prev.map(item => 
item.id === editingInventory.id 
? { ...item, ...inventoryData }
: item
));

// Refresh financial data to show updated payables
if (window.hasPermission('finance', 'read')) {
await fetchFinancialData();
}

alert(response.message || 'Inventory updated successfully! Payables have been synced automatically.');
setShowInventoryForm(false);
setEditingInventory(null);

} catch (error) {
console.error('Error updating inventory:', error);
alert('Failed to update inventory: ' + error.message);
} finally {
setLoading(false);
}
};



const openInventoryDetail = (inventoryItem) => {
setCurrentInventoryDetail(inventoryItem);
setShowInventoryDetail(true);
};



// 3. ADD THIS FUNCTION to close inventory detail:
const closeInventoryDetail = () => {
setShowInventoryDetail(false);
setCurrentInventoryDetail(null);
};



const openAddInventoryForm = () => {
console.log('openAddInventoryForm called');

// Fetch stadiums if not already loaded
if (stadiums.length === 0) {
fetchStadiums();
}

// Set up for new inventory item
setEditingInventory({ 
id: null, // Indicates this is a new item
event_name: '',
event_date: '',
event_type: '',
sports: '',
venue: '',
// Add other default fields as needed
});

// Initialize form data with empty values
setFormData({
event_name: '',
event_date: '',
event_type: '',
sports: '',
venue: '',
day_of_match: '',
category_of_ticket: '',
total_tickets: '',
available_tickets: '',
mrp_of_ticket: '',
buying_price: '',
selling_price: '',
stand: '',
inclusions: '',
booking_person: '',
procurement_type: '',
notes: '',
paymentStatus: 'pending',
supplierName: '',
supplierInvoice: '',
totalPurchaseAmount: '',
amountPaid: '',
paymentDueDate: ''
});

setShowInventoryForm(true);
console.log('Inventory form should now be visible with empty form data');
};



const handleCopyInventory = async (item) => {
try {
setLoading(true);

// Create a copy of the inventory item with modified fields
const copiedData = {
...item,
// Remove ID and system fields that shouldn't be copied
id: undefined,
created_date: undefined,
updated_date: undefined,

// Modify the event name to indicate it's a copy
event_name: item.event_name + ' (Copy)',

// Reset availability to match total tickets (fresh inventory)
available_tickets: item.total_tickets,

// Clear payment-related fields for fresh start
paymentStatus: 'pending',
amountPaid: 0,
supplierInvoice: '',

// Update creation info
created_by: JSON.parse(localStorage.getItem('crm_user') || '{}').name || 'Unknown User',
notes: (item.notes || '') + (item.notes ? '\n\n' : '') + 'Copied from original inventory on ' + new Date().toLocaleDateString()
};



console.log('Creating copy of inventory:', copiedData);

// Call API to create the copied inventory
const response = await window.apicall('/inventory', {
method: 'POST',
body: JSON.stringify(copiedData)
});

if (response.error) {
throw new Error(response.error);
}

console.log('Copy created successfully:', response.data);

// Update local state by adding the new item to the inventory array
setInventory(prev => [...prev, response.data]);

alert(`‚úÖ Inventory copied successfully!\n\nNew event: "${copiedData.event_name}"\nTotal tickets: ${copiedData.total_tickets}\nAvailable tickets: ${copiedData.available_tickets}`);

} catch (error) {
console.error('Error copying inventory:', error);
alert('‚ùå Failed to copy inventory: ' + error.message);
} finally {
setLoading(false);
}
};





const openDeliveryForm = (delivery) => {
if (!window.hasPermission('delivery', 'write')) {
alert('You do not have permission to manage deliveries');
return;
}
setCurrentDelivery(delivery);
setDeliveryFormData({
delivery_type: delivery.delivery_type || 'offline',
pickup_location: delivery.pickup_location || '',
delivery_location: delivery.delivery_location || '',
pickup_date: '',
pickup_time: '',
delivery_date: '',
delivery_time: '',
delivery_person: delivery.assigned_to || '',
delivery_notes: '',
online_platform: '',
online_link: ''
});
setShowDeliveryForm(true);
};



const openPaymentPostServiceForm = (lead) => {
if (!window.hasPermission('leads', 'write')) {
alert('You do not have permission to manage payment post service');
return;
}
setCurrentLead(lead);
setPaymentPostServiceData({
expected_payment_date: '',
expected_amount: lead.last_quoted_price || 0,
service_date: '',
service_details: '',
payment_terms: '30 days',
reminder_days: '7',
notes: ''
});
setShowPaymentPostServiceForm(true);
};



const handlePaymentPostServiceInputChange = (field, value) => {
setPaymentPostServiceData(prev => ({ ...prev, [field]: value }));
};






const collectPostServicePayment = (receivable) => {
const lead = leads.find(l => l.id === receivable.lead_id);
if (lead) {
setCurrentLead(lead);
setPaymentData({
...paymentData,
advance_amount: receivable.expected_amount,
payment_post_service: true,
from_receivable: true,
receivable_id: receivable.id,
receivable_amount: receivable.expected_amount || receivable.balance_amount || receivable.amount || 0
});
setShowPaymentForm(true);
}
};



const sendEmailNotification = (notification) => {
console.log('Email Notification:', {
to: notification.recipient,
subject: notification.subject,
body: notification.body,
sent_at: new Date().toISOString()
});

// Update notification status
setEmailNotifications(prev => 
prev.map(n => 
n.id === notification.id 
? { ...n, status: 'sent', sent_date: new Date().toISOString() }
: n
)
);
};


const deleteDelivery = async (deliveryId) => {
if (!window.hasPermission('delivery', 'write')) {
alert('You do not have permission to delete deliveries');
return;
}

if (!confirm('Are you sure you want to delete this delivery? This action cannot be undone.')) {
return;
}

setLoading(true);
try {
await window.apicall('/deliveries/' + (deliveryId), {
method: 'DELETE'
});

setDeliveries(prev => prev.filter(d => d.id !== deliveryId));

alert('Delivery deleted successfully!');
} catch (error) {
console.error('Failed to delete delivery:', error);
alert('Failed to delete delivery. Please try again.');
} finally {
setLoading(false);
}
};



const closeForm = () => {
setShowAddForm(false);
setShowEditForm(false);
setShowAssignForm(false);
setShowPaymentForm(false);
setShowLeadDetail(false);
setShowAllocationForm(false);
setShowEditInventoryForm(false);
setShowChoiceModal(false);
setShowInvoicePreview(false);
setShowDeliveryForm(false);
setShowPaymentPostServiceForm(false);
setCurrentForm('');
setCurrentLead(null);
setCurrentInventory(null);
setCurrentLeadForChoice(null);
setCurrentInvoice(null);
setCurrentDelivery(null);
setChoiceOptions([]);
setFormData({});
setPaymentData({});
setAllocationData({});
setDeliveryFormData({});
setPaymentPostServiceData({});
};



const handleInputChange = (field, value, itemIndex = null, itemField = null) => {
if (itemIndex !== null && itemField !== null) {
updateInvoiceItem(itemIndex, itemField, value);
} else {
setPaymentData(prevData => ({
...prevData,
[field]: value
}));
}
};



const handleFormDataChange = (field, value) => {
console.log('Form field changed:', field, '=', value);
setFormData(prev => ({
...prev,
[field]: value
}));
}; 

const handleUserInputChange = (field, value) => {
setUserFormData(prev => ({ ...prev, [field]: value }));
};



const handleAllocationInputChange = (field, value) => {
setAllocationData(prev => ({ ...prev, [field]: value }));
};


const handleDeliveryInputChange = (field, value) => {
setDeliveryFormData(prev => ({ ...prev, [field]: value }));
};

const ReminderCard = (reminder, isOverdue) => {
const lead = leads.find(l => l.id === reminder.lead_id);

return React.createElement('div', {
key: reminder.id,
className: `border rounded-lg p-4 ${isOverdue ? 'border-red-300 bg-red-50 dark:bg-red-900/20' : 'border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800'}`
},
React.createElement('div', {
className: 'flex items-start justify-between'
},
React.createElement('div', {
className: 'flex-1'
},
React.createElement('div', {
className: 'flex items-center space-x-3 mb-2'
},
React.createElement('span', {
className: `px-2 py-1 rounded text-xs font-medium ${getPriorityColor(reminder.priority)}`
}, reminder.priority.toUpperCase()),
React.createElement('span', {
className: `text-sm ${isOverdue ? 'text-red-600 font-semibold' : 'text-gray-600 dark:text-gray-400'}`
}, formatRelativeTime(reminder.due_date)),
reminder.auto_generated && React.createElement('span', {
className: 'px-2 py-1 bg-purple-100 text-purple-600 rounded text-xs'
}, 'Auto')
),
React.createElement('h4', {
className: 'font-semibold text-gray-900 dark:text-white mb-1'
}, reminder.title),
React.createElement('p', {
className: 'text-sm text-gray-600 dark:text-gray-400 mb-2'
}, reminder.description),
lead && React.createElement('div', {
className: 'text-sm text-blue-600 dark:text-blue-400'
}, `üë§ ${lead.name} - ${lead.phone} - ${lead.lead_for_event || 'General'}`)
),
React.createElement('div', {
className: 'flex space-x-2'
},
React.createElement('button', {
onClick: () => completeReminder(reminder.id, 'Completed from dashboard'),
className: 'px-3 py-1 bg-green-600 text-white rounded text-sm hover:bg-green-700'
}, '‚úì Complete'),
React.createElement('button', {
onClick: () => snoozeReminder(reminder.id, 24),
className: 'px-3 py-1 bg-yellow-600 text-white rounded text-sm hover:bg-yellow-700'
}, '‚è∞ Snooze'),
lead && React.createElement('button', {
onClick: () => {
setCurrentLead(lead);
setShowEditForm(true);
setShowReminderDashboard(false);
},
className: 'px-3 py-1 bg-blue-600 text-white rounded text-sm hover:bg-blue-700'
}, 'üë§ View Lead')
)
)
);
};



const ReminderDashboard = () => {
if (!showReminderDashboard) return null;

const pendingReminders = reminders.filter(r => r.status === 'pending');
const overdueReminders = pendingReminders.filter(r => new Date(r.due_date) < new Date());
const todayReminders = pendingReminders.filter(r => {
const today = new Date();
const reminderDate = new Date(r.due_date);
return reminderDate.toDateString() === today.toDateString();
});

return React.createElement('div', {
className: 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50'
},
React.createElement('div', {
className: 'bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-6xl h-5/6 flex flex-col'
},
// Header
React.createElement('div', {
className: 'flex items-center justify-between p-6 border-b border-gray-200 dark:border-gray-700'
},
React.createElement('h2', {
className: 'text-2xl font-bold text-gray-900 dark:text-white flex items-center'
},
React.createElement('span', { className: 'mr-3' }, 'üîî'),
'Smart Follow-up Reminders'
),
React.createElement('button', {
onClick: () => setShowReminderDashboard(false),
className: 'text-gray-400 hover:text-gray-600 text-2xl'
}, '√ó')
),

// Stats Cards
React.createElement('div', {
className: 'grid grid-cols-4 gap-4 p-6 bg-gray-50 dark:bg-gray-900'
},
React.createElement('div', {
className: 'bg-white dark:bg-gray-800 rounded-lg p-4 text-center shadow'
},
React.createElement('div', {
className: 'text-2xl font-bold text-blue-600'
}, reminderStats.total),
React.createElement('div', {
className: 'text-sm text-gray-600 dark:text-gray-400'
}, 'Total Reminders')
),
React.createElement('div', {
className: 'bg-white dark:bg-gray-800 rounded-lg p-4 text-center shadow'
},
React.createElement('div', {
className: 'text-2xl font-bold text-red-600'
}, reminderStats.overdue),
React.createElement('div', {
className: 'text-sm text-gray-600 dark:text-gray-400'
}, 'Overdue')
),
React.createElement('div', {
className: 'bg-white dark:bg-gray-800 rounded-lg p-4 text-center shadow'
},
React.createElement('div', {
className: 'text-2xl font-bold text-orange-600'
}, reminderStats.due_today),
React.createElement('div', {
className: 'text-sm text-gray-600 dark:text-gray-400'
}, 'Due Today')
),
React.createElement('div', {
className: 'bg-white dark:bg-gray-800 rounded-lg p-4 text-center shadow'
},
React.createElement('div', {
className: 'text-2xl font-bold text-green-600'
}, reminderStats.pending),
React.createElement('div', {
className: 'text-sm text-gray-600 dark:text-gray-400'
}, 'Pending')
)
),

// Reminders List
React.createElement('div', {
className: 'flex-1 overflow-auto p-6'
},
// Overdue Section
overdueReminders.length > 0 && React.createElement('div', {
className: 'mb-8'
},
React.createElement('h3', {
className: 'text-lg font-semibold text-red-600 mb-4 flex items-center'
},
React.createElement('span', { className: 'mr-2' }, 'üö®'),
`Overdue (${overdueReminders.length})`
),
React.createElement('div', {
className: 'space-y-3'
},
overdueReminders.map(reminder => 
ReminderCard(reminder, true)
)
)
),

// Due Today Section
todayReminders.length > 0 && React.createElement('div', {
className: 'mb-8'
},
React.createElement('h3', {
className: 'text-lg font-semibold text-orange-600 mb-4 flex items-center'
},
React.createElement('span', { className: 'mr-2' }, '‚è∞'),
`Due Today (${todayReminders.length})`
),
React.createElement('div', {
className: 'space-y-3'
},
todayReminders.map(reminder => 
ReminderCard(reminder, false)
)
)
),

// All Pending Reminders
React.createElement('div', null,
React.createElement('h3', {
className: 'text-lg font-semibold text-gray-700 dark:text-gray-300 mb-4 flex items-center'
},
React.createElement('span', { className: 'mr-2' }, 'üìã'),
`All Pending (${pendingReminders.length})`
),
React.createElement('div', {
className: 'space-y-3'
},
pendingReminders.map(reminder => 
ReminderCard(reminder, new Date(reminder.due_date) < new Date())
)
)
)
)
)
);
};

// Communication Timeline Component
const CommunicationTimeline = ({ leadId, leadName }) => {
const [communications, setCommunications] = React.useState([]);
const [loading, setLoading] = React.useState(false);
const [showAddForm, setShowAddForm] = React.useState(false);

const fetchCommunications = async () => {
if (!leadId) return;

try {
setLoading(true);
const response = await window.apicall(`/communications/lead/${leadId}`);
setCommunications(response.data || []);
} catch (error) {
console.error('Error fetching communications:', error);
} finally {
setLoading(false);
}
};



React.useEffect(() => {
fetchCommunications();
}, [leadId]);

const addCommunication = async (commData) => {
try {
const response = await window.apicall('/communications', {
method: 'POST',
body: JSON.stringify({
...commData,
lead_id: leadId
})
});

if (response.data) {
setCommunications(prev => [response.data, ...prev]);
setShowAddForm(false);
alert('Communication logged successfully!');
}
} catch (error) {
console.error('Error adding communication:', error);
alert('Failed to log communication: ' + error.message);
}
};



const getCommIcon = (type) => {
const icons = {
call: 'üìû',
email: 'üìß', 
whatsapp: 'üí¨',
meeting: 'ü§ù',
sms: 'üì±',
system: 'ü§ñ'
};


return icons[type] || 'üìù';
};



const getOutcomeColor = (outcome) => {
const colors = {
interested: 'bg-green-100 text-green-800',
not_interested: 'bg-red-100 text-red-800',
follow_up: 'bg-yellow-100 text-yellow-800',
closed: 'bg-gray-100 text-gray-800'
};


return colors[outcome] || 'bg-blue-100 text-blue-800';
};



return React.createElement('div', { className: 'bg-white rounded-lg shadow-sm border mt-6' },
React.createElement('div', { className: 'p-4 border-b flex justify-between items-center' },
React.createElement('h3', { className: 'text-lg font-semibold flex items-center gap-2' },
React.createElement('span', null, 'üìû'),
`Communication Timeline (${communications.length})`
),
React.createElement('button', {
onClick: () => setShowAddForm(true),
className: 'px-3 py-1 bg-blue-600 text-white text-sm rounded hover:bg-blue-700'
}, '+ Add Communication')
),

showAddForm && React.createElement('div', { className: 'p-4 bg-gray-50 border-b' },
React.createElement(CommunicationForm, {
onSubmit: addCommunication,
onCancel: () => setShowAddForm(false)
})
),

React.createElement('div', { className: 'p-4' },
loading ? React.createElement('div', { className: 'text-center py-8' }, 'Loading communications...') :
communications.length === 0 ? React.createElement('div', { className: 'text-center py-8 text-gray-500' },
'No communications yet. Click "Add Communication" to start tracking interactions.'
) :
React.createElement('div', { className: 'space-y-4' },
communications.map((comm, index) => 
React.createElement('div', { 
key: comm.id,
className: 'flex gap-4 p-3 border-l-4 border-blue-200 bg-gray-50 rounded-r'
},
React.createElement('div', { className: 'flex-shrink-0' },
React.createElement('div', { className: 'w-10 h-10 bg-blue-100 rounded-full flex items-center justify-center text-lg' },
getCommIcon(comm.communication_type)
)
),

React.createElement('div', { className: 'flex-1' },
React.createElement('div', { className: 'flex items-start justify-between' },
React.createElement('div', null,
React.createElement('h4', { className: 'font-medium text-gray-900' }, comm.subject || `${comm.communication_type} ${comm.direction}`),
React.createElement('p', { className: 'text-sm text-gray-600 mt-1' }, comm.content)
),
React.createElement('div', { className: 'text-xs text-gray-500 text-right' },
React.createElement('div', null, new Date(comm.created_date).toLocaleDateString()),
React.createElement('div', null, new Date(comm.created_date).toLocaleTimeString())
)
),

React.createElement('div', { className: 'flex gap-2 mt-2 flex-wrap' },
comm.duration_minutes && React.createElement('span', { className: 'px-2 py-1 bg-gray-200 text-xs rounded' }, 
`${comm.duration_minutes} min`
),
comm.outcome && React.createElement('span', { className: `px-2 py-1 text-xs rounded ${getOutcomeColor(comm.outcome)}` }, 
comm.outcome.replace('_', ' ')
),
comm.temperature && comm.temperature !== 'warm' && React.createElement('span', { 
className: `px-2 py-1 text-xs rounded ${comm.temperature === 'hot' ? 'bg-red-100 text-red-800' : 'bg-blue-100 text-blue-800'}`
}, comm.temperature),
comm.is_auto_logged && React.createElement('span', { className: 'px-2 py-1 bg-purple-100 text-purple-800 text-xs rounded' }, 'Auto-logged')
),

React.createElement('div', { className: 'text-xs text-gray-500 mt-1' },
`by ${comm.created_by_name || comm.created_by}`
)
)
)
)
)
)
);
};

// Set display name for debugging
window.AssignmentRulesManager.displayName = 'window.AssignmentRulesManager';

// ULTRA-FIX: Add display name for debugging
window.AssignmentRulesManager.displayName = 'window.AssignmentRulesManager';

const refreshAssignmentRules = async () => {
try {
// This will clear any cached assignment data and reload fresh rules
await window.apicall('/assignment-rules/refresh', 'POST');
} catch (error) {
console.log('Assignment rules refresh failed (non-critical):', error);
// Non-critical - rules will still work
}
}; 

// Communication Form Component
const CommunicationForm = ({ onSubmit, onCancel }) => {
const [formData, setFormData] = React.useState({
communication_type: 'call',
direction: 'outbound',
subject: '',
content: '',
duration_minutes: '',
outcome: '',
temperature: 'warm'
});

const handleSubmit = (e) => {
e.preventDefault();
if (!formData.subject && !formData.content) {
alert('Please provide a subject or content');
return;
}

onSubmit({
...formData,
duration_minutes: formData.duration_minutes ? parseInt(formData.duration_minutes) : null
});
};



return React.createElement('form', { onSubmit: handleSubmit, className: 'space-y-4' },
React.createElement('div', { className: 'grid grid-cols-1 md:grid-cols-2 gap-4' },
React.createElement('div', null,
React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-1' }, 'Type'),
React.createElement('select', {
value: formData.communication_type,
onChange: (e) => setFormData(prev => ({ ...prev, communication_type: e.target.value })),
className: 'w-full p-2 border border-gray-300 rounded text-sm'
},
React.createElement('option', { value: 'call' }, 'üìû Phone Call'),
React.createElement('option', { value: 'email' }, 'üìß Email'),
React.createElement('option', { value: 'whatsapp' }, 'üí¨ WhatsApp'),
React.createElement('option', { value: 'meeting' }, 'ü§ù Meeting')
)
),

React.createElement('div', null,
React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-1' }, 'Direction'),
React.createElement('select', {
value: formData.direction,
onChange: (e) => setFormData(prev => ({ ...prev, direction: e.target.value })),
className: 'w-full p-2 border border-gray-300 rounded text-sm'
},
React.createElement('option', { value: 'outbound' }, 'üì§ Outbound'),
React.createElement('option', { value: 'inbound' }, 'üì• Inbound')
)
)
),

React.createElement('div', null,
React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-1' }, 'Subject'),
React.createElement('input', {
type: 'text',
value: formData.subject,
onChange: (e) => setFormData(prev => ({ ...prev, subject: e.target.value })),
className: 'w-full p-2 border border-gray-300 rounded text-sm',
placeholder: 'Brief summary...'
})
),

React.createElement('div', null,
React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-1' }, 'Details'),
React.createElement('textarea', {
value: formData.content,
onChange: (e) => setFormData(prev => ({ ...prev, content: e.target.value })),
className: 'w-full p-2 border border-gray-300 rounded text-sm',
rows: 3,
placeholder: 'Detailed notes...'
})
),

React.createElement('div', { className: 'grid grid-cols-1 md:grid-cols-3 gap-4' },
React.createElement('div', null,
React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-1' }, 'Outcome'),
React.createElement('select', {
value: formData.outcome,
onChange: (e) => setFormData(prev => ({ ...prev, outcome: e.target.value })),
className: 'w-full p-2 border border-gray-300 rounded text-sm'
},
React.createElement('option', { value: '' }, 'Select outcome...'),
React.createElement('option', { value: 'interested' }, '‚úÖ Interested'),
React.createElement('option', { value: 'not_interested' }, '‚ùå Not Interested'),
React.createElement('option', { value: 'follow_up' }, 'üîÑ Follow Up Required')
)
),

formData.communication_type === 'call' && React.createElement('div', null,
React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-1' }, 'Duration (min)'),
React.createElement('input', {
type: 'number',
value: formData.duration_minutes,
onChange: (e) => setFormData(prev => ({ ...prev, duration_minutes: e.target.value })),
className: 'w-full p-2 border border-gray-300 rounded text-sm',
placeholder: '15'
})
),

React.createElement('div', null,
React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-1' }, 'Temperature'),
React.createElement('select', {
value: formData.temperature,
onChange: (e) => setFormData(prev => ({ ...prev, temperature: e.target.value })),
className: 'w-full p-2 border border-gray-300 rounded text-sm'
},
React.createElement('option', { value: 'hot' }, 'üî• Hot'),
React.createElement('option', { value: 'warm' }, 'üå°Ô∏è Warm'),
React.createElement('option', { value: 'cold' }, '‚ùÑÔ∏è Cold')
)
)
),

React.createElement('div', { className: 'flex gap-2 justify-end' },
React.createElement('button', {
type: 'button',
onClick: onCancel,
className: 'px-4 py-2 text-gray-600 hover:text-gray-800'
}, 'Cancel'),
React.createElement('button', {
type: 'submit',
className: 'px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700'
}, 'Log Communication')
)
);
};



// ===== END OF COMMUNICATION COMPONENTS =====

// Enhanced sidebar with user access control
const renderSidebar = () => {
const menuItems = [
{ id: 'dashboard', label: 'Dashboard', icon: 'üìä' },
{ id: 'leads', label: 'Leads', icon: 'üë•' },
{ id: 'inventory', label: 'Inventory', icon: 'üé´' },
{ id: 'orders', label: 'Orders', icon: 'üìã' },
{ id: 'delivery', label: 'Delivery', icon: 'üöö' },
{ id: 'finance', label: 'Financials', icon: 'üí∞' },
{ id: 'stadiums', label: 'Stadiums', icon: 'üèüÔ∏è' },
{ id: 'sports-calendar', label: 'Sports Calendar', icon: 'üìÖ' }, // ADD THIS LINE
{ id: 'reminders', label: 'Reminders', icon: 'üîî' },
{ id: 'myactions', label: 'My Actions', icon: 'üìå' },
{ id: 'assignment-rules', label: 'Assignment Rules', icon: '‚öôÔ∏è' }

];

return React.createElement('div', { className: 'w-64 bg-white shadow-lg' },
React.createElement('div', { className: 'p-4' },
React.createElement('div', { className: 'flex items-center space-x-3' },
React.createElement('div', { className: 'w-8 h-8 bg-blue-600 rounded-lg flex items-center justify-center' },
React.createElement('span', { className: 'text-white' }, 'üèÜ')
),
React.createElement('h2', { className: 'text-xl font-bold text-gray-900 dark:text-white' }, 'FanToPark CRM')
),
user && React.createElement('div', { className: 'mt-4 p-3 bg-blue-50 rounded-lg' },
React.createElement('div', { className: 'text-sm font-medium text-blue-900' }, user.name),
React.createElement('div', { className: 'text-xs text-blue-600' }, window.USER_ROLES[user.role]?.label || user.role),
React.createElement('div', { className: 'text-xs text-blue-500' }, user.department)
)
),
React.createElement('nav', { className: 'mt-8' },
menuItems.filter(item => canAccessTab(item.id)).map(item =>
React.createElement('button', {
key: item.id,
onClick: () => setActiveTab(item.id),
className: 'w-full flex items-center px-4 py-3 text-left hover:bg-gray-50 ' + (activeTab === item.id ? 'bg-blue-50 border-r-2 border-blue-600 text-blue-600' : 'text-gray-700')
},
React.createElement('span', { className: 'mr-3' }, item.icon),
item.label
)
),
// User Management - only for users with permission
window.hasPermission('users', 'read') && React.createElement('button', {
onClick: openUserManagement,
className: 'w-full flex items-center px-4 py-3 text-left hover:bg-gray-50 text-gray-700'
},
React.createElement('span', { className: 'mr-3' }, 'üë§'),
'User Management'
),
// Role Management - only for super admin
user && user.role === 'super_admin' && React.createElement('button', {
onClick: () => setActiveTab('roles'),
className: 'w-full flex items-center px-4 py-3 text-left hover:bg-gray-50 text-gray-700'
},
React.createElement('span', { className: 'mr-3' }, 'üõ°Ô∏è'),
'Role Management'
)
),
React.createElement('div', { className: 'mt-auto p-4' },
React.createElement('button', {
onClick: handleLogout,
className: 'w-full flex items-center px-4 py-3 text-gray-700 hover:bg-gray-50 rounded overflow-hidden'
},
React.createElement('span', { className: 'mr-3' }, 'üö™'),
'Logout'
)
)
);
};

const updateDeliveryStatus = (deliveryId) => {
// Implement delivery status update
alert('Delivery status update coming soon!');
};



const approveOrder = async (orderId) => {
if (confirm('Are you sure you want to approve this order?')) {
try {
await window.apicall('/orders/' + (orderId), {
method: 'PUT',
body: JSON.stringify({ status: 'approved' })
});
alert('Order approved successfully!');
fetchMyActions();
} catch (error) {
alert('Failed to approve order: ' + error.message);
}
}
};



const viewOrderDetails = (order) => {
setCurrentOrderDetail(order);
setShowOrderDetail(true);
};



const viewLeadDetails = (lead) => {
setCurrentLead(lead);
setShowLeadDetail(true);
};

// FIXED: Add this BEFORE the renderContent function to create a stable AssignmentRulesTab
const AssignmentRulesTab = React.useMemo(() => {
  return window.hasPermission('leads', 'assign') ? 
    React.createElement(window.AssignmentRulesManager, { 
      key: 'assignment-rules-stable',
      currentUser: user 
    }) :
    React.createElement('div', { className: 'text-center py-12' },
      React.createElement('p', { className: 'text-red-500 text-lg' }, 
        'Access Denied: You do not have permission to manage assignment rules.'
      )
    );
}, [user]); // Only recreate when user changes

// Login screen
if (!isLoggedIn) {
return React.createElement('div', { className: 'min-h-screen bg-gray-100 flex items-center justify-center'},
React.createElement('div', { className: 'max-w-md w-full bg-white rounded-lg shadow-md p-6' },
React.createElement('div', { className: 'text-center mb-8' },
React.createElement('div', { className: 'w-12 h-12 bg-blue-600 rounded-lg flex items-center justify-center mx-auto mb-4' },
React.createElement('span', { className: 'text-white text-xl' }, 'ÔøΩÔøΩ')
),
React.createElement('h2', { className: 'text-2xl font-bold text-gray-900' }, 'FanToPark CRM'),
React.createElement('p', { className: 'text-gray-600' }, 'Sign in to your account')
),
React.createElement('form', { onSubmit: handleLogin },
React.createElement('div', { className: 'mb-4' },
React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-2' }, 'Email'),
React.createElement('input', {
type: 'email',
value: email,
onChange: (e) => setEmail(e.target.value),
className: 'w-full px-3 py-2 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded-md focus:ring-2 focus:ring-blue-500',
required: true
})
),
React.createElement('div', { className: 'mb-6' },
React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-2' }, 'Password'),
React.createElement('input', {
type: 'password',
autoComplete: 'current-password',
value: password,
onChange: (e) => setPassword(e.target.value),
className: 'w-full px-3 py-2 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded-md focus:ring-2 focus:ring-blue-500',
required: true
})
),
React.createElement('button', {
type: 'submit',
disabled: loading,
className: 'w-full bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 disabled:opacity-50'
}, loading ? 'Signing in...' : 'Sign In')
),
React.createElement('div', { className: 'mt-6 text-sm text-gray-600' },
React.createElement('p', { className: 'font-medium mb-2' }, 'Demo Accounts:'),
React.createElement('div', { className: 'space-y-1 text-xs' },
React.createElement('p', null, React.createElement('strong', null, 'Super Admin:'), ' admin@fantopark.com / admin123'),
React.createElement('p', null, React.createElement('strong', null, 'Sales Manager:'), ' varun@fantopark.com / sales123'),
React.createElement('p', null, React.createElement('strong', null, 'Sales Executive:'), ' pratik@fantopark.com / sales123'),
React.createElement('p', null, React.createElement('strong', null, 'Supply Manager:'), ' akshay@fantopark.com / supply123'),
React.createElement('p', null, React.createElement('strong', null, 'Finance Manager:'), ' finance@fantopark.com / finance123')
)
)
)
);
}

// [Include all the missing rendering functions with permission checks]

// Form fields remain the same
const leadFormFields = [
{ name: 'name', label: 'Contact Name', type: 'text', required: true, section: 'basic' },
{ name: 'email', label: 'Email', type: 'email', required: true, section: 'basic' },
{ name: 'phone', label: 'Phone', type: 'tel', required: true, section: 'basic' },
{ name: 'company', label: 'Company', type: 'text', section: 'basic' },
{ name: 'business_type', label: 'Business Type', type: 'select', options: ['B2C', 'B2B'], required: true, section: 'basic' },
{ name: 'source', label: 'Source of Lead', type: 'select', options: [
'Facebook', 'Instagram', 'LinkedIn', 'Friends and Family', 'Through Champion', 
'Website', 'Existing Client', 'Contacted on Social Media', 'Middlemen', 
'Wealth Management Firm', 'Media Agency', 'Concierge Desk', 
'Travel Partner', 'Travel OTA'
], required: true, section: 'source' },
{ name: 'date_of_enquiry', label: 'Date of Enquiry', type: 'date', required: true, section: 'source' },
{ name: 'first_touch_base_done_by', label: 'First Touch Base Done By', type: 'text', required: true, section: 'source' },
{ name: 'city_of_residence', label: 'City of Residence', type: 'text', required: true, section: 'location' },
{ name: 'country_of_residence', label: 'Country of Residence', type: 'select', options: [
'India', 'United States', 'United Kingdom', 'Australia', 'Canada', 'Singapore', 
'UAE', 'Saudi Arabia', 'Germany', 'France', 'Italy', 'Spain', 'Netherlands', 
'Switzerland', 'Japan', 'South Korea', 'Other'
], required: true, section: 'location' },
{ name: 'lead_for_event', label: 'Lead for Event', type: 'inventory_select', required: true, section: 'event' },
{ name: 'number_of_people', label: 'Number of People Going', type: 'number', required: true, min: 1, section: 'event' },
{ name: 'has_valid_passport', label: 'Has Valid Passport', type: 'select', options: ['Yes', 'No', 'Not Sure'], section: 'travel' },
{ name: 'visa_available', label: 'Visa Available', type: 'select', options: ['Yes', 'No', 'Not Required', 'In Process'], section: 'travel' },
{ name: 'attended_sporting_event_before', label: 'Attended Sporting Event Before', type: 'select', options: ['Yes', 'No'], required: true, section: 'experience' },
{ name: 'annual_income_bracket', label: 'Annual Income Bracket', type: 'select', options: [
'Below ‚Çπ5 Lakhs', '‚Çπ5-10 Lakhs', '‚Çπ10-25 Lakhs', '‚Çπ25-50 Lakhs', 
'‚Çπ50 Lakhs - ‚Çπ1 Crore', '‚Çπ1-2 Crores', '‚Çπ2-5 Crores', 'Above ‚Çπ5 Crores'
], required: true, section: 'financial' },
{ name: 'status', label: 'Lead Status', type: 'select', options: Object.keys(window.LEAD_STATUSES), section: 'sales', editOnly: true },
{ name: 'assigned_to', label: 'Assigned To', type: 'select', options: [...(users || []).filter(u => ['sales_executive', 'sales_manager'].includes(u.role)), ...(users || []).filter(u => ['supply_executive', 'supply_sales_service_manager'].includes(u.role))], section: 'sales', editOnly: true},
{ name: 'last_quoted_price', label: 'Last Quoted Price (‚Çπ)', type: 'number', section: 'sales', editOnly: true },
{ name: 'potential_value', label: 'Potential Value (‚Çπ)', type: 'number', section: 'business' },
{ name: 'notes', label: 'Additional Notes', type: 'textarea', section: 'business' }
];

// Enhanced Event Form Fields based on Excel structure
const eventFormFields = [
  // Core Event Information
  { name: 'event_name', label: 'Event Name', type: 'text', required: true, section: 'basic' },
  { name: 'event_type', label: 'Event Type', type: 'select', options: ['Sport', 'Concert', 'Conference', 'Exhibition', 'Other'], required: true, section: 'basic' },
  { name: 'sport_type', label: 'Sport Type', type: 'select', options: ['Cricket', 'Football', 'Tennis', 'Basketball', 'Golf', 'Formula 1', 'Marathon', 'Boxing', 'Wrestling', 'Hockey', 'Badminton', 'Other'], required: true, section: 'basic' },
  { name: 'geography', label: 'Geography/Location', type: 'select', options: ['India', 'UAE - Dubai', 'UAE - Abu Dhabi', 'UK', 'USA', 'Australia', 'South Africa', 'New Zealand', 'Other'], required: true, section: 'basic' },
  
  // Date and Time Information
  { name: 'start_date', label: 'Start Date', type: 'date', required: true, section: 'datetime' },
  { name: 'end_date', label: 'End Date', type: 'date', required: false, section: 'datetime' },
  { name: 'start_time', label: 'Start Time', type: 'time', required: false, section: 'datetime' },
  { name: 'end_time', label: 'End Time', type: 'time', required: false, section: 'datetime' },
  
  // Venue Information
  { name: 'venue', label: 'Venue', type: 'text', required: true, section: 'venue' },
  { name: 'venue_capacity', label: 'Venue Capacity', type: 'number', required: false, section: 'venue' },
  { name: 'venue_address', label: 'Venue Address', type: 'textarea', required: false, section: 'venue' },
  
  // Ticketing Information
  { name: 'official_ticketing_partners', label: 'Official Ticketing Partners', type: 'textarea', required: false, section: 'ticketing' },
  { name: 'primary_source', label: 'Primary Source', type: 'text', required: false, section: 'ticketing' },
  { name: 'secondary_source', label: 'Secondary Source', type: 'text', required: false, section: 'ticketing' },
  { name: 'ticket_available', label: 'Tickets Available for Sale', type: 'checkbox', required: false, section: 'ticketing' },
  
  // Priority and Status
  { name: 'priority', label: 'Priority', type: 'select', options: ['P1', 'P2', 'P3'], required: true, section: 'status' },
  { name: 'status', label: 'Status', type: 'select', options: ['upcoming', 'live', 'completed', 'cancelled', 'postponed'], required: true, section: 'status' },
  { name: 'sold_out_potential', label: 'Sold Out Potential', type: 'select', options: ['High', 'Medium', 'Low', 'No'], required: false, section: 'status' },
  
  // Additional Information
  { name: 'remarks', label: 'Remarks/Description', type: 'textarea', required: false, section: 'additional' },
  { name: 'fantopark_package', label: 'FanToPark Package Details', type: 'textarea', required: false, section: 'additional' }
];  

const inventoryFormFields = [
{ name: 'event_name', label: 'Event Name', type: 'text', required: true },
{ name: 'event_date', label: 'Event Date', type: 'date', required: true },
{ name: 'event_type', label: 'Event Type', type: 'select', options: ['IPL', 'India Cricket + ICC', 'Football', 'Tennis', 'F1', 'Miscellaneous'], required: true },
{ name: 'sports', label: 'Sports Category', type: 'select', options: ['Cricket', 'Football', 'Tennis', 'Formula 1', 'Olympics', 'Basketball', 'Badminton', 'Hockey', 'Golf', 'Wrestling'], required: true },
{ name: 'venue', label: 'Venue', type: 'select', options: 'dynamic', required: true },
{ name: 'day_of_match', label: 'Day of Match (for Test/Multi-day)', type: 'select', options: ['Day 1', 'Day 2', 'Day 3', 'Day 4', 'Day 5', 'Not Applicable'], required: false },
{ name: 'category_of_ticket', label: 'Category of Ticket', type: 'select', options: ['VIP', 'Premium', 'Gold', 'Silver', 'Bronze', 'General', 'Corporate Box', 'Hospitality'], required: true },
{ name: 'stand', label: 'Stand/Section', type: 'text', required: false, placeholder: 'e.g., North Stand, East Pavilion' },
{ name: 'total_tickets', label: 'Total Tickets', type: 'number', required: true },
{ name: 'available_tickets', label: 'Available Tickets', type: 'number', required: true },
{ name: 'mrp_of_ticket', label: 'MRP of Ticket (‚Çπ)', type: 'number', required: true },
{ name: 'buying_price', label: 'Buying Price (‚Çπ)', type: 'number', required: true },
{ name: 'selling_price', label: 'Selling Price (‚Çπ)', type: 'number', required: true },
{ name: 'inclusions', label: 'Inclusions', type: 'textarea', required: false, placeholder: 'e.g., Food, Beverages, Parking, Merchandise, Meet & Greet' },
{ name: 'booking_person', label: 'Booking Person (Who Purchased)', type: 'text', required: true, placeholder: 'Name of person/company who purchased inventory' },
{ name: 'procurement_type', label: 'Procurement Type', type: 'select', options: ['pre_inventory', 'on_demand', 'partnership', 'direct_booking'], required: true },
{ name: 'notes', label: 'Additional Notes', type: 'textarea', required: false, placeholder: 'Any special conditions, restrictions, or notes' },

// Payment Information Fields
{ name: 'paymentStatus', label: 'Payment Status', type: 'select', options: ['paid', 'pending'], required: true },
{ name: 'supplierName', label: 'Supplier Name', type: 'text', required: false },
{ name: 'supplierInvoice', label: 'Supplier Invoice #', type: 'text', required: false },
{ name: 'purchasePrice', label: 'Purchase Price (per ticket)', type: 'number', required: false },
{ name: 'totalPurchaseAmount', label: 'Total Purchase Amount', type: 'number', required: false },
{ name: 'amountPaid', label: 'Amount Paid', type: 'number', required: false },
{ name: 'paymentDueDate', label: 'Payment Due Date', type: 'date', required: false }
];

const orderFormFields = [
{ name: 'client_name', label: 'Client Name', type: 'text', required: true },
{ name: 'client_email', label: 'Client Email', type: 'email', required: true },
{ name: 'client_phone', label: 'Client Phone', type: 'tel', required: true },
{ name: 'event_name', label: 'Event Name', type: 'text', required: true },
{ name: 'event_date', label: 'Event Date', type: 'date', required: true },
{ name: 'tickets_allocated', label: 'Number of Tickets', type: 'number', required: true },
{ name: 'ticket_category', label: 'Ticket Category', type: 'select', options: ['VIP', 'Premium', 'Gold', 'Silver', 'Bronze', 'General'], required: true },
{ name: 'price_per_ticket', label: 'Price per Ticket (‚Çπ)', type: 'number', required: true },
{ name: 'total_amount', label: 'Total Amount (‚Çπ)', type: 'number', required: true },
{ name: 'payment_method', label: 'Payment Method', type: 'select', options: ['Bank Transfer', 'UPI', 'Credit Card', 'Debit Card', 'Cheque', 'Cash'], required: true },
{ name: 'transaction_id', label: 'Transaction ID', type: 'text', required: true },
{ name: 'allocation_notes', label: 'Order Notes', type: 'textarea' }
];



// Function to open allocation management
const openAllocationManagement = async (inventoryItem) => {
try {
setLoading(true);
setAllocationManagementInventory(inventoryItem);

// Fetch allocations for this inventory
const response = await window.apicall(`/inventory/${inventoryItem.id}/allocations`);

if (response.error) {
throw new Error(response.error);
}

setCurrentAllocations(response.data.allocations);
setShowAllocationManagement(true);

} catch (error) {
console.error('Error fetching allocations:', error);
alert('Error fetching allocations: ' + error.message);
} finally {
setLoading(false);
}
};



// Function to unallocate tickets
const handleUnallocate = async (allocationId, ticketsToReturn) => {
if (!confirm(`Are you sure you want to unallocate ${ticketsToReturn} tickets?`)) {
return;
}

try {
setLoading(true);

const response = await window.apicall(`/inventory/${allocationManagementInventory.id}/allocations/${allocationId}`, {
method: 'DELETE'
});

if (response.error) {
throw new Error(response.error);
}

// Refresh allocations
await openAllocationManagement(allocationManagementInventory);

// Update inventory in main list
setInventory(prev => 
prev.map(item => 
item.id === allocationManagementInventory.id 
? { ...item, available_tickets: response.new_available_tickets }
: item
)
);

alert(`Successfully unallocated ${ticketsToReturn} tickets`);

} catch (error) {
console.error('Error unallocating tickets:', error);
alert('Error unallocating tickets: ' + error.message);
} finally {
setLoading(false);
}
};


// ADD this GST invoice preview function
const openInvoicePreview = (invoice) => {
setCurrentInvoice(invoice);
setShowInvoicePreview(true);
};



// Enhanced GST and TCS Calculation Preview Function
const renderEnhancedGSTCalculationPreview = () => {
  // ADD: Calculate invoiceTotal first
  const invoiceTotal = paymentData.invoice_items?.reduce((sum, item) => 
    sum + ((item.quantity || 0) * (item.rate || 0)), 0
  ) || 0;
  
  const baseAmount = window.getBaseAmount(paymentData);
  const calculation = calculateGSTAndTCS(baseAmount, paymentData);
  const isIntraState = paymentData.indian_state === 'Haryana' && !paymentData.is_outside_india;
  const advanceAmount = parseFloat(paymentData.advance_amount) || 0;
  const isReceivablePayment = paymentData.from_receivable || paymentData.payment_post_service;

  // CALCULATE: Final amount with custom TCS rate
  const finalAmount = baseAmount + calculation.gst.total + 
    (calculation.tcs.applicable ? (baseAmount * (paymentData.tcs_rate || calculation.tcs.rate)) / 100 : 0);

  return React.createElement('div', { className: 'mb-6 p-4 bg-gray-50 rounded-lg' },
    React.createElement('h3', { className: 'text-lg font-semibold text-gray-800 mb-4' }, 
      'üßÆ Enhanced Tax Calculation Preview'
    ),
    React.createElement('div', { className: 'grid grid-cols-1 md:grid-cols-2 gap-6' },

      // Left Column - Basic Amounts
      React.createElement('div', { className: 'space-y-3' },
        React.createElement('h4', { className: 'font-medium text-gray-700 border-b pb-2' }, 'Base Amounts'),
        React.createElement('div', { className: 'space-y-2 text-sm' },
          React.createElement('div', { className: 'flex justify-between' },
            React.createElement('span', null, 'Invoice Total:'),
            React.createElement('span', { className: 'font-medium' }, 
              (paymentData.payment_currency || 'INR'), ' ', invoiceTotal.toFixed(2)
            )
          ),
          paymentData.type_of_sale === 'Service Fee' && 
          React.createElement('div', { className: 'flex justify-between border-t pt-2' },
            React.createElement('span', null, 'Service Fee:'),
            React.createElement('span', { className: 'font-medium' }, 
              (paymentData.payment_currency || 'INR'), ' ', (parseFloat(paymentData.service_fee_amount) || 0).toFixed(2)
            )
          ),
          React.createElement('div', { className: 'flex justify-between font-medium border-t pt-2' },
            React.createElement('span', null, 'Taxable Amount:'),
            React.createElement('span', null, 
              (paymentData.payment_currency || 'INR'), ' ', baseAmount.toFixed(2)
            )
          )
        )
      ),

      // Right Column - Tax Breakdown
      React.createElement('div', { className: 'space-y-3' },
        React.createElement('h4', { className: 'font-medium text-gray-700 border-b pb-2' }, 'Tax Breakdown'),
        React.createElement('div', { className: 'space-y-2 text-sm' },

          // GST Section
          calculation.gst.applicable ? [
            isIntraState ? [
              React.createElement('div', { key: 'cgst', className: 'flex justify-between' },
                React.createElement('span', null, `CGST (${calculation.gst.rate/2}%):`),
                React.createElement('span', { className: 'font-medium' }, 
                  (paymentData.payment_currency || 'INR'), ' ', calculation.gst.cgst.toFixed(2)
                )
              ),
              React.createElement('div', { key: 'sgst', className: 'flex justify-between' },
                React.createElement('span', null, `SGST (${calculation.gst.rate/2}%):`),
                React.createElement('span', { className: 'font-medium' }, 
                  (paymentData.payment_currency || 'INR'), ' ', calculation.gst.sgst.toFixed(2)
                )
              )
            ] : React.createElement('div', { key: 'igst', className: 'flex justify-between' },
              React.createElement('span', null, `IGST (${calculation.gst.rate}%):`),
              React.createElement('span', { className: 'font-medium' }, 
                (paymentData.payment_currency || 'INR'), ' ', calculation.gst.igst.toFixed(2)
              )
            )
          ] : React.createElement('div', { key: 'no-gst', className: 'flex justify-between text-gray-500' },
            React.createElement('span', null, 'GST:'),
            React.createElement('span', null, 'Not Applicable')
          ),

          // TCS Section with dynamic rate
          calculation.tcs.applicable ? 
          React.createElement('div', { className: 'flex justify-between text-yellow-700' },
            React.createElement('span', null, `TCS (${paymentData.tcs_rate || calculation.tcs.rate}%):`),
            React.createElement('span', { className: 'font-medium' }, 
              paymentData.payment_currency || 'INR', ' ', 
              ((baseAmount * (paymentData.tcs_rate || calculation.tcs.rate)) / 100).toFixed(2)
            )
          ) : React.createElement('div', { className: 'flex justify-between text-gray-500' },
            React.createElement('span', null, 'TCS:'),
            React.createElement('span', null, 'Not Applicable')
          ),

          // Final Amount with custom TCS rate
          React.createElement('div', { className: 'flex justify-between text-lg font-bold border-t pt-2 mt-2' },
            React.createElement('span', null, 'Final Amount:'),
            React.createElement('span', null, 
              paymentData.payment_currency || 'INR', ' ', finalAmount.toFixed(2)
            )
          ),

          // Payment Information
          !isReceivablePayment && React.createElement('div', { className: 'flex justify-between border-t pt-2' },
            React.createElement('span', { className: 'font-semibold' }, 'Advance Received:'),
            React.createElement('span', { className: 'font-semibold text-blue-600' }, 
              (paymentData.payment_currency || 'INR'), ' ', advanceAmount.toFixed(2)
            )
          ),
          !isReceivablePayment && React.createElement('div', { className: 'flex justify-between' },
            React.createElement('span', { className: 'font-bold' }, 'Balance Due:'),
            React.createElement('span', { className: 'font-bold text-orange-600' }, 
              (paymentData.payment_currency || 'INR'), ' ', (finalAmount - advanceAmount).toFixed(2)
            )
          ),
          isReceivablePayment && React.createElement('div', { className: 'flex justify-between border-t pt-2' },
            React.createElement('span', { className: 'font-bold' }, 'Payment Being Collected:'),
            React.createElement('span', { className: 'font-bold text-green-600' }, 
              (paymentData.payment_currency || 'INR'), ' ', advanceAmount.toFixed(2)
            )
          )
        )
      )
    )
  );
}; 

const handleOrderApproval = async (orderId, action) => {
if (!window.hasPermission('orders', 'approve')) {
alert('You do not have permission to approve orders');
return;
}

setLoading(true);

try {
const order = orders.find(o => o.id === orderId);
console.log('Approving order:', order);

// If rejecting, ask for notes
let notes = '';
if (action === 'reject') {
notes = prompt('Please provide rejection reason:');
if (!notes) {
setLoading(false);
return;
}
}

const newStatus = action === 'approve' ? 'approved' : 'rejected';
let invoiceNumber = null;
let invoiceId = null;

// Generate GST invoice if approved
if (action === 'approve' && (order.requires_gst_invoice || order.gstin)) {
invoiceNumber = 'STTS/INV/' + (new Date().getFullYear()) + '/' + (String(Date.now()).slice(-6));
invoiceId = Date.now();

const newInvoice = {
id: invoiceId,
invoice_number: invoiceNumber,
order_id: orderId,
order_number: order.order_number,
client_name: order.legal_name || order.client_name,
client_email: order.client_email,

// GST Details
gstin: order.gstin,
legal_name: order.legal_name,
category_of_sale: order.category_of_sale,
type_of_sale: order.type_of_sale,
registered_address: order.registered_address,
indian_state: order.indian_state,
is_outside_india: order.is_outside_india,

// Invoice calculation
invoice_items: order.invoice_items,
base_amount: order.base_amount,
gst_calculation: order.gst_calculation,
total_tax: order.total_tax,
final_amount: order.final_amount || order.total_amount,

invoice_date: new Date().toISOString().split('T')[0],
due_date: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
status: 'generated',
generated_by: user.name
};



setInvoices(prev => [...prev, newInvoice]);
}

// Update order in backend with all necessary fields including invoice info
const updateData = {
status: newStatus,
approved_date: new Date().toISOString(),
approval_notes: notes,
approved_by: user.name,
payment_status: order.payment_status || 'pending'
};



// Add invoice fields if invoice was generated
if (invoiceNumber && invoiceId) {
updateData.invoice_number = invoiceNumber;
updateData.invoice_id = invoiceId;
}

// Send update to backend
await window.apicall('/orders/' + orderId, {
method: 'PUT',
body: JSON.stringify(updateData)
});

// CREATE RECEIVABLES FOR PARTIAL/POST-SERVICE PAYMENTS
if (action === 'approve') {
console.log('Order approved, checking if receivable needed...');
console.log('Order type:', order.order_type);
console.log('Payment status:', order.payment_status);

// Check if it's a post-service payment or partial payment
const isPostService = order.order_type === 'payment_post_service' || 
order.lead_status === 'payment_post_service';
const isPartialPayment = order.payment_status === 'partial' || 
(order.amount_paid && order.amount_paid < order.total_amount);

console.log('Is post service:', isPostService);
console.log('Is partial payment:', isPartialPayment);

if (isPostService || isPartialPayment) {
// Calculate pending amount
const paidAmount = parseFloat(order.amount_paid || 0);
const totalAmount = parseFloat(order.total_amount || order.final_amount || 0);
const pendingAmount = totalAmount - paidAmount;

console.log('Total amount:', totalAmount);
console.log('Paid amount:', paidAmount);
console.log('Pending amount:', pendingAmount);

if (pendingAmount > 0) {
// Create receivable entry
const receivableData = {
order_id: orderId,
order_number: order.order_number,
client_name: order.client_name || order.lead_name,
client_email: order.client_email,
client_phone: order.client_phone,
invoice_number: invoiceNumber || order.invoice_number || 'INV-' + orderId,
expected_amount: pendingAmount,
amount_paid: paidAmount,
balance_amount: pendingAmount,
due_date: order.expected_payment_date || 
new Date(Date.now() + 30*24*60*60*1000).toISOString(),
payment_terms: order.payment_terms || 'Net 30',
assigned_to: order.assigned_to || order.created_by,
status: 'pending',
created_date: new Date().toISOString(),
created_by: user.name,
is_post_service: isPostService,
event_date: order.event_date,
event_name: order.event_name
};



console.log('Creating receivable with data:', receivableData);

try {
const receivableResponse = await window.apicall('/receivables', {
method: 'POST',
body: JSON.stringify(receivableData)
});
console.log('Receivable created successfully:', receivableResponse);

// Update local receivables state if it exists
if (typeof setReceivables === 'function') {
setReceivables(prev => [...prev, receivableResponse.data || receivableResponse]);
}
} catch (error) {
console.error('Failed to create receivable:', error);
alert('Order approved but failed to create receivable. Please create it manually.');
}
}
}
}

// Update local state
setOrders(prev => 
prev.map(o => o.id === orderId ? { ...o, ...updateData } : o)
);

// Refresh financial data if user has permission
if (window.hasPermission('finance', 'read')) {
await fetchFinancialData();
}

setLoading(false);

// Custom alert message based on what happened
let alertMessage = action === 'approve' ? 'Order approved successfully!' : 'Order rejected successfully.';
if (action === 'approve' && invoiceNumber) {
alertMessage += ' GST Invoice has been generated.';
}
alert(alertMessage);

} catch (error) {
console.error('Order approval error:', error);
setLoading(false);
alert('Failed to update order status');
}
};


const handleDeleteLead = async (leadId) => {
if (!confirm('Are you sure you want to delete this lead?')) return;

try {
await window.apicall('/leads/' + (leadId), { method: 'DELETE' });
setLeads(prev => prev.filter(lead => lead.id !== leadId));

// ‚úÖ ADD: Refresh assignment rules after lead deletion
if (window.refreshAssignmentRules && typeof window.refreshAssignmentRules === 'function') {
try {
await window.refreshAssignmentRules();
console.log('‚úÖ Assignment rules refreshed after lead deletion');
} catch (refreshError) {
console.log('‚ö†Ô∏è Assignment rules refresh failed (non-critical):', refreshError);
}
}

alert('Lead deleted successfully!');
} catch (error) {
alert('Failed to delete lead: ' + error.message);
}
};

const togglePremiumStatus = async (leadId, isPremium) => {
  try {
    setLoading(true);
    
    const response = await window.apicall(`/leads/${leadId}`, {
      method: 'PUT',
      body: JSON.stringify({ is_premium: isPremium })
    });
    
    // Update the leads list
    setLeads(prev => prev.map(lead => 
      lead.id === leadId ? { ...lead, is_premium: isPremium } : lead
    ));
    
    // Update currentLead if viewing the lead details
    if (showLeadDetail && currentLead?.id === leadId) {
      setCurrentLead(prev => ({ ...prev, is_premium: isPremium }));
    }
    
    console.log(`‚úÖ Lead ${leadId} premium status updated to ${isPremium}`);
    
  } catch (error) {
    console.error('Error updating premium status:', error);
    alert('Failed to update premium status: ' + error.message);
  } finally {
    setLoading(false);
  }
};

const handleDeleteInventory = async (inventoryId) => {
if (!confirm('Are you sure you want to delete this event?')) return;

try {
await window.apicall('/inventory/' + (inventoryId), { method: 'DELETE' });
setInventory(prev => prev.filter(item => item.id !== inventoryId));
alert('Event deleted successfully!');
} catch (error) {
alert('Failed to delete event: ' + error.message);
}
};


const populateDefaultStadiums = async () => {
if (!confirm('This will add popular stadiums to your database. Continue?')) return;

const defaultStadiums = [
// Cricket Stadiums - India
{ 
name: 'Wankhede Stadium', 
city: 'Mumbai', 
state: 'Maharashtra', 
country: 'India', 
sport_type: 'Cricket', 
capacity: 33000, 
opened_year: 1974,
nickname: 'Home of Indian Cricket',
notes: 'Famous for hosting Cricket World Cup finals'
},
{ 
name: 'Eden Gardens', 
city: 'Kolkata', 
state: 'West Bengal', 
country: 'India', 
sport_type: 'Cricket', 
capacity: 66000, 
opened_year: 1864,
nickname: 'Cricket\'s Colosseum',
notes: 'One of the oldest and largest cricket stadiums'
},
{ 
name: 'M. Chinnaswamy Stadium', 
city: 'Bangalore', 
state: 'Karnataka', 
country: 'India', 
sport_type: 'Cricket', 
capacity: 40000, 
opened_year: 1969,
notes: 'Known for high-scoring matches and IPL games'
},
{ 
name: 'Feroz Shah Kotla Ground', 
city: 'Delhi', 
state: 'Delhi', 
country: 'India', 
sport_type: 'Cricket', 
capacity: 41000, 
opened_year: 1883,
notes: 'One of the oldest cricket grounds in India'
},
{ 
name: 'MA Chidambaram Stadium', 
city: 'Chennai', 
state: 'Tamil Nadu', 
country: 'India', 
sport_type: 'Cricket', 
capacity: 50000, 
opened_year: 1916,
nickname: 'Chepauk Stadium',
notes: 'Known for its spinning pitches'
},
{ 
name: 'Narendra Modi Stadium', 
city: 'Ahmedabad', 
state: 'Gujarat', 
country: 'India', 
sport_type: 'Cricket', 
capacity: 132000, 
opened_year: 2020,
nickname: 'Motera Stadium',
notes: 'World\'s largest cricket stadium'
},

// Cricket Stadiums - International
{ 
name: 'Lord\'s Cricket Ground', 
city: 'London', 
country: 'United Kingdom', 
sport_type: 'Cricket', 
capacity: 31000, 
opened_year: 1814, 
nickname: 'Home of Cricket',
notes: 'Most famous cricket ground in the world'
},
{ 
name: 'Melbourne Cricket Ground', 
city: 'Melbourne', 
state: 'Victoria',
country: 'Australia', 
sport_type: 'Cricket', 
capacity: 100024, 
opened_year: 1853, 
nickname: 'MCG',
notes: 'Largest cricket stadium in the Southern Hemisphere'
},
{ 
name: 'The Oval', 
city: 'London', 
country: 'United Kingdom', 
sport_type: 'Cricket', 
capacity: 23500, 
opened_year: 1845,
notes: 'Famous for hosting the final Test of English summer'
},
{ 
name: 'Sydney Cricket Ground', 
city: 'Sydney', 
state: 'New South Wales',
country: 'Australia', 
sport_type: 'Cricket', 
capacity: 48000, 
opened_year: 1848, 
nickname: 'SCG',
notes: 'Hosts New Year Test matches'
},

// Football Stadiums - International
{ 
name: 'Camp Nou', 
city: 'Barcelona', 
country: 'Spain', 
sport_type: 'Football', 
capacity: 99354, 
opened_year: 1957,
notes: 'Home of FC Barcelona, largest stadium in Europe'
},
{ 
name: 'Wembley Stadium', 
city: 'London', 
country: 'United Kingdom', 
sport_type: 'Football', 
capacity: 90000, 
opened_year: 2007,
nickname: 'The Home of Football',
notes: 'England national team home, hosts FA Cup finals'
},
{ 
name: 'Old Trafford', 
city: 'Manchester', 
country: 'United Kingdom', 
sport_type: 'Football', 
capacity: 74140, 
opened_year: 1910, 
nickname: 'Theatre of Dreams',
notes: 'Home of Manchester United'
},
{ 
name: 'Santiago Bernab√©u', 
city: 'Madrid', 
country: 'Spain', 
sport_type: 'Football', 
capacity: 81044, 
opened_year: 1947,
notes: 'Home of Real Madrid, hosts Champions League finals'
},
{ 
name: 'Allianz Arena', 
city: 'Munich', 
country: 'Germany', 
sport_type: 'Football', 
capacity: 75000, 
opened_year: 2005,
notes: 'Famous for its color-changing exterior'
},

// Multi-Sport & Other Venues
{ 
name: 'Madison Square Garden', 
city: 'New York', 
state: 'New York',
country: 'United States', 
sport_type: 'Multi-Sport', 
capacity: 20000, 
opened_year: 1968, 
nickname: 'The Garden',
notes: 'Famous for basketball, hockey, and concerts'
},
{ 
name: 'Maracan√£ Stadium', 
city: 'Rio de Janeiro', 
country: 'Brazil', 
sport_type: 'Football', 
capacity: 78838, 
opened_year: 1950,
notes: 'Hosted 2014 FIFA World Cup final'
},
{ 
name: 'Wimbledon', 
city: 'London', 
country: 'United Kingdom', 
sport_type: 'Tennis', 
capacity: 15000, 
opened_year: 1877,
nickname: 'All England Club',
notes: 'Most prestigious tennis tournament venue'
}
];

try {
setLoading(true);
console.log(`üèüÔ∏è Adding ${defaultStadiums.length} popular stadiums...`);

const response = await window.apicall('/stadiums/bulk', {
method: 'POST',
body: JSON.stringify({ stadiums: defaultStadiums })
});

// Refresh stadiums list
await fetchStadiums();

alert(`‚úÖ Successfully added ${response.success || defaultStadiums.length} popular stadiums!${response.errors > 0 ? ` (${response.errors} duplicates skipped)` : ''}`);

} catch (error) {
console.error('‚ùå Error adding default stadiums:', error);
alert('‚ùå Error adding stadiums: ' + error.message);
} finally {
setLoading(false);
}
}; 

// Close inventory form
const closeInventoryForm = () => {
setShowInventoryForm(false);
setEditingInventory(null);
setFormData({});
};

const renderClientViewContent = () => {
if (clientsLoading) {
return React.createElement('div', { className: 'text-center py-12' },
React.createElement('div', { className: 'text-gray-500' }, 'Loading clients...')
);
}

if (clients.length === 0) {
return React.createElement('div', { className: 'bg-white rounded-lg shadow-sm border p-8 text-center' },
React.createElement('div', { className: 'text-gray-500 text-lg mb-2' }, 'No clients found'),
React.createElement('p', { className: 'text-gray-400' }, 'Clients will appear here when you have leads with phone numbers'),
React.createElement('div', { className: 'mt-4' },
React.createElement('button', {
onClick: () => setViewMode('leads'),
className: 'text-blue-600 hover:text-blue-800 underline'
}, 'Go to Lead View to create leads')
)
);
}

return React.createElement('div', { className: 'space-y-6' },

// Client Statistics Summary
React.createElement('div', { className: 'grid grid-cols-1 md:grid-cols-4 gap-4' },
React.createElement('div', { className: 'bg-blue-50 border border-blue-200 rounded-lg p-4' },
React.createElement('div', { className: 'text-2xl font-bold text-blue-900' }, clients.length),
React.createElement('div', { className: 'text-sm text-blue-700' }, 'Total Clients')
),
React.createElement('div', { className: 'bg-green-50 border border-green-200 rounded-lg p-4' },
React.createElement('div', { className: 'text-2xl font-bold text-green-900' }, 
clients.filter(c => c.total_leads > 1).length
),
React.createElement('div', { className: 'text-sm text-green-700' }, 'Multi-Lead Clients')
),
React.createElement('div', { className: 'bg-purple-50 border border-purple-200 rounded-lg p-4' },
React.createElement('div', { className: 'text-2xl font-bold text-purple-900' }, 
clients.reduce((sum, c) => sum + c.total_leads, 0)
),
React.createElement('div', { className: 'text-sm text-purple-700' }, 'Total Leads')
),
React.createElement('div', { className: 'bg-orange-50 border border-orange-200 rounded-lg p-4' },
React.createElement('div', { className: 'text-2xl font-bold text-orange-900' }, 
'‚Çπ' + clients.reduce((sum, c) => sum + (parseFloat(c.total_value) || 0), 0).toLocaleString()
),
React.createElement('div', { className: 'text-sm text-orange-700' }, 'Total Client Value')
)
),

// Client Table
React.createElement('div', { className: 'bg-white rounded-lg shadow-sm border overflow-hidden' },
React.createElement('div', { className: 'px-6 py-4 border-b border-gray-200 bg-gray-50' },
React.createElement('h3', { className: 'text-lg font-medium text-gray-900' }, 'Clients Overview'),
React.createElement('p', { className: 'text-sm text-gray-600 mt-1' }, 
'Leads grouped by phone number - Click to see complete client timeline'
)
),
React.createElement('div', { className: 'overflow-x-auto' },
React.createElement('table', { className: 'w-full' },
React.createElement('thead', { className: 'bg-gray-50' },
React.createElement('tr', null,
React.createElement('th', { className: 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase' }, 'Client'),
React.createElement('th', { className: 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase' }, 'Leads'),
React.createElement('th', { className: 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase' }, 'Events'),
React.createElement('th', { className: 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase' }, 'Assigned To'),
React.createElement('th', { className: 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase' }, 'Status'),
React.createElement('th', { className: 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase' }, 'Value'),
React.createElement('th', { className: 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase' }, 'Actions')
)
),
React.createElement('tbody', { className: 'bg-white divide-y divide-gray-200' },
clients.map(client => {
const primaryLead = client.leads[0];
return React.createElement('tr', { key: client.client_id, className: 'hover:bg-gray-50' },
React.createElement('td', { className: 'px-6 py-4' },
React.createElement('div', { 
className: 'cursor-pointer hover:text-blue-600',
onClick: () => {
setSelectedClient(client);
setShowClientDetail(true);
}
},
React.createElement('div', { className: 'text-sm font-medium text-gray-900 hover:text-blue-600' }, 
primaryLead.name
),
React.createElement('div', { className: 'text-sm text-gray-500' }, primaryLead.phone),
React.createElement('div', { className: 'text-xs text-gray-400' }, 
`First contact: ${new Date(client.first_contact).toLocaleDateString()}`
)
)
),
React.createElement('td', { className: 'px-6 py-4' },
React.createElement('div', { className: 'flex items-center' },
React.createElement('span', { 
className: `inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${
  client.total_leads > 1 ? 'bg-blue-100 text-blue-800' : 'bg-gray-100 text-gray-800'
}`
}, 
client.total_leads,
client.total_leads > 1 && React.createElement('span', { className: 'ml-1' }, 'üîó')
)
)
),
React.createElement('td', { className: 'px-6 py-4' },
React.createElement('div', { className: 'text-sm text-gray-900' },
client.events.length > 0 ? client.events.slice(0, 2).join(', ') : '-'
),
client.events.length > 2 && React.createElement('div', { className: 'text-xs text-gray-500' },
`+${client.events.length - 2} more`
)
),
React.createElement('td', { className: 'px-6 py-4 text-sm text-gray-900' },
client.assigned_to || 'Unassigned'
),
React.createElement('td', { className: 'px-6 py-4' },
React.createElement('span', { 
className: `px-2 py-1 text-xs rounded-full ${
client.status === 'converted' ? 'bg-green-100 text-green-800' :
client.status === 'dropped' ? 'bg-red-100 text-red-800' :
'bg-yellow-100 text-yellow-800'
}`
}, client.status || 'active')
),
React.createElement('td', { className: 'px-6 py-4 text-sm text-gray-900' },
client.total_value ? `‚Çπ${(parseFloat(client.total_value) || 0).toLocaleString()}` : '-'
),
React.createElement('td', { className: 'px-6 py-4 text-sm font-medium space-x-2' },
React.createElement('button', {
onClick: () => {
setSelectedClient(client);
setShowClientDetail(true);
},
className: 'text-blue-600 hover:text-blue-900'
}, 'View Timeline'),
window.hasPermission('leads', 'assign') && client.total_leads > 1 &&
React.createElement('button', {
onClick: () => {
// Bulk reassign functionality - will implement in next phase
alert(`Bulk reassign for ${client.total_leads} leads coming in next update!`);
},
className: 'text-green-600 hover:text-green-900 ml-2'
}, 'Reassign All')
)
);
})
)
)
)
)
);
};



// 1. ESPN API ENDPOINTS AND FETCH FUNCTIONS
const SOFASCORE_API_BASE = "https://api.sofascore.com/api/v1";

// ESPN API fetch function with error handling
const fetchSofaScoreData = async (endpoint) => {
try {
const response = await fetch(endpoint, {
method: 'GET',
headers: {
'Accept': 'application/json',
'Content-Type': 'application/json'
}
});

if (!response.ok) {
throw new Error(`SofaScore API error: ${response.status}`);
}

const data = await response.json();
return data;
} catch (error) {
console.error('SofaScore API fetch error:', error);
return null;
}
};



// Fetch events from multiple sports leagues
const fetchAllEvents = async () => {
  try {
    console.log("Fetching all events from backend...");
    const response = await fetch(`${window.API_CONFIG.API_URL}/events`, {
      method: "GET",
      headers: { "Authorization": `Bearer ${localStorage.getItem("crm_auth_token")}` }
    });
    if (response.ok) {
      const result = await response.json();
      if (result.success && result.data) {
        const transformedEvents = result.data.map(event => ({
          id: event.id, title: event.event_name, date: event.start_date,
          time: event.start_time || "", venue: event.venue || "",
          category: event.sport_type || "", status: event.status || "upcoming",
          ...event
        }));
        setSportsEvents(transformedEvents);
      }
    }
  } catch (error) { console.error("Error fetching events:", error); }
};



const fetchSofaScoreEvents = async () => {
try {
setLoading(true);

// Define sports endpoints for different leagues
const sportsEndpoints = [
{
name: "Premier League",
endpoint: `${SOFASCORE_API_BASE}/unique-tournament/17/season/52186/events/last/0`,
category: "football"
},
{
name: "Champions League",
endpoint: `${SOFASCORE_API_BASE}/unique-tournament/7/season/52162/events/last/0`,
category: "football"
},
{
name: "NBA",
endpoint: `${SOFASCORE_API_BASE}/unique-tournament/132/season/58766/events/last/0`,
category: "basketball"
}
];

const allEvents = [];

// Fetch events from each sport
for (const sport of sportsEndpoints) {
const data = await fetchSofaScoreData(sport.endpoint);

if (data && data.events) {
const processedEvents = data.events.map(event => ({
id: `sofascore_${event.id}`,
title: `${event.name || event.shortName}`,
date: new Date(event.date).toISOString().split('T')[0],
time: new Date(event.date).toLocaleTimeString('en-US', { 
hour: '2-digit', 
minute: '2-digit',
hour12: false 
}),
venue: event.competitions?.[0]?.venue?.fullName || 'TBD',
category: sport.category,
description: `${sport.name} - ${event.status?.type?.description || 'Scheduled'}`,
ticket_available: true,
fantopark_package: generateFanToParkPackage(event, sport.name),
status: getEventStatus(event.status?.type?.name),
espn_data: {
league: sport.name,
competitors: event.competitions?.[0]?.competitors?.map(comp => ({
name: comp.team?.displayName,
logo: comp.team?.logo,
record: comp.records?.[0]?.summary
})) || [],
broadcasts: event.competitions?.[0]?.broadcasts || [],
odds: event.competitions?.[0]?.odds || []
}
}));

allEvents.push(...processedEvents);
}
}

// Sort events by date
allEvents.sort((a, b) => new Date(a.date) - new Date(b.date));

// Update state with fetched events
setSportsEvents(allEvents);
setLoading(false);

return allEvents;

} catch (error) {
console.error('Error fetching ESPN events:', error);
setLoading(false);

// Fallback to some basic events if ESPN API fails
setSportsEvents([
{
id: 'fallback_001',
title: 'ESPN API Unavailable - Sample Event',
date: new Date().toISOString().split('T')[0],
time: '20:00',
venue: 'Various Stadiums',
category: 'multi-sport',
description: 'ESPN API is currently unavailable. This is a fallback event.',
ticket_available: false,
fantopark_package: 'Please check back later for live events',
status: 'upcoming'
}
]);

return [];
}
};



// Generate FanToPark package descriptions based on event type
const generateFanToParkPackage = (event, sportName) => {
const venue = event.competitions?.[0]?.venue?.fullName || 'Stadium';
const competitors = event.competitions?.[0]?.competitors;

let packagePrice = '‚Çπ15,000';
let packageType = 'Standard Package';

// Customize package based on sport and event importance
if (sportName.includes('Cricket') || sportName.includes('ICC')) {
packagePrice = '‚Çπ25,000';
packageType = 'Cricket Premium Package';
} else if (sportName.includes('Premier League')) {
packagePrice = '‚Çπ35,000';
packageType = 'Premier League VIP Package';
} else if (sportName.includes('NFL')) {
packagePrice = '‚Çπ45,000';
packageType = 'NFL Elite Package';
} else if (sportName.includes('NBA')) {
packagePrice = '‚Çπ30,000';
packageType = 'NBA Courtside Package';
}

const teamNames = competitors?.map(c => c.team?.displayName).join(' vs ') || 'Teams TBD';

return `${packageType}: ${packagePrice} - ${teamNames} at ${venue}, Premium seating, refreshments, and match commentary`;
};



// Convert ESPN event status to our status format
const getEventStatus = (espnStatus) => {
if (!espnStatus) return 'upcoming';

switch (espnStatus.toLowerCase()) {
case 'scheduled':
case 'pre':
return 'upcoming';
case 'in':
case 'live':
return 'live';
case 'final':
case 'completed':
return 'completed';
case 'postponed':
case 'canceled':
return 'cancelled';
default:
return 'upcoming';
}
}; 

// 6. EVENT DETAIL MODAL
const renderEventDetailModal = () => {
if (!showEventDetail || !currentEvent) return null;

return React.createElement('div', {
className: 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4',
style: { backdropFilter: 'blur(4px)' },
onClick: (e) => {
if (e.target === e.currentTarget) setShowEventDetail(false);
}
},
React.createElement('div', {
className: 'bg-white rounded-xl max-w-4xl w-full max-h-[90vh] overflow-auto shadow-2xl',
onClick: (e) => e.stopPropagation()
},
React.createElement('div', {
className: `p-6 border-b ${window.getPriorityStyles(currentEvent.priority)}`
},
React.createElement('div', { className: 'flex justify-between items-start' },
React.createElement('div', { className: 'flex-1' },
React.createElement('div', { className: 'flex items-center gap-3 mb-2' },
React.createElement('h2', { className: 'text-2xl font-bold' },
currentEvent.event_name || currentEvent.title
),
React.createElement('span', {
className: `px-3 py-1 text-sm font-semibold rounded-full ${window.getPriorityBadgeColor(currentEvent.priority)}`
}, currentEvent.priority || 'N/A')
),
React.createElement('p', { className: 'text-sm opacity-75' },
`${currentEvent.sport_type || currentEvent.category || 'Event'} ‚Ä¢ ${currentEvent.geography || 'Location TBD'}`
)
),
React.createElement('button', {
onClick: () => setShowEventDetail(false),
className: 'text-gray-500 hover:text-gray-700 text-2xl p-2 rounded-lg hover:bg-gray-100'
}, '‚úï')
)
),
React.createElement('div', { className: 'p-6 grid md:grid-cols-2 gap-6' },
React.createElement('div', { className: 'space-y-6' },
React.createElement('div', null,
React.createElement('h3', { className: 'text-lg font-semibold mb-3 flex items-center' },
React.createElement('span', { className: 'mr-2' }, 'üìÖ'),
'Date & Time'
),
React.createElement('div', { className: 'space-y-2 text-sm bg-gray-50 p-4 rounded-lg' },
React.createElement('div', { className: 'flex justify-between' },
React.createElement('span', { className: 'font-medium text-gray-700' }, 'Date:'),
React.createElement('span', { className: 'text-gray-900' },
new Date(currentEvent.start_date || currentEvent.date).toLocaleDateString()
)
),
React.createElement('div', { className: 'flex justify-between' },
React.createElement('span', { className: 'font-medium text-gray-700' }, 'Time:'),
React.createElement('span', { className: 'text-gray-900 font-mono' },
currentEvent.start_time || currentEvent.time || 'TBD'
)
)
)
),
currentEvent.venue && React.createElement('div', null,
React.createElement('h3', { className: 'text-lg font-semibold mb-3 flex items-center' },
React.createElement('span', { className: 'mr-2' }, 'üèüÔ∏è'),
'Venue'
),
React.createElement('div', { className: 'bg-gray-50 p-4 rounded-lg' },
React.createElement('div', { className: 'font-medium text-gray-900' },
currentEvent.venue
)
)
),
React.createElement('div', null,
React.createElement('h3', { className: 'text-lg font-semibold mb-3 flex items-center' },
React.createElement('span', { className: 'mr-2' }, 'üìä'),
'Status & Priority'
),
React.createElement('div', { className: 'flex flex-wrap gap-2' },
React.createElement('span', {
className: `px-3 py-1 text-sm font-semibold rounded-full ${window.getPriorityBadgeColor(currentEvent.priority)}`
}, `Priority ${currentEvent.priority || 'N/A'}`),
React.createElement('span', {
className: `px-3 py-1 text-sm font-semibold rounded-full ${
currentEvent.status === 'live' ? 'bg-red-500 text-white animate-pulse' :
currentEvent.status === 'upcoming' ? 'bg-blue-500 text-white' :
currentEvent.status === 'completed' ? 'bg-gray-500 text-white' :
'bg-gray-400 text-white'
}`
}, (currentEvent.status || 'upcoming').toUpperCase())
)
)
),
React.createElement('div', { className: 'space-y-6' },
currentEvent.fantopark_package && React.createElement('div', null,
React.createElement('h3', { className: 'text-lg font-semibold mb-3 flex items-center' },
React.createElement('span', { className: 'mr-2' }, 'üì¶'),
'FanToPark Package'
),
React.createElement('div', { className: 'bg-blue-50 p-4 rounded-lg border border-blue-200' },
React.createElement('p', { className: 'text-blue-900 text-sm' },
currentEvent.fantopark_package
)
)
),
currentEvent.description && React.createElement('div', null,
React.createElement('h3', { className: 'text-lg font-semibold mb-3 flex items-center' },
React.createElement('span', { className: 'mr-2' }, 'üìù'),
'Description'
),
React.createElement('div', { className: 'bg-gray-50 p-4 rounded-lg' },
React.createElement('p', { className: 'text-gray-700 text-sm' },
currentEvent.description
)
)
)
)
),
React.createElement('div', { className: 'px-6 pb-6 flex flex-wrap gap-3' },
React.createElement('button', {
onClick: () => {
setEventFormData({
...currentEvent,
event_name: currentEvent.event_name || currentEvent.title,
start_date: currentEvent.start_date || currentEvent.date,
start_time: currentEvent.start_time || currentEvent.time,
venue: currentEvent.venue,
sport_type: currentEvent.sport_type || currentEvent.category,
priority: currentEvent.priority,
status: currentEvent.status,
description: currentEvent.description,
fantopark_package: currentEvent.fantopark_package
});
setShowEventDetail(false);
setShowEventForm(true);
},
className: 'px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-medium transition-colors flex items-center gap-2'
},
React.createElement('span', null, '‚úèÔ∏è'),
'Edit Event'
),
React.createElement('button', {
onClick: () => {
console.log('Creating lead for event:', currentEvent.id);
},
className: 'px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 font-medium transition-colors flex items-center gap-2'
},
React.createElement('span', null, 'üéØ'),
'Create Lead'
),
React.createElement('button', {
onClick: () => setShowEventDetail(false),
className: 'px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50 font-medium transition-colors'
}, 'Close')
)
)
);
};



// 7. EVENT FORM MODAL
const renderEventFormModal = () => {
  if (!showEventForm) return null;

 const handleEventSubmit = async (e) => {
  e.preventDefault();
  
  try {
    // Sanitize event data - remove undefined values completely
    const sanitizeData = (data) => {
      const sanitized = {};
      Object.keys(data).forEach(key => {
        const value = data[key];
        
        // Only include non-undefined, non-null values
        if (value !== undefined && value !== null) {
          // Convert empty strings to actual empty strings, not null
          if (typeof value === 'string') {
            sanitized[key] = value.trim();
          } else if (typeof value === 'number' && !isNaN(value)) {
            sanitized[key] = value;
          } else if (typeof value === 'boolean') {
            sanitized[key] = value;
          } else if (value !== '') {
            sanitized[key] = value;
          }
        }
        // Skip completely if undefined, null, or problematic
      });
      return sanitized;
    };

    // Build clean event data object
    const cleanEventData = {};
    
    // Required fields
    if (eventFormData.event_name && eventFormData.event_name.trim()) {
      cleanEventData.event_name = eventFormData.event_name.trim();
    }
    if (eventFormData.event_type && eventFormData.event_type.trim()) {
      cleanEventData.event_type = eventFormData.event_type.trim();
    }
    if (eventFormData.sport_type && eventFormData.sport_type.trim()) {
      cleanEventData.sport_type = eventFormData.sport_type.trim();
    }
    if (eventFormData.geography && eventFormData.geography.trim()) {
      cleanEventData.geography = eventFormData.geography.trim();
    }
    if (eventFormData.start_date && eventFormData.start_date.trim()) {
      cleanEventData.start_date = eventFormData.start_date.trim();
    }
    if (eventFormData.venue && eventFormData.venue.trim()) {
      cleanEventData.venue = eventFormData.venue.trim();
    }
    if (eventFormData.priority && eventFormData.priority.trim()) {
      cleanEventData.priority = eventFormData.priority.trim();
    }
    
    // Optional fields - only add if they have actual values
    if (eventFormData.end_date && eventFormData.end_date.trim()) {
      cleanEventData.end_date = eventFormData.end_date.trim();
    }
    if (eventFormData.start_time && eventFormData.start_time.trim()) {
      cleanEventData.start_time = eventFormData.start_time.trim();
    }
    if (eventFormData.end_time && eventFormData.end_time.trim()) {
      cleanEventData.end_time = eventFormData.end_time.trim();
    }
    if (eventFormData.venue_capacity && eventFormData.venue_capacity !== '') {
      const capacity = parseInt(eventFormData.venue_capacity);
      if (!isNaN(capacity)) {
        cleanEventData.venue_capacity = capacity;
      }
    }
    if (eventFormData.venue_address && eventFormData.venue_address.trim()) {
      cleanEventData.venue_address = eventFormData.venue_address.trim();
    }
    if (eventFormData.official_ticketing_partners && eventFormData.official_ticketing_partners.trim()) {
      cleanEventData.official_ticketing_partners = eventFormData.official_ticketing_partners.trim();
    }
    if (eventFormData.primary_source && eventFormData.primary_source.trim()) {
      cleanEventData.primary_source = eventFormData.primary_source.trim();
    }
    if (eventFormData.secondary_source && eventFormData.secondary_source.trim()) {
      cleanEventData.secondary_source = eventFormData.secondary_source.trim();
    }
    if (eventFormData.sold_out_potential && eventFormData.sold_out_potential.trim()) {
      cleanEventData.sold_out_potential = eventFormData.sold_out_potential.trim();
    }
    if (eventFormData.remarks && eventFormData.remarks.trim()) {
      cleanEventData.remarks = eventFormData.remarks.trim();
    }
    if (eventFormData.fantopark_package && eventFormData.fantopark_package.trim()) {
      cleanEventData.fantopark_package = eventFormData.fantopark_package.trim();
    }
    
    // Boolean field
    cleanEventData.ticket_available = Boolean(eventFormData.ticket_available);
    
    // Status with default
    cleanEventData.status = eventFormData.status && eventFormData.status.trim() ? eventFormData.status.trim() : 'upcoming';

    console.log('Sending clean event data:', cleanEventData); // Debug log

    const url = currentEvent ? `${window.API_CONFIG.API_URL}/events/${currentEvent.id}` : `${window.API_CONFIG.API_URL}/events`;
    const method = currentEvent ? 'PUT' : 'POST';
    
    const response = await fetch(url, {
      method: method,
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${localStorage.getItem('crm_auth_token')}`
      },
      body: JSON.stringify(cleanEventData)
    });

    const result = await response.json();
    
    if (result.success) {
      // Refresh events list
      await fetchSportsEvents();
      setShowEventForm(false);
      setCurrentEvent(null);
      resetEventForm();
      alert(currentEvent ? 'Event updated successfully!' : 'Event created successfully!');
    } else {
      throw new Error(result.error || 'Failed to save event');
    }
  } catch (error) {
    console.error('Error saving event:', error);
    alert('Error saving event: ' + error.message);
  }
};





  const resetEventForm = () => {
    setEventFormData({
      event_name: '',
      event_type: '',
      sport_type: '',
      geography: '',
      start_date: '',
      end_date: '',
      start_time: '',
      end_time: '',
      venue: '',
      venue_capacity: '',
      venue_address: '',
      official_ticketing_partners: '',
      primary_source: '',
      secondary_source: '',
      ticket_available: false,
      priority: '',
      status: 'upcoming',
      sold_out_potential: '',
      remarks: '',
      fantopark_package: ''
    });
  };

  const renderFormSection = (sectionName, title) => {
    const sectionFields = eventFormFields.filter(field => field.section === sectionName);
    
    return React.createElement('div', { className: 'mb-6' },
      React.createElement('h3', { className: 'text-lg font-semibold text-gray-900 mb-3 border-b pb-2' }, title),
      React.createElement('div', { className: 'grid grid-cols-1 md:grid-cols-2 gap-4' },
        ...sectionFields.map(field => {
          if (field.type === 'textarea') {
            return React.createElement('div', { key: field.name, className: 'md:col-span-2' },
              React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-1' }, 
                field.label + (field.required ? ' *' : '')
              ),
              React.createElement('textarea', {
                value: eventFormData[field.name] || '',
                onChange: (e) => setEventFormData({...eventFormData, [field.name]: e.target.value}),
                className: 'w-full p-2 border border-gray-300 rounded-lg',
                required: field.required,
                rows: 3,
                placeholder: field.placeholder || ''
              })
            );
          } else if (field.type === 'select') {
            return React.createElement('div', { key: field.name },
              React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-1' }, 
                field.label + (field.required ? ' *' : '')
              ),
              React.createElement('select', {
                value: eventFormData[field.name] || '',
                onChange: (e) => setEventFormData({...eventFormData, [field.name]: e.target.value}),
                className: 'w-full p-2 border border-gray-300 rounded-lg',
                required: field.required
              },
                React.createElement('option', { value: '' }, `Select ${field.label}`),
                ...field.options.map(option =>
                  React.createElement('option', { key: option, value: option }, option)
                )
              )
            );
          } else if (field.type === 'checkbox') {
            return React.createElement('div', { key: field.name, className: 'flex items-center' },
              React.createElement('input', {
                type: 'checkbox',
                checked: eventFormData[field.name] || false,
                onChange: (e) => setEventFormData({...eventFormData, [field.name]: e.target.checked}),
                className: 'mr-2',
                id: field.name
              }),
              React.createElement('label', { 
                htmlFor: field.name,
                className: 'text-sm font-medium text-gray-700' 
              }, field.label)
            );
          } else {
            return React.createElement('div', { key: field.name },
              React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-1' }, 
                field.label + (field.required ? ' *' : '')
              ),
              React.createElement('input', {
                type: field.type,
                value: eventFormData[field.name] || '',
                onChange: (e) => setEventFormData({...eventFormData, [field.name]: e.target.value}),
                className: 'w-full p-2 border border-gray-300 rounded-lg',
                required: field.required,
                placeholder: field.placeholder || ''
              })
            );
          }
        })
      )
    );
  };

  return React.createElement('div', {
    className: 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50',
    onClick: () => setShowEventForm(false)
  },
    React.createElement('div', {
      className: 'bg-white dark:bg-gray-800 rounded-lg w-full max-w-4xl max-h-[90vh] overflow-y-auto',
      onClick: (e) => e.stopPropagation()
    },
      React.createElement('form', { onSubmit: handleEventSubmit, className: 'p-6' },
        React.createElement('div', { className: 'flex justify-between items-center mb-6' },
          React.createElement('h2', { className: 'text-2xl font-bold' }, 
            currentEvent ? 'Edit Event' : 'Add New Event'
          ),
          React.createElement('button', {
            type: 'button',
            onClick: () => setShowEventForm(false),
            className: 'text-gray-400 hover:text-gray-600 text-2xl'
          }, '‚úï')
        ),

        // Form sections
        renderFormSection('basic', 'üìÖ Basic Information'),
        renderFormSection('datetime', '‚è∞ Date & Time'),
        renderFormSection('venue', 'üèüÔ∏è Venue Details'),
        renderFormSection('ticketing', 'üé´ Ticketing Information'),
        renderFormSection('status', 'üìä Priority & Status'),
        renderFormSection('additional', 'üìù Additional Information'),

        // Form actions
        React.createElement('div', { className: 'flex justify-end space-x-3 mt-6 pt-6 border-t' },
          React.createElement('button', {
            type: 'button',
            onClick: () => setShowEventForm(false),
            className: 'px-6 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50'
          }, 'Cancel'),
          React.createElement('button', {
            type: 'submit',
            className: 'px-6 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-medium'
          }, currentEvent ? 'Update Event' : 'Create Event')
        )
      )
    )
  );
};

return React.createElement('div', { className: 'flex h-screen bg-gray-100 dark:bg-gray-900' },
renderSidebar(),
React.createElement('div', { className: 'flex-1 flex flex-col overflow-hidden' },
React.createElement('header', { className: 'bg-white dark:bg-gray-800 shadow-sm border-b dark:border-gray-700 px-6 py-4' },
React.createElement('div', { className: 'flex items-center justify-between' },
React.createElement('div', null,
React.createElement('h1', { className: 'text-lg font-semibold' }, 'Welcome, ' + (user?.name || 'Admin User')),
React.createElement('p', { className: 'text-sm text-gray-600 dark:text-gray-400' }, window.USER_ROLES[user?.role]?.label + ' ‚Ä¢ ' + user?.department)
),
React.createElement('div', { className: 'flex items-center space-x-4' },
React.createElement('span', { className: 'text-lg' }, 'üîî'),
React.createElement('button', {
onClick: () => setShowHelpGuide(true),
className: 'p-2 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors',
title: 'How to use CRM'
}, '‚ùì'),
React.createElement('button', {
onClick: () => {
setDarkMode(!darkMode);
document.documentElement.classList.toggle('dark');
localStorage.setItem('crm_dark_mode', !darkMode);
},
className: 'p-2 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors',
title: darkMode ? 'Switch to light mode' : 'Switch to dark mode'
}, darkMode ? '‚òÄÔ∏è' : 'üåô'),
React.createElement('div', { className: 'w-8 h-8 bg-blue-600 rounded-full flex items-center justify-center' },
React.createElement('span', { className: 'text-white text-sm' }, (user?.name || 'A')[0])
),
currentUser && currentUser.role === 'super_admin' && React.createElement('div', { 
className: 'flex items-center gap-2 ml-4'
},
React.createElement('button', {
onClick: () => {
const newMode = !testMode;
setTestMode(newMode);
localStorage.setItem('testMode', newMode.toString());
if (newMode) {
document.body.classList.add('test-mode-active');
} else {
document.body.classList.remove('test-mode-active');
}
},
className: 'relative inline-flex h-6 w-12 items-center rounded-full transition-colors ' + 
(testMode ? 'bg-red-600' : 'bg-gray-300'),
title: 'Toggle Test Mode'
},
React.createElement('span', {
className: 'inline-block h-4 w-4 transform rounded-full bg-white transition-transform ' +
(testMode ? 'translate-x-6' : 'translate-x-1')
})
),
testMode && React.createElement('span', { 
className: 'text-red-600 font-bold text-sm ml-2'
}, 'TEST MODE')
)
)
)
),
React.createElement('main', { className: 'flex-1 overflow-y-auto p-6' },
testMode && user.role === 'super_admin' && React.createElement('div', {
className: 'bg-red-100 border-2 border-red-500 text-red-700 p-4 rounded-lg mb-4 text-center font-bold animate-pulse'
}, 
'‚ö†Ô∏è TEST MODE ACTIVE - Delete buttons and test data fills are enabled!'
),
window.renderContent()
)
),

// Modal forms
ReminderDashboard(),  
renderInventoryForm(),                           
renderForm(),
showCSVUploadModal && React.createElement(CSVUploadModal, {
isOpen: showCSVUploadModal,
onClose: () => {
setShowCSVUploadModal(false);
setCSVUploadType('');
},
type: csvUploadType,
authToken: authToken
}),
renderAssignForm(),
renderBulkAssignModal(),                           
renderPaymentForm(),
renderLeadDetail(),
showInventoryDetail && renderInventoryDetail(),                   
renderAllocationForm(),
renderAllocationManagement(),
renderStadiumForm(),                           
renderChoiceModal(),
renderUserManagement(),
renderStatusProgressModal(),                           
renderUserForm(),
renderGSTInvoicePreview(),
renderOrderDetailModal(),
renderOrderAssignmentModal(),
renderOrderDetailModal(),
renderOrderAssignmentModal(),
renderDeliveryForm(),
renderOrderDetail(),
renderEditOrderForm(),
renderPaymentPostServiceForm(),
window.renderPaymentSubmitHandler(),
window.renderInventoryFormSubmitHandler(),
window.renderDeleteHandler(),                           
renderHelpGuide(),
showClientDetail && renderClientDetailModal(),
showEventDetail && renderEventDetailModal(),
showPreview && React.createElement(UploadPreviewModal),
showClientDetectionResults && React.createElement(ClientDetectionResultsModal),                           
showEventForm && renderEventFormModal() 
);
}

// Render the app
ReactDOM.render(React.createElement(App), document.getElementById('root'));

</script>

<script src="components/test-mode-system.js"></script>
</body>
</html>

