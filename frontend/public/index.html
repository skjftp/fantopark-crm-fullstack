
<!-- CRM Version:FIELD-MAPPING-FIXED-20250630 -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<link rel="icon" type="image/x-icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>FanToPark CRM Pro</title>
<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://cdn.tailwindcss.com"></script>
<!-- Load all constant files -->
<script src="constants/config.js"></script>
<script src="constants/status-config.js"></script>
<script src="constants/user-roles.js"></script>
<script src="constants/form-config.js"></script>
<script src="constants/default-data.js"></script>
<!-- Utility Functions -->
<script src="utils/api.js"></script>
<script src="utils/permissions.js"></script>
<script src="utils/helpers.js"></script>
<!-- Component Files -->
<script src="components/assignment-rules.js"></script>
<script src="components/my-actions.js"></script>
<script src="components/leads.js"></script>
<script src="components/dashboard.js"></script>  
<script src="components/content-router.js"></script>
<script src="components/inventory.js"></script>
<script src="components/financials.js"></script>
<script src="components/orders.js"></script> 
<script src="components/user-management.js"></script>
<script src="components/stadiums.js"></script> 
<script src="components/delivery.js"></script>
<script src="components/sports-calendar.js"></script> 
<script src="components/reminders.js"></script>
<script src="components/inventory-form.js"></script>
<script src="components/lead-form.js"></script> 
<script src="components/lead-detail.js"></script>
<script src="components/payment-form.js"></script>
<script src="components/inventory-detail.js"></script>
<script src="components/order-detail-modal.js"></script>
<script src="components/user-form.js"></script>
<script src="components/gst-invoice-preview.js"></script>
<script src="components/assign-form.js"></script>
<script src="components/bulk-assign-modal.js"></script>
<script src="components/choice-modal.js"></script>  
<script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>  

<!-- API Configuration--->
<script>
// Configure API endpoint

// Global function to handle proceed from preview
window.handleProceedFromPreview = () => {
if (window.currentUploadFile) {
console.log("üöÄ Starting upload with file:", window.currentUploadFile.name);

// Close any open modals by clicking cancel/close buttons
const cancelBtn = Array.from(document.querySelectorAll("button")).find(b => b.textContent === "Cancel");
if (cancelBtn) cancelBtn.click();

// Trigger the upload with the stored file
const formData = new FormData();
formData.append("file", window.currentUploadFile);
fetch(window.API_CONFIG.API_URL + "/upload/leads/csv", {
method: "POST",
headers: { Authorization: authToken ? "Bearer " + authToken : undefined },
body: formData
}).then(response => response.json()).then(result => {
console.log("‚úÖ Upload successful:", result);
alert("‚úÖ Upload successful: " + result.message);
window.currentUploadFile = null;
location.reload();
}).catch(error => {
console.error("‚ùå Upload failed:", error);
alert("‚ùå Upload failed: " + error.message);
});
} else {
alert("No file selected for upload");
}
};


console.log("üîó window.API_CONFIG.API_URL set to:", window.API_CONFIG.API_URL);
console.log("üîó window.API_CONFIG.API_URL:", window.API_CONFIG.API_URL);
// Get stored auth token
let authToken = localStorage.getItem("crm_auth_token");

// Update authToken if found in localStorage
if (authToken) {
console.log("Auth token loaded from localStorage");
}

</script>

<style>
/* Dark mode base styles */
.dark {
color-scheme: dark;
}

.dark body {
background-color: #111827;
color: #f3f4f6;
}

/* Dark mode for main containers */
.dark .bg-white {
background-color: #1f2937 !important;
}

.dark .bg-gray-50 {
background-color: #111827 !important;
}

.dark .bg-gray-100 {
background-color: #0f172a !important;
}

/* Dark mode for text */
.dark .text-gray-900 {
color: #f3f4f6 !important;
}

.dark .text-gray-800 {
color: #e5e7eb !important;
}

.dark .text-gray-700 {
color: #d1d5db !important;
}

.dark .text-gray-600 {
color: #9ca3af !important;
}

.dark .text-gray-500 {
color: #6b7280 !important;
}

/* Dark mode for borders */
.dark .border-gray-200 {
border-color: #374151 !important;
}

.dark .border-gray-300 {
border-color: #4b5563 !important;
}

.dark .border-b {
border-color: #374151 !important;
}

/* Dark mode for inputs and forms */
.dark input, .dark select, .dark textarea {
background-color: #374151 !important;
border-color: #4b5563 !important;
color: #f3f4f6 !important;
}

.dark input:focus, .dark select:focus, .dark textarea:focus {
border-color: #3b82f6 !important;
background-color: #4b5563 !important;
}

/* Dark mode for hover states */
.dark .hover\:bg-gray-50:hover {
background-color: #374151 !important;
}

.dark .hover\:bg-gray-100:hover {
background-color: #4b5563 !important;
}

/* Dark mode for tables */
.dark table {
background-color: #1f2937 !important;
}

.dark thead {
background-color: #111827 !important;
}

.dark tbody tr:hover {
background-color: #374151 !important;
}

/* Dark mode for modals */
.dark .bg-black.bg-opacity-50 {
background-color: rgba(0, 0, 0, 0.75) !important;
}

/* Dark mode for shadows */
.dark .shadow-sm {
box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.5) !important;
}

.dark .shadow-md {
box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5) !important;
}

/* Dark mode for sidebar */
.dark .bg-gray-900 {
background-color: #0f172a !important;
}

/* Dark mode scrollbars */
.dark ::-webkit-scrollbar {
background-color: #1f2937;
}

.dark ::-webkit-scrollbar-thumb {
background-color: #4b5563;
}

.dark ::-webkit-scrollbar-thumb:hover {
background-color: #6b7280;
}


/* Invoice Styles - Updated to match invoice module */
.invoice-preview {
background: white;
border: 2px solid #000;
font-family: Arial, sans-serif;
font-size: 10px;
line-height: 1.2;
margin: 0 auto;
max-width: 210mm;
height: fit-content;
padding: 8mm;
box-sizing: border-box;
display: block;
overflow: hidden;
}
.invoice-header-row {
display: grid;
grid-template-columns: 300px 1fr auto;
padding: 10px 8px;
border-bottom: 2px solid #000;
align-items: center;
margin-bottom: 10px;
background: #f8f9fa;
}
.company-logo {
width: 210px;
height: 150px;
margin: 0;
}
.company-logo img {
max-width: 210px;
max-height: 150px;
object-fit: contain;
}
.invoice-title {
text-align: right;
font-size: 16px;
font-weight: bold;
padding-top: 10px;
color: #2c3e50;
}
.invoice-meta {
display: grid;
grid-template-columns: 1fr 1fr;
padding: 8px;
border-bottom: 1px solid #000;
font-size: 10px;
margin-bottom: 10px;
background: #f8f9fa;
}
.customer-section {
padding: 10px 8px;
border-bottom: 1px solid #000;
margin-bottom: 12px;
background: #f8f9fa;
}
.customer-title {
font-weight: bold;
margin-bottom: 4px;
font-size: 10px;
}
.invoice-table {
width: 100%;
border-collapse: collapse;
font-size: 10px;
margin-bottom: 12px;
}
.invoice-table th {
background: #2c3e50;
color: white;
padding: 6px 4px;
text-align: left;
border: 1px solid #000;
font-weight: bold;
font-size: 10px;
}
.invoice-table td {
padding: 6px 4px;
border: 1px solid #000;
text-align: left;
background: white;
}
.totals-table {
width: 100%;
border-collapse: collapse;
font-size: 10px;
margin-bottom: 12px;
}
.totals-table td {
padding: 4px;
border: 1px solid #000;
}
.bank-details {
display: grid;
grid-template-columns: 1fr 1fr;
padding: 10px 8px;
border: 2px solid #2c3e50;
font-size: 9px;
gap: 10px;
background: #f8f9fa;
margin-top: 10px;
}
.bank-info h4 {
margin-bottom: 6px;
font-size: 10px;
color: #2c3e50;
border-bottom: 1px solid #2c3e50;
padding-bottom: 2px;
}
.bank-info div {
margin-bottom: 2px;
line-height: 1.1;
}
.payment-qr {
text-align: center;
}
.payment-qr img {
width: 120px;
height: 120px;
border: 2px solid #ddd;
padding: 5px;
background: white;
}
.invoice-footer {
margin-top: 10px;
text-align: center;
font-size: 8px;
color: #666;
}
.company-info-section {
background: white;
padding: 8px;
border: 1px solid #ddd;
border-radius: 3px;
margin-bottom: 8px;
}
.company-info-section h4 {
color: #2c3e50;
margin-bottom: 6px;
border-bottom: 1px solid #2c3e50;
padding-bottom: 2px;
text-align: center;
font-size: 9px;
}
@media print {
body { background: white; padding: 0; margin: 0; }
.invoice-preview { border: none; box-shadow: none; margin: 0; padding: 5mm; }
.modal-backdrop { display: none; }
.sticky { position: relative !important; }
@page { margin: 10mm; size: A4; }
}
/* Fix for action buttons */
.action-buttons button {
position: relative;
z-index: 10;
cursor: pointer;
}
td .flex button {
position: relative;
z-index: 10;
}

/* Logout button fix */
.logout-button-fix {
position: relative !important;
width: auto !important;
height: auto !important;
}

/* Prevent invisible overlays */
button:not(:hover) {
z-index: auto !important;
}

/* Ensure sidebar stays contained */
.sidebar-container {
overflow: hidden;
}


/* Logout button area fix */
.sidebar-logout {
margin-top: auto;
padding: 1rem;
border-top: 1px solid #e5e7eb;
}

.sidebar-logout button {
width: 100%;
max-width: 200px;
margin: 0 auto;
display: flex;
align-items: center;
padding: 0.75rem 1rem;
border-radius: 0.375rem;
transition: background-color 0.2s;
}

.sidebar-logout button:hover {
background-color: #f9fafb;
}

/* Prevent any overlay issues */
.sidebar-container > div:last-child {
position: relative !important;
bottom: auto !important;
left: auto !important;
right: auto !important;
}

</style>

<style>
.test-mode-active {
border: 4px solid #dc2626 !important;
box-shadow: inset 0 0 0 4px #dc2626;
}

/* Logout button fix */
.logout-button-fix {
position: relative !important;
width: auto !important;
height: auto !important;
}

/* Prevent invisible overlays */
button:not(:hover) {
z-index: auto !important;
}

/* Ensure sidebar stays contained */
.sidebar-container {
overflow: hidden;
}


/* Logout button area fix */
.sidebar-logout {
margin-top: auto;
padding: 1rem;
border-top: 1px solid #e5e7eb;
}

.sidebar-logout button {
width: 100%;
max-width: 200px;
margin: 0 auto;
display: flex;
align-items: center;
padding: 0.75rem 1rem;
border-radius: 0.375rem;
transition: background-color 0.2s;
}

.sidebar-logout button:hover {
background-color: #f9fafb;
}

/* Prevent any overlay issues */
.sidebar-container > div:last-child {
position: relative !important;
bottom: auto !important;
left: auto !important;
right: auto !important;
}

</style>
</head>
<body>
<div id="test-mode-indicator" style="display:none; background:#dc2626; color:white; text-align:center; padding:10px; font-weight:bold;">
üß™ TEST MODE ACTIVE - Delete All buttons enabled
</div>
<script>if(localStorage.getItem('testMode')==='true') document.getElementById('test-mode-indicator').style.display='block';</script>
<div id="root"></div>
<div id="error-message" style="position: fixed; top: 20px; right: 20px; background: #ef4444; color: white; padding: 12px 20px; border-radius: 6px; display: none; z-index: 9999;"></div>
<script>


// Show previous logs on page load
window.addEventListener('load', () => {
const logs = JSON.parse(sessionStorage.getItem('debugLogs') || '[]');
if (logs.length > 0) {
console.log('=== Previous Session Logs ===');
logs.forEach(log => console.log('[' + (log.time) + '] ' + (log.key) + ':', log.data));
console.log('=== End Previous Logs ===');
}
});

// Clear logs button (press Ctrl+Shift+L)
document.addEventListener('keydown', (e) => {
if (e.ctrlKey && e.shiftKey && e.key === 'L') {
sessionStorage.removeItem('debugLogs');
console.log('Debug logs cleared');
}
});

const { useState, useEffect, useRef } = React;


// Helper function to display user names instead of emails


// Helper function to get proper role display label
window.getRoleDisplayLabel = function(roleName) {
// Map of role names to display labels
const roleLabels = {
'super_admin': 'Super Admin',
'admin': 'Admin', 
'sales_manager': 'Sales Manager',
'sales_executive': 'Sales Executive',
'supply_manager': 'Supply Manager', // Legacy
'supply_sales_service_manager': 'Supply Sales Service Manager', // Updated
'finance_manager': 'Finance Manager',
'viewer': 'Viewer'
};



return roleLabels[roleName] || roleName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
};



// Helper function to format date for display (DD/MM/YYYY)
const formatDateForDisplay = (dateValue) => {
if (!dateValue) return 'Not Set';

try {
let date;

if (dateValue instanceof Date) {
date = dateValue;
} else if (typeof dateValue === 'string' && dateValue.includes('T')) {
date = new Date(dateValue);
} else if (typeof dateValue === 'string') {
date = new Date(dateValue);
} else if (typeof dateValue === 'object' && dateValue._seconds) {
date = new Date(dateValue._seconds * 1000);
} else {
return 'Invalid Date';
}

if (isNaN(date.getTime())) {
return 'Invalid Date';
}

const day = String(date.getDate()).padStart(2, '0');
const month = String(date.getMonth() + 1).padStart(2, '0');
const year = date.getFullYear();

return `${day}/${month}/${year}`;
} catch (error) {
return 'Error';
}
};


// Replace existing calculateGST function

// Helper function to get lead temperature (preserves temperature through parallel stages)
const getLeadTemperature = (lead) => {
// If current status has temperature, use it
if (window.LEAD_STATUSES[lead.status]?.temperature) {
return window.LEAD_STATUSES[lead.status].temperature;
}

// If it's a parallel stage, get temperature from lead data
if (lead.temperature) {
return lead.temperature;
}

// Fallback to status if it's a temperature status
if (['hot', 'warm', 'cold'].includes(lead.status)) {
return lead.status;
}

return null;
};



// Helper function to get display temperature for dashboard
const getDisplayTemperature = (lead) => {
const temp = getLeadTemperature(lead);
if (temp && ['hot', 'warm', 'cold'].includes(temp)) {
return temp;
}
// For quote_requested, check if it was previously hot/warm/cold
if (lead.status === 'quote_requested' && lead.temperature) {
return lead.temperature;
}
return null;
};



function App() {
// Authentication states
const [isLoggedIn, setIsLoggedIn] = useState(false);
const [testMode, setTestMode] = useState(() => {
return localStorage.getItem('testMode') === 'true';
});
const [user, setUser] = useState(null);
const [email, setEmail] = useState('');
const [password, setPassword] = useState('');
const [activeTab, setActiveTab] = useState(() => {
const savedTab = localStorage.getItem('crm_active_tab');
return savedTab || 'dashboard';
});
const [loading, setLoading] = useState(false);

// Users management

// Initialize empty, will fetch from API
const [leads, setLeads] = useState([]);
const [inventory, setInventory] = useState([]);
// Add this line near other useState declarations
const [editingInventory, setEditingInventory] = useState(null);
const [showInventoryForm, setShowInventoryForm] = useState(false);
const [orders, setOrders] = useState([]);
const [orderToAssign, setOrderToAssign] = useState(null);
const [reminders, setReminders] = useState([]);
const [showReminderDashboard, setShowReminderDashboard] = useState(false);
const [reminderStats, setReminderStats] = useState({
total: 0,
overdue: 0,
due_today: 0,
pending: 0
}); 
const [sportsEvents, setSportsEvents] = useState([]);
const [showEventForm, setShowEventForm] = useState(false);
const [showEventDetail, setShowEventDetail] = useState(false);
const [currentEvent, setCurrentEvent] = useState(null);
const [eventFormData, setEventFormData] = useState({
title: "",
date: "",
time: "",
venue: "",
category: "cricket",
description: "",
ticket_available: false,
fantopark_package: ""
});
const [calendarView, setCalendarView] = useState("month");
const [selectedDate, setSelectedDate] = useState(new Date());
const [showOrderAssignModal, setShowOrderAssignModal] = useState(false);
const [showAllocationManagement, setShowAllocationManagement] = React.useState(false);
const [showInventoryDetail, setShowInventoryDetail] = useState(false);
const [currentInventoryDetail, setCurrentInventoryDetail] = useState(null);
const [currentAllocations, setCurrentAllocations] = React.useState([]);
const [showOrderForm, setShowOrderForm] = useState(false);
const [inventoryEventTypeFilter, setInventoryEventTypeFilter] = useState('all');
const [inventorySortField, setInventorySortField] = useState('event_date');
const [inventorySortDirection, setInventorySortDirection] = useState('desc'); // 'asc' or 'desc'
const [allocationManagementInventory, setAllocationManagementInventory] = React.useState(null);
const [leadsSourceFilter, setLeadsSourceFilter] = useState('all');
const [leadsBusinessTypeFilter, setLeadsBusinessTypeFilter] = useState('all');
const [leadsEventFilter, setLeadsEventFilter] = useState('all');
const [leadsSortField, setLeadsSortField] = useState('date_of_enquiry');
const [leadsSortDirection, setLeadsSortDirection] = useState('desc');
const [showBulkAssignModal, setShowBulkAssignModal] = useState(false);
const [bulkAssignSelections, setBulkAssignSelections] = useState({});
const [bulkAssignLoading, setBulkAssignLoading] = useState(false);
const [selectedStatusFilters, setSelectedStatusFilters] = useState([]);
const [showStatusFilterDropdown, setShowStatusFilterDropdown] = useState(false);
const statusDropdownRef = React.useRef(null);
const [stadiums, setStadiums] = useState([]);
const [showStadiumForm, setShowStadiumForm] = useState(false);
const [editingStadium, setEditingStadium] = useState(null);
const [stadiumFormData, setStadiumFormData] = useState({});
const [stadiumSortField, setStadiumSortField] = useState('name');
const [stadiumSortDirection, setStadiumSortDirection] = useState('asc');
const [stadiumSearchQuery, setStadiumSearchQuery] = useState('');
const [stadiumSportFilter, setStadiumSportFilter] = useState('all');
const [dynamicRoles, setDynamicRoles] = useState({});
const [rolesLoaded, setRolesLoaded] = useState(false);
const [viewMode, setViewMode] = useState('leads'); // 'leads' or 'clients'
const [clients, setClients] = useState([]);
const [clientsLoading, setClientsLoading] = useState(false);
const [selectedClient, setSelectedClient] = useState(null);
const [showClientDetail, setShowClientDetail] = useState(false);
const [phoneCheckLoading, setPhoneCheckLoading] = useState(false);
const [clientSuggestion, setClientSuggestion] = useState(null);
const [showClientSuggestion, setShowClientSuggestion] = useState(false);
const [phoneCheckTimeout, setPhoneCheckTimeout] = useState(null);
const [showStatusProgressModal, setShowStatusProgressModal] = useState(false);
const [statusProgressOptions, setStatusProgressOptions] = useState([]);
const [selectedStatus, setSelectedStatus] = useState('');
const [followUpDate, setFollowUpDate] = useState('');
const [followUpNotes, setFollowUpNotes] = useState('');
const [uploadPreview, setUploadPreview] = useState(null);
const [showPreview, setShowPreview] = useState(false);
const [proceedAfterPreview, setProceedAfterPreview] = useState(false);
const [previewLoading, setPreviewLoading] = useState(false);
const [clientDetectionResults, setClientDetectionResults] = useState([]);
const [showClientDetectionResults, setShowClientDetectionResults] = useState(false);
const [calendarFilters, setCalendarFilters] = React.useState({});
const [showImportModal, setShowImportModal] = React.useState(false);



// 1. Enhanced Customer Type Classification
const [paymentData, setPaymentData] = useState({
legal_name: '',
gstin: '',
registered_address: '',
category_of_sale: 'Corporate',
type_of_sale: 'Tour',
indian_state: 'Haryana',
is_outside_india: false,

// NEW: Enhanced customer classification
customer_type: 'indian', // 'indian', 'nri', 'foreigner'
event_location: 'india', // 'india', 'outside_india'
payment_currency: 'INR', // 'INR', 'USD', 'EUR', 'GBP'

advance_amount: '',
payment_method: 'bank_transfer',
transaction_id: '',
payment_date: new Date().toISOString().split('T')[0],
payment_proof: '',
notes: '',
gst_certificate: '',
pan_card: '',

invoice_items: [
{
description: '',
additional_info: '',
quantity: 1,
rate: 0
}
],

service_fee_amount: '',
gst_rate: 5,

// NEW: TCS fields
tcs_applicable: false,
tcs_rate: 5, // Default to 5%
tcs_amount: 0,
tcs_rate_editable: true, // Allow manual override
});

const addInvoiceItem = () => {
const newItems = [...(paymentData.invoice_items || [])];
newItems.push({
description: '',
additional_info: '',
quantity: 1,
rate: 0
});
handlePaymentInputChange('invoice_items', newItems);
};



const removeInvoiceItem = (index) => {
if (paymentData.invoice_items.length <= 1) {
alert('At least one invoice item is required');
return;
}
const newItems = paymentData.invoice_items.filter((_, i) => i !== index);
handlePaymentInputChange('invoice_items', newItems);
};



// Fixed version for post-deployment input issues
const updateInvoiceItem = (index, field, value) => {
// Create a completely new array to ensure React detects the change
const newItems = JSON.parse(JSON.stringify(paymentData.invoice_items || []));
newItems[index][field] = value;

// Force a state update with new reference
setPaymentData(prevData => ({
...prevData,
invoice_items: newItems
}));
}; 

// Enhanced GST and TCS Calculation Function
const calculateGSTAndTCS = (baseAmount, paymentData) => {
const isIntraState = paymentData.indian_state === 'Haryana' && !paymentData.is_outside_india;
const isOutsideIndia = paymentData.event_location === 'outside_india';
const isIndian = paymentData.customer_type === 'indian';
const isNRIOrForeigner = ['nri', 'foreigner'].includes(paymentData.customer_type);
const isINRPayment = paymentData.payment_currency === 'INR';
const isCorporate = paymentData.category_of_sale === 'Corporate';
const isServiceFee = paymentData.type_of_sale === 'Service Fee';

let gstApplicable = false;
let gstRate = 0;
let tcsApplicable = false;
let tcsRate = paymentData.tcs_rate || 5; // Standard TCS rate

// TCS Logic: CORRECTED
if (isOutsideIndia) {
// Event outside India
if (isIndian) {
// All Indian clients pay TCS for events outside India
tcsApplicable = true;
} else if (isNRIOrForeigner && isINRPayment) {
// NRI/Foreigner pay TCS only if they pay in INR
tcsApplicable = true;
}
}
// If event is in India, NO ONE pays TCS

// GST Logic: CORRECTED with Service Fee handling
if (isServiceFee) {
// Service Fee: Always 18% GST regardless of customer type or location
gstApplicable = true;
gstRate = 18;
} else {
// Tour Package: Variable rates based on customer type and location
if (isIndian) {
// Domestic clients (Indian)
if (isCorporate) {
// B2B: Always 18% regardless of event location
gstApplicable = true;
gstRate = 18;
} else {
// B2C: Always 5% regardless of event location  
gstApplicable = true;
gstRate = 5;
}
} else if (isNRIOrForeigner) {
// International clients (NRI/Foreigner)
if (!isOutsideIndia) {
// Event in India: Always 5% GST for international clients
gstApplicable = true;
gstRate = 5;
} else {
// Event outside India
if (isINRPayment) {
// Pay in INR: 5% GST
gstApplicable = true;
gstRate = 5;
} else {
// Pay in foreign currency: No GST
gstApplicable = false;
}
}
}
}

// Calculate amounts
const gstAmount = gstApplicable ? (baseAmount * gstRate) / 100 : 0;
const cgstAmount = gstApplicable && isIntraState ? gstAmount / 2 : 0;
const sgstAmount = gstApplicable && isIntraState ? gstAmount / 2 : 0;
const igstAmount = gstApplicable && !isIntraState ? gstAmount : 0;

const tcsAmount = tcsApplicable ? (baseAmount * tcsRate) / 100 : 0;

return {
gst: {
applicable: gstApplicable,
rate: gstRate,
cgst: cgstAmount,
sgst: sgstAmount,
igst: igstAmount,
total: gstAmount
},
tcs: {
applicable: tcsApplicable,
rate: tcsRate,
amount: tcsAmount
},
finalAmount: baseAmount + gstAmount + tcsAmount
};


};



const formatCurrency = (amount) => {
return amount.toLocaleString('en-IN', {
minimumFractionDigits: 2,
maximumFractionDigits: 2
});
};



// Safe number formatting helper
const safeFormatNumber = (value) => {
const num = parseFloat(value) || 0;
return num.toLocaleString('en-IN');
};



const handlePaymentInputChange = (field, value) => {
  setPaymentData(prev => {
    const updated = { ...prev, [field]: value };
    
    // Auto-update GST rate based on type_of_sale
    if (field === 'type_of_sale') {
      if (value === 'Service Fee') {
        updated.gst_rate = 18;
      } else if (value === 'Tour') {
        updated.gst_rate = 5;
      } else {
        updated.gst_rate = 18;
      }
    }
    
    // Handle TCS rate changes manually
    if (field === 'tcs_rate') {
      const baseAmount = window.getBaseAmount(updated);
      const newTcsAmount = updated.tcs_applicable ? (baseAmount * parseFloat(value)) / 100 : 0;
      updated.tcs_amount = newTcsAmount;
      // Mark that rate was manually selected
      updated.tcs_rate_manual = true;
    }
    
    // Auto-determine TCS applicability when customer type or currency changes
    if (['customer_type', 'event_location', 'payment_currency'].includes(field)) {
      const baseAmount = window.getBaseAmount(updated);
      const calculation = calculateGSTAndTCS(baseAmount, updated);
      updated.tcs_applicable = calculation.tcs.applicable;
      
      // Only update TCS rate if it wasn't manually set, or if customer type changed
      if (!updated.tcs_rate_manual || field === 'customer_type') {
        updated.tcs_rate = calculation.tcs.rate;
        updated.tcs_rate_manual = false; // Reset manual flag when customer type changes
      }
      
      // Recalculate TCS amount with current (possibly manual) rate
      const currentTcsRate = updated.tcs_rate || calculation.tcs.rate;
      updated.tcs_amount = calculation.tcs.applicable ? (baseAmount * currentTcsRate) / 100 : 0;
    }
    
    // Recalculate TCS when invoice items or service fee amount changes
    if (['invoice_items', 'service_fee_amount'].includes(field)) {
      const baseAmount = window.getBaseAmount(updated);
      if (updated.tcs_applicable) {
        const currentTcsRate = updated.tcs_rate || 5;
        updated.tcs_amount = (baseAmount * currentTcsRate) / 100;
      }
    }
    
    return updated;
  });
};



// Edit order function - in App scope
const openEditOrderForm = (order) => {
if (!order) {
alert('Order data not found');
return;
}

if (!window.hasPermission('orders', 'write')) {
alert('You do not have permission to edit orders');
return;
}

setCurrentOrderForEdit(order);
setOrderEditData({
...order,
status: order.status || 'pending_approval',
rejection_reason: order.rejection_reason || '',
assigned_to: order.assigned_to || ''
});
setShowEditOrderForm(true);
};




const handleBulkAssignSubmit = async () => {
if (Object.keys(bulkAssignSelections).length === 0) {
alert('Please select at least one lead to assign.');
return;
}

setBulkAssignLoading(true);
let successCount = 0;
let errorCount = 0;

try {
for (const [leadId, assigneeEmail] of Object.entries(bulkAssignSelections)) {
try {
const response = await window.apicall(`/leads/${leadId}`, {
method: 'PUT',
body: JSON.stringify({
assigned_to: assigneeEmail,
status: 'assigned'
})
});

if (response.error) {
console.error(`Failed to assign lead ${leadId}:`, response.error);
errorCount++;
} else {
successCount++;
}
} catch (error) {
console.error(`Error assigning lead ${leadId}:`, error);
errorCount++;
}
}

alert(`Bulk assignment completed!\n‚úÖ ${successCount} leads assigned successfully\n‚ùå ${errorCount} failed`);

// FIXED: Use the correct function name to refresh leads data
// Try these in order - use whichever function name you have:
if (typeof fetchData === 'function') {
await fetchData(); // Most likely this one
} else if (typeof loadLeads === 'function') {
await loadLeads();
} else if (typeof refreshLeads === 'function') {
await refreshLeads();
} else if (typeof getData === 'function') {
await getData();
} else {
// If none of the above work, just reload the page
window.location.reload();
}

// Close modal and reset selections
setShowBulkAssignModal(false);
setBulkAssignSelections({});

} catch (error) {
console.error('Bulk assignment error:', error);
alert('Error during bulk assignment: ' + error.message);
} finally {
setBulkAssignLoading(false);
}
};



const fetchClients = async () => {
setClientsLoading(true);
try {
const response = await window.apicall('/clients');
setClients(response.data || []);
console.log(`Fetched ${response.data?.length || 0} clients`);
} catch (error) {
console.error('Failed to fetch clients:', error);
alert('Failed to load clients: ' + error.message);
} finally {
setClientsLoading(false);
}
};



const fetchUserRoles = async () => {
try {
const response = await window.apicall('/roles');
const roleMap = {};

// Convert API roles to permission format
response.data.forEach(role => {
roleMap[role.name] = {
label: role.label,
permissions: role.permissions
};


});

setDynamicRoles(roleMap);
setRolesLoaded(true);
} catch (error) {
console.error('Failed to fetch roles:', error);
// Fallback to hardcoded roles if API fails
setDynamicRoles(window.USER_ROLES);
setRolesLoaded(true);
}
};



const handleStatusFilterToggle = (status) => {
setSelectedStatusFilters(prev => {
if (prev.includes(status)) {
return prev.filter(s => s !== status);
} else {
return [...prev, status];
}
});
};



const handleSelectAllStatuses = () => {
if (selectedStatusFilters.length === Object.keys(window.LEAD_STATUSES).length) {
setSelectedStatusFilters([]);
} else {
setSelectedStatusFilters(Object.keys(window.LEAD_STATUSES));
}
};



// Add this function for checking phone numbers
const checkPhoneForClient = async (phone) => {
if (!phone || phone.length < 10) {
setClientSuggestion(null);
setShowClientSuggestion(false);
return;
}

// Normalize phone number (remove spaces, +91, etc.)
const normalizedPhone = phone.replace(/[\s\-\+]/g, '').replace(/^91/, '');

if (normalizedPhone.length < 10) {
setClientSuggestion(null);
setShowClientSuggestion(false);
return;
}

setPhoneCheckLoading(true);
try {
const response = await window.apicall(`/leads/check-phone/${normalizedPhone}`);
if (response.exists && response.suggestion) {
setClientSuggestion(response.suggestion);
setShowClientSuggestion(true);
} else {
setClientSuggestion(null);
setShowClientSuggestion(false);
}
} catch (error) {
console.error('Error checking phone:', error);
setClientSuggestion(null);
setShowClientSuggestion(false);
} finally {
setPhoneCheckLoading(false);
}
};



// Add this function to handle phone input changes with debouncing
const handlePhoneChange = (value) => {
setLeadFormData(prev => ({ ...prev, phone: value }));

// Clear existing timeout
if (phoneCheckTimeout) {
clearTimeout(phoneCheckTimeout);
}

// Set new timeout for phone check (debounce)
const newTimeout = setTimeout(() => {
checkPhoneForClient(value);
}, 500); // Check after 500ms of no typing

setPhoneCheckTimeout(newTimeout);
};



// Add this function to apply client suggestions
const applyClientSuggestion = () => {
if (clientSuggestion) {
setLeadFormData(prev => ({
...prev,
assigned_to: clientSuggestion.suggested_assigned_to,
company: clientSuggestion.client_history[0]?.company || prev.company,
city_of_residence: clientSuggestion.client_history[0]?.city_of_residence || prev.city_of_residence,
country_of_residence: clientSuggestion.client_history[0]?.country_of_residence || prev.country_of_residence,
business_type: clientSuggestion.client_history[0]?.business_type || prev.business_type,
annual_income_bracket: clientSuggestion.client_history[0]?.annual_income_bracket || prev.annual_income_bracket
}));
setShowClientSuggestion(false);
alert('Client information applied! This lead will be linked to the existing client.');
}
};



const handleClearAllStatuses = () => {
setSelectedStatusFilters([]);
};



const getStatusFilterDisplayText = () => {
if (selectedStatusFilters.length === 0) {
return 'All Statuses';
} else if (selectedStatusFilters.length === 1) {
return window.LEAD_STATUSES[selectedStatusFilters[0]].label;
} else if (selectedStatusFilters.length === Object.keys(window.LEAD_STATUSES).length) {
return 'All Statuses';
} else {
return `${selectedStatusFilters.length} statuses selected`;
}
}; 

// Form helpers
const openStadiumForm = (stadium = null) => {
setEditingStadium(stadium);
setStadiumFormData(stadium || {});
setShowStadiumForm(true);
};



const closeStadiumForm = () => {
setShowStadiumForm(false);
setEditingStadium(null);
setStadiumFormData({});
};



const handleStadiumInputChange = (name, value) => {
setStadiumFormData(prev => ({
...prev,
[name]: value
}));
};




const updateOrderStatus = async (orderId, newStatus, rejectionReason = '') => {
setLoading(true);
try {
const updateData = {
status: newStatus,
updated_date: new Date().toISOString(),
updated_by: user.name
};



// Add specific fields based on status
if (newStatus === 'rejected' && rejectionReason) {
updateData.rejection_reason = rejectionReason;
updateData.rejected_date = new Date().toISOString();
updateData.rejected_by = user.name;
} else if (newStatus === 'approved') {
updateData.approved_date = new Date().toISOString();
updateData.approved_by = user.name;

// Generate invoice if needed
const order = orders.find(o => o.id === orderId);
if (order && (order.requires_gst_invoice || order.gstin)) {
const invoiceNumber = 'STTS/INV/' + (new Date().getFullYear()) + '/' + (String(Date.now()).slice(-6));
updateData.invoice_number = invoiceNumber;
updateData.invoice_id = Date.now();
}
} else if (newStatus === 'pending_approval') {
// Clear rejection/approval data when moving back to pending
updateData.rejection_reason = null;
updateData.rejected_date = null;
updateData.rejected_by = null;
updateData.approved_date = null;
updateData.approved_by = null;
}

// Update in backend
await window.apicall('/orders/' + (orderId), {
method: 'PUT',
body: JSON.stringify(updateData)
});

// Update local state
setOrders(prev => 
prev.map(order => 
order.id === orderId 
? { ...order, ...updateData }
: order
)
);

alert('Order status updated to: ' + (newStatus));
} catch (error) {
console.error('Error updating order status:', error);
alert('Failed to update order status');
} finally {
setLoading(false);
}
}

const [invoices, setInvoices] = useState([]);
const [deliveries, setDeliveries] = useState([]);
const [receivables, setReceivables] = useState([]);
const [emailNotifications, setEmailNotifications] = useState([]);
const [allUsers, setAllUsers] = useState([]);
const [users, setUsers] = useState([]);
const [myLeads, setMyLeads] = useState([]);
const [myQuoteRequested, setMyQuoteRequested] = useState([]);
const [myOrders, setMyOrders] = useState([]);
const [myDeliveries, setMyDeliveries] = useState([]);
const [myReceivables, setMyReceivables] = useState([]);

// Add data fetching function
const fetchData = async () => {
if (!isLoggedIn || !authToken) return;

try {
const [leadsData, inventoryData, ordersData, invoicesData, deliveriesData, clientsData] = await Promise.all([
window.apicall('/leads').catch(() => ({ data: [] })),
window.apicall('/inventory').catch(() => ({ data: [] })),
window.apicall('/orders').catch(() => ({ data: [] })),
window.apicall('/invoices').catch(() => ({ data: [] })),
window.apicall('/deliveries').catch(() => ({ data: [] })),
window.apicall('/clients').catch(() => ({ data: [] }))
]);

setLeads(leadsData.data || []);
setInventory(inventoryData.data || []);
setOrders(ordersData.data || []);
setInvoices(invoicesData.data || []);
setDeliveries(deliveriesData.data || []);
setClients(clientsData.data || []);
} catch (error) {
console.error('Error fetching data:', error);
}
};



// Fetch data when logged in
useEffect(() => {
if (isLoggedIn) {
fetchData();
}


// Fetch My Actions data
console.log('useEffect triggered - activeTab:', activeTab, 'isLoggedIn:', isLoggedIn);
if (activeTab === 'myactions') {
} else if (activeTab === 'finance') {
console.log('Finance tab active, fetching financial data...');
fetchFinancialData();
console.log('My Actions tab is active, calling fetchMyActions...');
fetchMyActions();
}
}, [isLoggedIn, activeTab]);

useEffect(() => {
if (isLoggedIn) {
fetchReminders();
// Set up auto-refresh every 5 minutes
const interval = setInterval(fetchReminders, 5 * 60 * 1000);
return () => clearInterval(interval);
}
}, [isLoggedIn]);


useEffect(() => {
if (viewMode === 'clients' && isLoggedIn) {
fetchClients();
}
}, [viewMode, isLoggedIn]);




// Add after other state variables

const [searchQuery, setSearchQuery] = useState('');
const [statusFilter, setStatusFilter] = useState('all');
// Google Cloud Storage Integration
// Google Cloud Storage Integration


const [showOrderDetail, setShowOrderDetail] = useState(false);
const [selectedOrderForAssignment, setSelectedOrderForAssignment] = useState(null);
const [showOrderAssignmentModal, setShowOrderAssignmentModal] = useState(false);
const [showEditOrderForm, setShowEditOrderForm] = useState(false);
const [currentOrderForEdit, setCurrentOrderForEdit] = useState(null);
const [orderEditData, setOrderEditData] = useState({});
const [inventoryDueDateFilter, setInventoryDueDateFilter] = useState('all');
const [inventoryEventFilter, setInventoryEventFilter] = useState('all');
const [currentLeadsPage, setCurrentLeadsPage] = useState(1);
const [currentInventoryPage, setCurrentInventoryPage] = useState(1);
const [itemsPerPage] = useState(10);
const [currentOrderDetail, setCurrentOrderDetail] = useState(null);

// Form states
const [showAddForm, setShowAddForm] = useState(false);
const [showEditForm, setShowEditForm] = useState(false);
const [showAssignForm, setShowAssignForm] = useState(false);
const [showPaymentForm, setShowPaymentForm] = useState(false);
const [showLeadDetail, setShowLeadDetail] = useState(false);
const [showAllocationForm, setShowAllocationForm] = useState(false);
const [showEditInventoryForm, setShowEditInventoryForm] = useState(false);
const [showUserManagement, setShowUserManagement] = useState(false);
const [showUserForm, setShowUserForm] = useState(false);
const [roles, setRoles] = useState([]);
const [showRoleForm, setShowRoleForm] = useState(false);
const [rolesInitialized, setRolesInitialized] = useState(false);

// Financials state
const [financialData, setFinancialData] = useState({
activeSales: [],
sales: [],
receivables: [],
payables: [],
expiringInventory: []
});
const [financialFilters, setFinancialFilters] = useState({
clientName: '',
assignedPerson: '',
dateFrom: '',
dateTo: '',
status: 'all',
expiringDays: 7,
clientName: '',
assignedPerson: '',
dateFrom: '',
dateTo: '',
status: 'all'
});
const [activeFinancialTab, setActiveFinancialTab] = useState('sales');
const [financialStats, setFinancialStats] = useState({
totalSales: 0,
totalReceivables: 0,
totalPayables: 0,
expiringValue: 0
});
const [editingRole, setEditingRole] = useState(null);
const [roleFormData, setRoleFormData] = useState({
name: '',
label: '',
description: '',
permissions: {
dashboard: { read: false, write: false, delete: false, manage_users: false },
leads: { read: false, write: false, delete: false, assign: false, progress: false },
inventory: { read: false, write: false, delete: false, allocate: false },
orders: { read: false, write: false, delete: false, approve: false, assign: false },
finance: { read: false, write: false, delete: false, approve: false },
delivery: { read: false, write: false, delete: false },
users: { read: false, write: false, delete: false, manage_roles: false }
}
});
const [editingUser, setEditingUser] = useState(null);
const [showCSVUploadModal, setShowCSVUploadModal] = useState(false);
const [availableRoles, setAvailableRoles] = useState([]);
const [csvUploadType, setCSVUploadType] = useState('');
const [currentForm, setCurrentForm] = useState('');
const [currentLead, setCurrentLead] = useState(null);
const [currentInventory, setCurrentInventory] = useState(null);
const [darkMode, setDarkMode] = useState(() => {
return localStorage.getItem('crm_dark_mode') === 'true';
});
const [currentUser, setCurrentUser] = useState(null);
const [formData, setFormData] = useState({});
const [allocationData, setAllocationData] = useState({});
const [userFormData, setUserFormData] = useState({});
const [showInvoicePreview, setShowInvoicePreview] = useState(false);
const [currentInvoice, setCurrentInvoice] = useState(null);
const [showDeliveryForm, setShowDeliveryForm] = useState(false);
const [currentDelivery, setCurrentDelivery] = useState(null);
const [deliveryFormData, setDeliveryFormData] = useState({});
const [showPaymentPostServiceForm, setShowPaymentPostServiceForm] = useState(false);
const [showHelpGuide, setShowHelpGuide] = useState(false);
const [paymentPostServiceData, setPaymentPostServiceData] = useState({});
const [showChoiceModal, setShowChoiceModal] = useState(false);
const [currentLeadForChoice, setCurrentLeadForChoice] = useState(null);
const [choiceOptions, setChoiceOptions] = useState([]);


// Dashboard stats
const [dashboardStats, setDashboardStats] = useState({
totalLeads: 0,
activeDeals: 0,
thisMonthRevenue: 0,
pendingDeliveries: 0,
inventoryValue: 0
});

// Dashboard filter states for pie charts
const [dashboardFilter, setDashboardFilter] = useState('overall');
const [selectedSalesPerson, setSelectedSalesPerson] = useState('');
const [selectedEvent, setSelectedEvent] = useState('');
const [events, setEvents] = useState([]);
const [salesPeople, setSalesPeople] = useState([]);
const [chartInstances, setChartInstances] = useState({
leadSplit: null,
tempCount: null,
tempValue: null
});


// Permission check function
// Updated Permission check function with dynamic roles
window.hasPermission = function(module, action) {
if (user?.role === 'super_admin') return true;
if (!user || !user.role) {
console.log('No user or role found');
return false;
}

// Use dynamic roles if loaded, otherwise fallback to hardcoded
const availableRoles = rolesLoaded ? dynamicRoles : window.USER_ROLES;
const userRole = availableRoles[user.role];

if (!userRole) {
console.log('Role not found in available roles:', user.role);
console.log('Available roles:', Object.keys(availableRoles));
return false;
}

const modulePermissions = userRole.permissions[module];
if (!modulePermissions) {
console.log('Module permissions not found:', module);
return false;
}

const hasAccess = modulePermissions[action] === true;
console.log(`Permission check: ${user.role} -> ${module}.${action} = ${hasAccess}`);
return hasAccess;
};



const canAccessTab = (tabId) => {
if (!user) return false;
// My Actions is available to all logged-in users
if (tabId === 'myactions') return true;
// Reminders available to users who can read leads
if (tabId === 'reminders') return window.hasPermission('leads', 'read');
// Sports Calendar available to users who can read leads (for now, or adjust as needed)
if (tabId === 'sports-calendar') return window.hasPermission('leads', 'read');
return window.hasPermission(tabId, 'read');
};




// Test mode logging
useEffect(() => {
console.log('Test mode state:', testMode);
console.log('Current user:', currentUser);
console.log('Is super admin:', currentUser?.role === 'super_admin');
console.log('User object:', JSON.stringify(currentUser));

// Force re-render when user changes
if (currentUser && currentUser.role === 'super_admin') {
console.log('Super admin logged in - test mode toggle should be visible');
}
}, [testMode, currentUser]);

React.useEffect(() => {
if (isLoggedIn) {
fetchData();
fetchStadiums(); // Add this line
}
}, [isLoggedIn]); 

// Persist authentication state
useEffect(() => {
try {
const savedUser = localStorage.getItem('crm_user');
const savedLoginState = localStorage.getItem('crm_auth_token');

if (savedUser && savedLoginState) {
const userData = JSON.parse(savedUser);
setUser(userData);
setCurrentUser(userData);
authToken = savedLoginState;
setIsLoggedIn(true);
// Fetch users for dropdowns
fetchUsers();
// Clear any cached user management data
setUsers([]);
}
} catch (e) {
console.log('Failed to restore auth state:', e);
}
}, []);

useEffect(() => {
localStorage.setItem('crm_active_tab', activeTab);
}, [activeTab]);


// Calculate dashboard stats
// Initialize dashboard stats
useEffect(() => {
if (isLoggedIn) {
calculateDashboardStats();
}
}, [isLoggedIn]);

useEffect(() => {
const handleClickOutside = (event) => {
if (statusDropdownRef.current && !statusDropdownRef.current.contains(event.target)) {
setShowStatusFilterDropdown(false);
}
};


document.addEventListener('mousedown', handleClickOutside);
return () => document.removeEventListener('mousedown', handleClickOutside);
}, []);

// Add useEffect to extract filter data when leads or users change
useEffect(() => {
if (leads.length > 0 || users.length > 0) {
extractFiltersData();
}
}, [leads, users]);

const getFilteredLeads = () => {
let filteredLeads = [...leads];

if (dashboardFilter === 'salesperson' && selectedSalesPerson) {
filteredLeads = filteredLeads.filter(lead => lead.assigned_to === selectedSalesPerson);
}

if (dashboardFilter === 'event' && selectedEvent) {
filteredLeads = filteredLeads.filter(lead => lead.lead_for_event === selectedEvent);
}

return filteredLeads;
};    

// Update stats when filter changes
useEffect(() => {
if (leads.length > 0) {
calculateDashboardStats();
}
}, [dashboardFilter, selectedSalesPerson, selectedEvent, leads]);

useEffect(() => {
console.log('Chart initialization useEffect triggered', {
activeTab,
leadsCount: leads.length,
chartExists: typeof Chart !== 'undefined'
});

if (activeTab === 'dashboard' && leads.length > 0 && typeof Chart !== 'undefined') {
// Wait a bit longer for DOM to be ready and add additional checks
const timeoutId = setTimeout(() => {
console.log('Attempting to initialize charts...');

// Check if canvas elements exist
const canvas1 = document.getElementById('leadSplitChart');
const canvas2 = document.getElementById('tempCountChart');  
const canvas3 = document.getElementById('tempValueChart');

console.log('Canvas elements found:', {
leadSplit: !!canvas1,
tempCount: !!canvas2,
tempValue: !!canvas3
});

if (canvas1 && canvas2 && canvas3) {
initializeChartsAdvanced();

// Then update with current data
setTimeout(() => {
const filteredLeads = getFilteredLeads();
updateCharts(filteredLeads);
}, 100);
} else {
console.log('Canvas elements not ready yet, retrying...');
// Retry after another delay
setTimeout(() => {
initializeChartsAdvanced();
const filteredLeads = getFilteredLeads();
updateCharts(filteredLeads);
}, 500);
}
}, 200); // Increased delay

return () => clearTimeout(timeoutId);
}

// Cleanup when leaving dashboard
if (activeTab !== 'dashboard') {
if (chartInstances.leadSplit) {
chartInstances.leadSplit.destroy();
chartInstances.leadSplit = null;
}
if (chartInstances.tempCount) {
chartInstances.tempCount.destroy();
chartInstances.tempCount = null;
}
if (chartInstances.tempValue) {
chartInstances.tempValue.destroy();
chartInstances.tempValue = null;
}
}
}, [activeTab, leads.length]); // Include leads.length to ensure data is available


// Add useEffect to update stats when filter changes
useEffect(() => {
if (leads.length > 0) {
calculateDashboardStats();
}
}, [dashboardFilter, selectedSalesPerson, selectedEvent]);

// Apply dark mode on mount
useEffect(() => {
if (darkMode) {
document.documentElement.classList.add('dark');
} else {
document.documentElement.classList.remove('dark');
}
}, [darkMode]);
// Chart initialization
useEffect(() => {
if (isLoggedIn && window.hasPermission('finance', 'read')) {
const chartElement = document.getElementById('receivablesPieChart');
if (chartElement && receivables.filter(r => r.status === 'pending').length > 0) {
const ctx = chartElement.getContext('2d');

// Destroy existing chart if any
if (window.receivablesChart) {
window.receivablesChart.destroy();
}

// Group receivables by salesperson
const receivablesBySalesperson = {};
receivables
.filter(r => r.status === 'pending')
.forEach(receivable => {
const salesperson = receivable.assigned_to || 'Unassigned';
receivablesBySalesperson[salesperson] = (receivablesBySalesperson[salesperson] || 0) + receivable.expected_amount;
});

window.receivablesChart = new Chart(ctx, {
type: 'pie',
data: {
labels: Object.keys(receivablesBySalesperson),
datasets: [{
data: Object.values(receivablesBySalesperson),
backgroundColor: [
'#3B82F6', '#EF4444', '#10B981', '#F59E0B', 
'#8B5CF6', '#EC4899', '#14B8A6', '#F97316'
]
}]
},
options: {
responsive: true,
maintainAspectRatio: false
}
});
}
}
}, [isLoggedIn, receivables, user]);
// Add this useEffect to handle scheduled notifications
useEffect(() => {
const checkScheduledNotifications = () => {
const now = new Date();
emailNotifications
.filter(n => n.status === 'scheduled' && new Date(n.scheduled_date) <= now)
.forEach(notification => {
sendEmailNotification(notification);
});
};



const interval = setInterval(checkScheduledNotifications, 60000); // Check every minute
return () => clearInterval(interval);
}, [emailNotifications]);

// ADD this new useEffect after your existing ones:
useEffect(() => {
if (users.length === 0) {
setUsers(window.DEFAULT_USERS);
}
}, []);
// Fetch all users on app initialization
useEffect(() => {
if (isLoggedIn && allUsers.length === 0) {
fetchUsers();
}
}, [isLoggedIn]);


useEffect(() => {
try {
localStorage.setItem('crm_deliveries', JSON.stringify(deliveries));
} catch (e) {
console.log('Failed to save deliveries:', e);
}
}, [deliveries]);

useEffect(() => {
try {
localStorage.setItem('crm_receivables', JSON.stringify(receivables));
} catch (e) {
console.log('Failed to save receivables:', e);
}
}, [receivables]);

useEffect(() => {
try {
localStorage.setItem('crm_email_notifications', JSON.stringify(emailNotifications));
} catch (e) {
console.log('Failed to save notifications:', e);
}
}, [emailNotifications]);


const assignOrderToService = async (orderId, assignee) => {

const openEditOrderForm = (order) => {
alert(`Edit Order: ${order.order_number}

Client: ${order.client_name}
Email: ${order.client_email}
Event: ${order.event_name || 'N/A'}
Tickets: ${order.tickets_allocated || 0}
Amount: ‚Çπ${order.total_amount || 0}

Status: ${order.status}`);
};


setLoading(true);
try {
const updateData = {
assigned_to: assignee, // This will now be an email
status: 'service_assigned',
assigned_date: new Date().toISOString()
};



await window.apicall('/orders/' + (orderId), {
method: 'PUT',
body: JSON.stringify(updateData)
});

setOrders(prev => 
prev.map(order => 
order.id === orderId 
? { ...order, ...updateData }
: order
)
);

const openOrderForm = () => {
setShowOrderForm(true);
// Initialize any form data if needed
};



// Create delivery entry when assigning to supply team
const order = orders.find(o => o.id === orderId);
if (order) {
const newDelivery = {
// id will be generated by Firestore
order_id: orderId,
order_number: order.order_number,
client_name: order.client_name,
client_email: order.client_email,
client_phone: order.client_phone,
event_name: order.event_name || 'N/A',
event_date: order.event_date || new Date().toISOString().split('T')[0],
tickets_count: order.tickets_allocated || 0,
amount: order.total_amount || 0,

// Delivery form fields
delivery_type: 'offline',
pickup_location: '',
pickup_date: '',
pickup_time: '',
delivery_location: order.delivery_address || order.client_address || '',
delivery_date: '',
delivery_time: '',
delivery_person: assignee,
delivery_notes: '',
online_platform: '',
online_link: '',

// Status and metadata
assigned_to: assignee, // This will now be an email
status: 'pending',
created_date: new Date().toISOString().split('T')[0],
created_by: user.name
};



// Add to deliveries state
setDeliveries(prev => [...prev, newDelivery]);

console.log('Delivery entry created:', newDelivery);

// Save delivery to backend
try {
const deliveryResponse = await window.apicall('/deliveries', {
method: 'POST',
body: JSON.stringify(newDelivery)
});
console.log('Delivery saved to backend:', deliveryResponse);
// Update local state with backend response if it has an ID
if (deliveryResponse && deliveryResponse.data && deliveryResponse.data.id) {
setDeliveries(prev => prev.map(d => 
d.id === newDelivery.id ? { ...d, id: deliveryResponse.data.id } : d
));
}
} catch (error) {
console.error('Failed to save delivery to backend:', error);
}
}

alert('Order assigned to ' + (assignee) + ' successfully!');
} catch (error) {
console.error('Error assigning order:', error);
alert('Failed to assign order');
} finally {
setLoading(false);
}
};



const fetchReminders = async () => {
if (!isLoggedIn) return;

try {
const response = await window.apicall('/reminders');
if (response.data) {
const userReminders = response.data.filter(r => 
r.assigned_to === user.email || 
['sales_manager', 'admin', 'super_admin'].includes(user.role)
);

setReminders(userReminders);

// Calculate stats
const now = new Date();
const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

const stats = {
total: userReminders.length,
overdue: userReminders.filter(r => new Date(r.due_date) < now && r.status === 'pending').length,
due_today: userReminders.filter(r => {
const dueDate = new Date(r.due_date);
return dueDate >= today && dueDate < new Date(today.getTime() + 24*60*60*1000) && r.status === 'pending';
}).length,
pending: userReminders.filter(r => r.status === 'pending').length
};



setReminderStats(stats);
}
} catch (error) {
console.error('Error fetching reminders:', error);
}
};



// Complete a reminder
const completeReminder = async (reminderId, notes = '') => {
try {
await window.apicall(`/reminders/${reminderId}/complete`, {
method: 'POST',
body: JSON.stringify({ notes })
});

setReminders(prev => prev.map(r => 
r.id === reminderId 
? { ...r, status: 'completed', completed_date: new Date().toISOString() }
: r
));

alert('‚úÖ Reminder completed successfully!');
await fetchReminders();
} catch (error) {
console.error('Error completing reminder:', error);
alert('‚ùå Failed to complete reminder');
}
};



// Snooze a reminder
const snoozeReminder = async (reminderId, hours = 24) => {
try {
const snoozeUntil = new Date();
snoozeUntil.setHours(snoozeUntil.getHours() + hours);

await window.apicall(`/reminders/${reminderId}/snooze`, {
method: 'POST',
body: JSON.stringify({ snooze_until: snoozeUntil.toISOString() })
});

alert(`‚è∞ Reminder snoozed for ${hours} hours`);
await fetchReminders();
} catch (error) {
console.error('Error snoozing reminder:', error);
alert('‚ùå Failed to snooze reminder');
}
};



const deleteReminder = async (reminderId) => {
// Confirm before deleting
if (!confirm('Are you sure you want to delete this reminder? This action cannot be undone.')) {
return;
}

try {
await window.apicall(`/reminders/${reminderId}`, {
method: 'DELETE'
});

// Update local state to remove the deleted reminder
setReminders(prevReminders => 
prevReminders.filter(r => r.id !== reminderId)
);

// Update reminder stats
await fetchReminders();

alert('üóëÔ∏è Reminder deleted successfully!');
} catch (error) {
console.error('Error deleting reminder:', error);
alert('‚ùå Failed to delete reminder: ' + error.message);
}
}; 

// Helper functions
const formatRelativeTime = (dateString) => {
const date = new Date(dateString);
const now = new Date();
const diffMs = date - now;
const diffHours = Math.round(diffMs / (1000 * 60 * 60));
const diffDays = Math.round(diffMs / (1000 * 60 * 60 * 24));

if (diffMs < 0) {
const pastHours = Math.abs(diffHours);
const pastDays = Math.abs(diffDays);

if (pastDays > 0) {
return `${pastDays} day${pastDays > 1 ? 's' : ''} overdue`;
} else {
return `${pastHours} hour${pastHours > 1 ? 's' : ''} overdue`;
}
} else {
if (diffDays > 0) {
return `in ${diffDays} day${diffDays > 1 ? 's' : ''}`;
} else if (diffHours > 0) {
return `in ${diffHours} hour${diffHours > 1 ? 's' : ''}`;
} else {
return 'now';
}
}
};



const getPriorityColor = (priority) => {
switch (priority) {
case 'urgent': return 'text-red-600 bg-red-100';
case 'high': return 'text-orange-600 bg-orange-100';
case 'medium': return 'text-blue-600 bg-blue-100';
case 'low': return 'text-gray-600 bg-gray-100';
default: return 'text-gray-600 bg-gray-100';
}
};



const openOrderDetail = (order) => {
setCurrentOrderDetail(order);
setShowOrderDetail(true);
};

const renderOrderAssignmentModal = () => {
if (!showOrderAssignmentModal || !selectedOrderForAssignment) return null;

const supplyTeamUsers = (users || []).filter(u => 
['supply_executive', 'supply_sales_service_manager'].includes(u.role)
);

return React.createElement('div', { 
className: 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50',
onClick: (e) => {
if (e.target === e.currentTarget) {
setShowOrderAssignmentModal(false);
setSelectedOrderForAssignment(null);
}
}
},
React.createElement('div', { className: 'bg-white dark:bg-gray-800 rounded-lg p-6 max-w-md w-full' },
React.createElement('h3', { className: 'text-lg font-semibold mb-4' }, 
'Assign Order to Supply Team'
),
React.createElement('div', { className: 'space-y-2' },
supplyTeamUsers.map(user =>
React.createElement('button', {
key: user.email,
className: 'w-full text-left px-4 py-2 rounded hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors',
onClick: () => {
assignOrderToService(selectedOrderForAssignment.id, user.email);
setShowOrderAssignmentModal(false);
setSelectedOrderForAssignment(null);
}
},
React.createElement('div', { className: 'font-medium' }, user.name),
React.createElement('div', { className: 'text-sm text-gray-500' }, user.role)
)
)
),
React.createElement('button', {
className: 'mt-4 w-full text-center text-gray-500 hover:text-gray-700',
onClick: () => {
setShowOrderAssignmentModal(false);
setSelectedOrderForAssignment(null);
}
}, 'Cancel')
)
);
};


;

const getInventoryDueInDays = (eventDate) => {
const today = new Date();
const event = new Date(eventDate);
const diffTime = event - today;
const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
return diffDays;
};




const calculateDashboardStats = () => {
let filteredLeads = leads;

// Apply filters
if (dashboardFilter === 'salesPerson' && selectedSalesPerson) {
filteredLeads = leads.filter(l => l.assigned_to === selectedSalesPerson);
} else if (dashboardFilter === 'event' && selectedEvent) {
filteredLeads = leads.filter(l => l.lead_for_event === selectedEvent);
}

const stats = {
totalLeads: filteredLeads.length,
activeDeals: filteredLeads.filter(l => ['hot', 'warm', 'qualified'].includes(l.status)).length,
thisMonthRevenue: 0,
pendingDeliveries: deliveries.filter(d => d.status === 'pending').length,
inventoryValue: inventory.reduce((sum, item) => sum + (item.price * item.quantity), 0)
};


setDashboardStats(stats);

// Update charts with filtered data
updateCharts(filteredLeads);
};



// HOW TO FIX THE DUPLICATE FUNCTION ERRORS

// The problem: You have these functions declared TWICE in your code:
// 1. extractFiltersData
// 2. updateCharts

// SOLUTION:

// Step 1: Use your text editor's search function (Ctrl+F or Cmd+F)
// Search for each of these function names:

// Search for: "const extractFiltersData"
// You'll find 2 occurrences - DELETE ONE OF THEM

// Search for: "const updateCharts" 
// You'll find 2 occurrences - DELETE ONE OF THEM

// Step 2: Make sure you keep only ONE instance of each function
// The functions should look like this (KEEP ONLY ONE OF EACH):

// ===== KEEP ONLY ONE extractFiltersData =====
const extractFiltersData = () => {
// Extract unique events from leads
const uniqueEvents = [...new Set(leads.map(l => l.lead_for_event).filter(e => e))];
setEvents(uniqueEvents);

// Extract sales people from users
const salesUsers = users.filter(u => 
u.role === 'sales_executive' || u.role === 'sales_manager'
);
setSalesPeople(salesUsers);
};



// ===== KEEP ONLY ONE updateCharts =====
const updateCharts = (filteredLeads) => {
console.log('Updating charts with', filteredLeads.length, 'leads');

// Lead Split Chart (Qualified vs Junk)
const qualifiedCount = filteredLeads.filter(l => l.status === 'qualified').length;
const junkCount = filteredLeads.filter(l => l.status === 'junk').length;
console.log('Lead Split:', { qualified: qualifiedCount, junk: junkCount });

// Temperature Count
// Temperature Count (including parallel stages)
const hotCount = filteredLeads.filter(l => getDisplayTemperature(l) === 'hot').length;
const warmCount = filteredLeads.filter(l => getDisplayTemperature(l) === 'warm').length;
const coldCount = filteredLeads.filter(l => getDisplayTemperature(l) === 'cold').length;
console.log('Temperature Count:', { hot: hotCount, warm: warmCount, cold: coldCount });

// Temperature Value
// Temperature Value (including parallel stages)
const hotValue = filteredLeads.filter(l => getDisplayTemperature(l) === 'hot')
.reduce((sum, l) => sum + (l.potential_value || 0), 0);
const warmValue = filteredLeads.filter(l => getDisplayTemperature(l) === 'warm')
.reduce((sum, l) => sum + (l.potential_value || 0), 0);
const coldValue = filteredLeads.filter(l => getDisplayTemperature(l) === 'cold')
.reduce((sum, l) => sum + (l.potential_value || 0), 0);
console.log('Temperature Value:', { hot: hotValue, warm: warmValue, cold: coldValue });

// Update charts if they exist
if (chartInstances.leadSplit) {
chartInstances.leadSplit.data.datasets[0].data = [qualifiedCount, junkCount];
chartInstances.leadSplit.update();
console.log('Lead Split chart updated');
} else {
console.log('Lead Split chart not found!');
}

if (chartInstances.tempCount) {
chartInstances.tempCount.data.datasets[0].data = [hotCount, warmCount, coldCount];
chartInstances.tempCount.update();
console.log('Temp Count chart updated');
} else {
console.log('Temp Count chart not found!');
}

if (chartInstances.tempValue) {
chartInstances.tempValue.data.datasets[0].data = [hotValue, warmValue, coldValue];
chartInstances.tempValue.update();
console.log('Temp Value chart updated');
} else {
console.log('Temp Value chart not found!');
}
};




// Function to initialize charts
const initializeChartsAdvanced = () => {
console.log('Initializing advanced charts...');

// Destroy existing charts first
Object.keys(chartInstances).forEach(key => {
if (chartInstances[key]) {
chartInstances[key].destroy();
chartInstances[key] = null;
}
});

// Lead Split Chart 
const ctx1 = document.getElementById('leadSplitChart');
if (ctx1) {
try {
chartInstances.leadSplit = new Chart(ctx1, {
type: 'pie',
data: {
labels: ['Qualified', 'Junk'],
datasets: [{
data: [0, 0],
backgroundColor: ['#10b981', '#ef4444'],
borderWidth: 2,
borderColor: '#ffffff'
}]
},
options: {
responsive: true,
maintainAspectRatio: false,
plugins: {
legend: {
position: 'bottom',
labels: {
padding: 15,
font: { size: 12, weight: 'bold' },
usePointStyle: true,
pointStyle: 'circle'
}
},
tooltip: {
backgroundColor: 'rgba(0, 0, 0, 0.8)',
titleColor: '#ffffff',
bodyColor: '#ffffff',
borderColor: '#ffffff',
borderWidth: 1,
cornerRadius: 8,
displayColors: true,
callbacks: {
title: function(context) {
return 'Lead Split Analysis';
},
label: function(context) {
const label = context.label || '';
const value = context.parsed || 0;
const total = context.dataset.data.reduce((a, b) => a + b, 0);
const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
return [
`Status: ${label}`,
`Count: ${value} leads`,
`Percentage: ${percentage}%`
];
}
}
}
}
}
});
} catch (error) {
console.error('Error creating advanced Lead Split chart:', error);
}
}

// Temperature Count Chart
const ctx2 = document.getElementById('tempCountChart');
if (ctx2) {
try {
chartInstances.tempCount = new Chart(ctx2, {
type: 'pie',
data: {
labels: ['Hot', 'Warm', 'Cold'],
datasets: [{
data: [0, 0, 0],
backgroundColor: ['#ef4444', '#f59e0b', '#3b82f6'],
borderWidth: 2,
borderColor: '#ffffff'
}]
},
options: {
responsive: true,
maintainAspectRatio: false,
plugins: {
legend: {
position: 'bottom',
labels: {
padding: 15,
font: { size: 12, weight: 'bold' },
usePointStyle: true,
pointStyle: 'circle'
}
},
tooltip: {
backgroundColor: 'rgba(0, 0, 0, 0.8)',
titleColor: '#ffffff',
bodyColor: '#ffffff',
borderColor: '#ffffff',
borderWidth: 1,
cornerRadius: 8,
displayColors: true,
callbacks: {
title: function(context) {
return 'Lead Temperature Count';
},
label: function(context) {
const label = context.label || '';
const value = context.parsed || 0;
const total = context.dataset.data.reduce((a, b) => a + b, 0);
const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
return [
`Temperature: ${label}`,
`Count: ${value} leads`,
`Percentage: ${percentage}%`
];
}
}
}
}
}
});
} catch (error) {
console.error('Error creating advanced Temp Count chart:', error);
}
}

// Temperature Value Chart
const ctx3 = document.getElementById('tempValueChart');
if (ctx3) {
try {
chartInstances.tempValue = new Chart(ctx3, {
type: 'pie',
data: {
labels: ['Hot', 'Warm', 'Cold'],
datasets: [{
data: [0, 0, 0],
backgroundColor: ['#ef4444', '#f59e0b', '#3b82f6'],
borderWidth: 2,
borderColor: '#ffffff'
}]
},
options: {
responsive: true,
maintainAspectRatio: false,
plugins: {
legend: {
position: 'bottom',
labels: {
padding: 15,
font: { size: 12, weight: 'bold' },
usePointStyle: true,
pointStyle: 'circle'
}
},
tooltip: {
backgroundColor: 'rgba(0, 0, 0, 0.8)',
titleColor: '#ffffff',
bodyColor: '#ffffff',
borderColor: '#ffffff',
borderWidth: 1,
cornerRadius: 8,
displayColors: true,
callbacks: {
title: function(context) {
return 'Lead Temperature Value';
},
label: function(context) {
const label = context.label || '';
const value = context.parsed || 0;
const total = context.dataset.data.reduce((a, b) => a + b, 0);
const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;

// Format value in Lacs with better formatting
let formattedValue;
if (value >= 10000000) { // 1 Crore
formattedValue = (value / 10000000).toFixed(2) + ' Cr';
} else if (value >= 100000) { // 1 Lac
formattedValue = (value / 100000).toFixed(2) + ' L';
} else if (value >= 1000) { // 1 Thousand
formattedValue = (value / 1000).toFixed(1) + ' K';
} else {
formattedValue = value.toString();
}

return [
`Temperature: ${label}`,
`Value: ‚Çπ${formattedValue}`,
`Percentage: ${percentage}%`
];
}
}
}
}
}
});
} catch (error) {
console.error('Error creating advanced Temp Value chart:', error);
}
}

console.log('Advanced chart initialization complete');
};



const formatValueInLacs = (value) => {
if (value >= 100000) {
return (value / 100000).toFixed(2) + 'L';
} else if (value >= 1000) {
return (value / 1000).toFixed(1) + 'K';
} else {
return value.toString();
}
};




// Authentication
const handleLogin = async (e) => {
debugLog('LOGIN_START', { email, timestamp: Date.now() });
e.preventDefault();
setLoading(true);

try {
const response = await window.apicall('/auth/login', {
method: 'POST',
body: JSON.stringify({ email, password })
});
debugLog('LOGIN_RESPONSE', { 
response, 
hasToken: response?.token !== undefined,
hasUser: response?.user !== undefined,
responseType: typeof response
});

console.log("Login response structure:", response);
console.log("Response type:", typeof response);
console.log("Has token?", response.token !== undefined);
console.log("Has user?", response.user !== undefined);
if (response.token && response.user) {
authToken = response.token;  // Update global authToken variable
localStorage.setItem('crm_auth_token', response.token);
localStorage.setItem('crm_user', JSON.stringify(response.user));
setUser(response.user);
debugLog('LOGIN_SUCCESS', { user: response.user });
setIsLoggedIn(true);
await fetchUserRoles();
// Clear any cached user management data
setUsers([]);
setEmail('');
setPassword('');
}
} catch (error) {
debugLog('LOGIN_ERROR', { error: error.message, stack: error.stack });
console.error("Login failed:", error.message || "Invalid credentials");
console.error("Full error:", error);
} finally {
setLoading(false);
}
};




const handleLogout = () => {
setIsLoggedIn(false);
setUser(null);
setCurrentUser(null);
setEmail('');
setPassword('');
setActiveTab('dashboard');
try {
localStorage.removeItem('crm_user');
localStorage.removeItem('crm_auth_token');
authToken = null;  // Clear the global authToken variable
authToken = null;  // Clear the global authToken variable
} catch (e) {
console.log('Failed to clear auth state:', e);
}
};



// User Management Functions
const openUserManagement = () => {
if (!window.hasPermission('users', 'read')) {
alert('You do not have permission to access user management');
return;
}
setShowUserManagement(true);
};



const openUserForm = (editUser = null) => {
if (editUser && !window.hasPermission('users', 'write')) {
alert('You do not have permission to edit users');
return;
}
if (!editUser && !window.hasPermission('users', 'write')) {
alert('You do not have permission to create users');
return;
}

setCurrentUser(editUser);
if (editUser) {
// Editing existing user
setUserFormData({
name: editUser.name,
email: editUser.email,
role: editUser.role,
status: editUser.status || 'active'
});
} else {
// Creating new user
setUserFormData({
name: '',
email: '',
role: '',
password: '',
status: 'active'
});
}
setShowUserForm(true);
};



const handleDeleteUser = async (userId, userName) => {
if (!window.hasPermission('users', 'delete')) {
alert('You do not have permission to delete users');
return;
}

if (!confirm(`Are you sure you want to delete user "${userName}"? This action cannot be undone.`)) {
return;
}

setLoading(true);
try {
await window.apicall(`/users/${userId}`, { method: 'DELETE' });
console.log('User deleted successfully');

// Remove user from the list
setUsers(prev => prev.filter(u => u.id !== userId));
showNotification('User deleted successfully', 'success');
} catch (error) {
console.error('Error deleting user:', error);
showNotification(error.message || 'Failed to delete user', 'error');
} finally {
setLoading(false);
}
};




const closeUserForm = () => {
setShowUserForm(false);
setEditingUser(null);
setUserFormData({
name: '',
email: '',
password: '',
role: 'viewer',
department: '',
status: 'active'
});
};



const handleUserSubmit = async (e) => {
e.preventDefault();
setLoading(true);

try {
const endpoint = editingUser ? '/users/' + (editingUser.id) : '/users';
const method = editingUser ? 'PUT' : 'POST';

const response = await window.apicall(endpoint, {
method: method,
body: JSON.stringify(userFormData)
});

if (response.error) {
throw new Error(response.error);
}

console.log(editingUser ? 'User updated successfully' : 'User created successfully');

// Refresh users list
fetchUsers();

// Close form
setShowUserForm(false);
setEditingUser(null);
setUserFormData({
name: '',
email: '',
password: '',
role: 'viewer',
department: '',
payment_status: 'paid'
});
} catch (error) {
console.error('Error saving user:', error);
alert(error.message || 'Failed to save user');
} finally {
setLoading(false);
}
};




const fetchUsers = async () => {
try {
const response = await window.apicall('/users');
if (response.data) {
setUsers(response.data);
}
} catch (error) {
console.error('Failed to fetch users:', error);
}
};



// Enhanced handleMarkAsPaid function with inventory integration
const handleMarkAsPaid = async (payableId) => {
try {
console.log('handleMarkAsPaid called with payableId:', payableId);

const payable = financialData.payables?.find(p => p.id === payableId);

if (!payable) {
console.error('Payable not found:', payableId);
alert('Payable not found.');
return;
}

console.log('Found payable:', payable);

// If linked to inventory, open inventory edit form
if (payable.inventoryId) {
console.log('Payable is linked to inventory:', payable.inventoryId);

const inventoryItem = inventory.find(inv => inv.id === payable.inventoryId);

if (!inventoryItem) {
console.error('Related inventory item not found:', payable.inventoryId);
alert('Related inventory item not found. Please refresh and try again.');
await fetchInventory();
return;
}

console.log('Found inventory item:', inventoryItem);
console.log('Opening inventory edit form for payable payment...');

// Set up for editing with payment focus
// Pre-fill form data with payment context
const inventoryWithContext = {
...inventoryItem,
_payableContext: {
payableId: payable.id,
payableAmount: payable.amount,
fromPayables: true
}
};



setEditingInventory(inventoryWithContext);

// Pre-fill form data for payment
// Calculate correct payment amounts
// When coming from payables, we're paying off the pending balance
const currentTotal = parseFloat(inventoryItem.totalPurchaseAmount || 0);
const currentPaid = parseFloat(inventoryItem.amountPaid || 0);
const pendingBalance = parseFloat(payable.amount || 0); // What we owe

console.log('Payable form pre-fill calculation:', {
currentTotal,
currentPaid,
pendingBalance,
action: 'Setting form to mark as fully paid'
});

// Pre-fill form to mark as FULLY PAID by default
setFormData({
...inventoryItem,
totalPurchaseAmount: currentTotal, // Keep original total
amountPaid: currentTotal, // Set paid amount = total amount (fully paid)
paymentStatus: 'paid' // Mark as paid by default
});

setShowInventoryForm(true);

return;
}

// For non-inventory payables, use traditional mark as paid
console.log('Processing non-inventory payable...');
const confirmPaid = confirm(`Mark payable of ‚Çπ${payable.amount} as paid?`);
if (!confirmPaid) return;

setLoading(true);

const response = await window.apicall(`/finance/payables/${payableId}`, {
method: 'PUT',
body: JSON.stringify({
status: 'paid',
paid_date: new Date().toISOString(),
payment_notes: 'Marked as paid manually'
})
});

if (response.error) {
throw new Error(response.error);
}

console.log('Payable marked as paid successfully');
alert('Payable marked as paid!');
await fetchFinancialData();

} catch (error) {
console.error('Error handling mark as paid:', error);
alert('Failed to process payment: ' + error.message);
} finally {
setLoading(false);
}
};



const fetchFinancialData = async () => {
try {
console.log('Fetching financial data...');
const [ordersRes, invoicesRes, payablesRes, inventoryRes, receivablesRes] = await Promise.all([
window.apicall('/orders'),
window.apicall('/invoices'),
window.apicall('/payables'),
window.apicall('/inventory'),
window.apicall('/receivables').catch(() => ({ data: [] }))
]);

const ordersData = ordersRes.data || [];
const invoicesData = invoicesRes.data || [];
const payablesData = payablesRes.data || [];
const inventoryData = inventoryRes.data || [];
const receivablesData = receivablesRes.data || [];

console.log('Raw receivables data:', receivablesData);

const today = new Date();
today.setHours(0, 0, 0, 0);

// FIXED: Process active sales (orders in progress with event date in future)
const activeSalesData = ordersData
.filter(order => {
// Include orders that are approved OR in service/delivery process
const validStatuses = ['approved', 'service_assigned', 'in_progress', 'delivery_scheduled', 'pending_delivery'];

if (!validStatuses.includes(order.status)) {
// Skip completed, cancelled, rejected orders
console.log(`Skipping order ${order.id} with status: ${order.status}`);
return false;
}

// Only include if event date is in future
if (!order.event_date) {
console.log(`Skipping order ${order.id} - no event date`);
return false;
}

const eventDate = new Date(order.event_date);
eventDate.setHours(0, 0, 0, 0);
const isEventInFuture = eventDate >= today;

console.log(`Order ${order.id}: status=${order.status}, eventDate=${order.event_date}, inFuture=${isEventInFuture}`);
return isEventInFuture;
})
.map(order => ({
id: order.id,
date: order.created_at || order.created_date || new Date().toISOString(),
invoice_number: order.invoice_number || 'INV-' + order.id,
clientName: order.lead_name || order.client_name || 'N/A',
assignedTo: order.assigned_to || order.sales_person || order.created_by || 'Unassigned',
amount: parseFloat(order.final_amount || order.total_amount || 0),
status: 'active',
event_date: order.event_date,
payment_status: order.payment_status || 'pending',
order_type: order.order_type,
order_status: order.status // Keep original status for reference
}));

// FIXED: Process completed sales - orders that are completed OR have past event dates
const salesData = ordersData
.filter(order => {
// Include if explicitly completed or delivered
if (order.status === 'completed' || order.status === 'delivered') {
console.log(`Including completed order ${order.id} with status: ${order.status}`);
return true;
}

// Include if event date has passed (regardless of status, except rejected/cancelled)
if (order.status !== 'rejected' && order.status !== 'cancelled' && order.event_date) {
const eventDate = new Date(order.event_date);
eventDate.setHours(0, 0, 0, 0);
const isEventPast = eventDate < today;

if (isEventPast) {
console.log(`Including past event order ${order.id}: eventDate=${order.event_date}, status=${order.status}`);
return true;
}
}

return false;
})
.map(order => ({
id: order.id,
date: order.created_at || order.created_date || new Date().toISOString(),
invoice_number: order.invoice_number || 'INV-' + order.id,
clientName: order.lead_name || order.client_name || 'N/A',
assignedTo: order.assigned_to || order.sales_person || order.created_by || 'Unassigned',
amount: parseFloat(order.final_amount || order.total_amount || 0),
status: order.payment_status === 'paid' ? 'paid' : 'completed',
event_date: order.event_date,
payment_status: order.payment_status || 'pending'
}));

// Process receivables - ensure all fields are properly mapped
const processedReceivables = receivablesData.map(r => {
console.log('Processing receivable:', r);
return {
...r,
// Ensure all required fields are present
amount: parseFloat(r.expected_amount || r.amount || 0),
balance_amount: parseFloat(r.balance_amount || r.expected_amount || r.amount || 0),
invoice_number: r.invoice_number || r.invoice_id || 'N/A',
due_date: r.due_date || r.expected_payment_date || new Date().toISOString(),
client_name: r.client_name || 'N/A',
assigned_to: r.assigned_to || 'Unassigned',
status: r.status || 'pending'
};


});

console.log('Processed receivables:', processedReceivables);

// Filter only unpaid receivables
const unpaidReceivables = processedReceivables.filter(r => r.status !== 'paid');

console.log('Unpaid receivables to display:', unpaidReceivables);

// Calculate totals
const totalActiveSales = activeSalesData.reduce((sum, sale) => sum + sale.amount, 0);
const totalSales = salesData.reduce((sum, sale) => sum + sale.amount, 0);
const totalReceivables = unpaidReceivables.reduce((sum, rec) => 
sum + (rec.balance_amount || rec.amount || 0), 0
);
const totalPayables = payablesData.reduce((sum, pay) => 
sum + parseFloat(pay.amount || 0), 0
);

// Log the results
console.log('=== FINANCIAL DATA SUMMARY ===');
console.log(`Active Sales: ${activeSalesData.length} orders, Total: ‚Çπ${totalActiveSales.toLocaleString()}`);
console.log(`Completed Sales: ${salesData.length} orders, Total: ‚Çπ${totalSales.toLocaleString()}`);
console.log(`Receivables: ${unpaidReceivables.length} entries, Total: ‚Çπ${totalReceivables.toLocaleString()}`);
console.log(`Payables: ${payablesData.length} entries, Total: ‚Çπ${totalPayables.toLocaleString()}`);

// Update state
setFinancialData({
activeSales: activeSalesData,
sales: salesData,
receivables: unpaidReceivables,
payables: payablesData,
expiringInventory: inventoryData.filter(item => {
if (!item.event_date || item.allocated) return false;
const days = Math.ceil((new Date(item.event_date) - new Date()) / (1000 * 60 * 60 * 24));
return days <= 7 && days >= 0;
})
});

console.log('Financial data set:', {
activeSales: activeSalesData.length,
sales: salesData.length,
receivables: unpaidReceivables.length,
payables: payablesData.length
});

} catch (error) {
console.error('Error fetching financial data:', error);
alert('Failed to load financial data. Please refresh the page.');
}
};




// Record payment for receivable
const recordPayment = async (receivableId) => {
const paymentAmount = prompt('Enter payment amount:');
if (!paymentAmount) return;

const paymentMode = prompt('Enter payment mode (bank_transfer/cash/cheque):', 'bank_transfer');
const transactionId = prompt('Enter transaction ID (optional):');

try {
setLoading(true);
const response = await window.apicall('/receivables/record-payment/' + (receivableId), 'PUT', {
payment_amount: parseFloat(paymentAmount),
payment_date: new Date().toISOString(),
payment_mode: paymentMode,
transaction_id: transactionId
});

alert('Payment recorded successfully!');
fetchFinancialData(); // Refresh data
} catch (error) {
console.error('Error recording payment:', error);
alert('Failed to record payment');
} finally {
setLoading(false);
}
};




const fetchMyActions = async () => {
console.log('===== fetchMyActions CALLED =====');
console.log('Timestamp:', new Date().toISOString());
console.log('Current user:', user);
console.log('User email:', user?.email);
console.log('User role:', user?.role);
console.log('Is logged in:', isLoggedIn);
console.log('Loading state:', loading);

if (!user) {
console.error('No user object - cannot fetch actions');
return;
}

if (!user) {
console.log('No user logged in');
return;
}

try {
setLoading(true);
console.log('Fetching actions for:', user.name, '(' + user.email + ')');

// Fetch all data in parallel
const [leadsResponse, ordersResponse, deliveriesResponse, receivablesResponse] = await Promise.all([
window.apicall('/leads').catch(err => { console.error('Failed to fetch leads:', err); return { data: [] }; }),
window.apicall('/orders').catch(err => { console.error('Failed to fetch orders:', err); return { data: [] }; }),
window.apicall('/deliveries').catch(err => { console.error('Failed to fetch deliveries:', err); return { data: [] }; }),
window.apicall('/receivables').catch(err => { console.error('Failed to fetch receivables:', err); return { data: [] }; })
]);

// Debug: Log all API responses
console.log('=== API RESPONSES RECEIVED ===');
console.log('Leads response:', leadsResponse);
console.log('Number of leads:', leadsResponse?.data?.length || 0);
if (leadsResponse?.data?.length > 0) {
console.log('First lead full data:', leadsResponse.data[0]);
console.log('Lead assignment field:', leadsResponse.data[0].assigned_to || leadsResponse.data[0].assignedTo || 'NOT FOUND');
}

// Filter leads assigned to me
// Filter leads assigned to me
if (leadsResponse && leadsResponse.data) {
const assignedLeads = leadsResponse.data.filter(lead => {
console.log('\n--- Checking Lead ---');
console.log('Lead:', lead);
console.log('Lead name:', lead.name);
console.log('Lead assigned_to:', lead.assigned_to);
console.log('Lead assignedTo:', lead.assignedTo);
console.log('My email:', user.email);

const isAssigned = lead.assigned_to === user.email;
console.log('Match result:', isAssigned);

return isAssigned;
});

// Filter quote requested leads for supply managers and supply sales service managers
const quoteRequestedLeads = leadsResponse.data.filter(lead => {
if (lead.status === 'quote_requested') {
// Check if user is supply_manager or has supply_sales_service role
return (user.role === 'supply_manager' || 
user.role === 'supply_sales_service_manager' ||
lead.quote_assigned_to === user.email);
}
return false;
});

console.log('\n=== FILTER RESULTS ===');
console.log('Total leads:', leadsResponse.data.length);
console.log('Assigned to me:', assignedLeads.length);
console.log('Quote requested for me:', quoteRequestedLeads.length);
console.log('Assigned leads:', assignedLeads);
console.log('Quote requested leads:', quoteRequestedLeads);

setMyLeads(assignedLeads);
setMyQuoteRequested(quoteRequestedLeads);
} else {
setMyLeads([]);
setMyQuoteRequested([]);
}

// Filter orders based on role
if (ordersResponse && ordersResponse.data) {
let assignedOrders = [];

if (user.role === 'supply_sales_service_manager' || user.role === 'supply_executive') {
assignedOrders = ordersResponse.data.filter(order => 
order.status === 'approved' && order.assigned_to === user.email
);
} else if (user.role === 'finance_manager' || user.role === 'finance_executive') {
assignedOrders = ordersResponse.data.filter(order => 
order.status === 'pending_approval'
);
}

console.log('My orders:', assignedOrders.length);
setMyOrders(assignedOrders);
} else {
setMyOrders([]);
}

// Filter deliveries
if (deliveriesResponse && deliveriesResponse.data) {
const assignedDeliveries = deliveriesResponse.data.filter(delivery => 
delivery.assigned_to === user.email
);
console.log('My deliveries:', assignedDeliveries.length);
setMyDeliveries(assignedDeliveries);
} else {
setMyDeliveries([]);
}

// Get overdue receivables
if (receivablesResponse && receivablesResponse.data) {
const today = new Date();
const overdueReceivables = receivablesResponse.data.filter(rec => {
if (rec.status === 'paid') return false;
const dueDate = new Date(rec.due_date);
return dueDate < today;
});
console.log('Overdue receivables:', overdueReceivables.length);
setMyReceivables(overdueReceivables);
} else {
setMyReceivables([]);
}

setLoading(false);
} catch (error) {
console.error('Error in fetchMyActions:', error);
setLoading(false);
}
};



window.chartInstances = chartInstances;
window.calculateDashboardStats = calculateDashboardStats;
window.debugCharts = () => {
console.log('=== Chart Debug Info ===');
console.log('Canvas elements:', {
leadSplit: document.getElementById('leadSplitChart'),
tempCount: document.getElementById('tempCountChart'),
tempValue: document.getElementById('tempValueChart')
});
console.log('Chart instances:', window.chartInstances);
console.log('Current leads:', leads);
console.log('Lead statuses:', leads.map(l => ({ name: l.name, status: l.status })));
};



// 5. Function to manually initialize charts:
window.forceInitCharts = () => {
console.log('Force initializing charts...');
initializeChartsAdvanced();
};    

window.debugDashboard = () => {
console.log('=== Dashboard Debug ===');
console.log('Active tab:', activeTab);
console.log('Leads count:', leads.length);
console.log('Chart.js loaded:', typeof Chart !== 'undefined');
console.log('Canvas elements in DOM:', {
leadSplit: !!document.getElementById('leadSplitChart'),
tempCount: !!document.getElementById('tempCountChart'),
tempValue: !!document.getElementById('tempValueChart')
});
console.log('Chart instances:', {
leadSplit: !!chartInstances.leadSplit,
tempCount: !!chartInstances.tempCount,
tempValue: !!chartInstances.tempValue
});

// Try to reinitialize
if (activeTab === 'dashboard') {
console.log('Attempting manual chart initialization...');
initializeChartsAdvanced();
}
};



// Enhanced lead progression function with permission check
// Status update function with permission check
const updateLeadStatus = async (leadId, newStatus) => {
if (!window.hasPermission('leads', 'progress')) {
alert('You do not have permission to progress leads');
return;
}

try {
setLoading(true);

// CRITICAL: Get the full lead object first
const currentLead = leads.find(l => l.id === leadId);
if (!currentLead) {
alert('Lead not found');
setLoading(false);
return;
}

// Include ALL fields from current lead
const updateData = {
...currentLead,  // This includes EVERYTHING
status: newStatus,
last_contact_date: new Date().toISOString(),
[(newStatus) + '_date']: new Date().toISOString(),
updated_date: new Date().toISOString()
};



console.log('Updating lead with full data:', updateData);

// API call to update lead status
const response = await window.apicall('/leads/' + (leadId), {
method: 'PUT',
body: JSON.stringify(updateData)
});

// Update local state with response from server
console.log("Status update response:", response);
setLeads(prevLeads => 
prevLeads.map(lead => 
lead.id === leadId ? response.data : lead
)
);

// Update current lead if in detail view
if (showLeadDetail && currentLead?.id === leadId) {
setCurrentLead(response.data);
}

setLoading(false);
alert('Lead status updated successfully!');
} catch (error) {
console.error('Error updating lead status:', error);
setLoading(false);
alert('Failed to update lead status: ' + error.message);
}
};




// 2. REPLACE your renderStatusProgressModal function with this corrected version:

const renderStatusProgressModal = () => {
// NO useState declarations here - they're now at top level!

const handleStatusUpdate = async () => {
if (!selectedStatus) {
alert('Please select a status');
return;
}

const selectedStatusConfig = window.LEAD_STATUSES[selectedStatus];

// Check if follow-up date is required
if (selectedStatusConfig.requires_followup_date && !followUpDate) {
alert('Follow-up date is required for this status');
return;
}

try {
setLoading(true);

// Handle payment status specially
if (selectedStatus === 'payment') {
setShowStatusProgressModal(false);
openPaymentForm(currentLead);
setLoading(false);
return;
}

if (selectedStatus === 'payment_post_service') {
setShowStatusProgressModal(false);
openPaymentPostServiceForm(currentLead);
setLoading(false);
return;
}

// Prepare update data
const updateData = {
...currentLead,
status: selectedStatus,
last_contact_date: new Date().toISOString(),
[(selectedStatus) + '_date']: new Date().toISOString(),
updated_date: new Date().toISOString()
};



// Add follow-up specific fields if applicable
if (selectedStatusConfig.requires_followup_date && followUpDate) {
updateData.next_follow_up_date = followUpDate;
updateData.follow_up_notes = followUpNotes;
updateData.follow_up_reason = selectedStatus === 'pickup_later' ? 'Pick up later' : 'Follow up required';

// Store previous status for pickup_later
if (selectedStatus === 'pickup_later') {
updateData.previous_status = currentLead.status;
}
}

// Update lead status
const response = await window.apicall('/leads/' + currentLead.id, {
method: 'PUT',
body: JSON.stringify(updateData)
});

// Update local state
setLeads(prevLeads => 
prevLeads.map(lead => 
lead.id === currentLead.id ? response.data : lead
)
);

// Update current lead if in detail view
if (showLeadDetail && currentLead?.id === currentLead.id) {
setCurrentLead(response.data);
}

setLoading(false);
setShowStatusProgressModal(false);

// Clear the form after successful update
setSelectedStatus('');
setFollowUpDate('');
setFollowUpNotes('');

// Show success message with follow-up info
if (selectedStatusConfig.requires_followup_date && followUpDate) {
alert(`Lead status updated successfully! Follow-up scheduled for ${new Date(followUpDate).toLocaleString()}`);
} else {
alert('Lead status updated successfully!');
}
} catch (error) {
console.error('Error updating lead status:', error);
setLoading(false);
alert('Failed to update lead status: ' + error.message);
}
};



const handleModalClose = () => {
setShowStatusProgressModal(false);
// Clear form when closing
setSelectedStatus('');
setFollowUpDate('');
setFollowUpNotes('');
};



if (!showStatusProgressModal) return null;

return React.createElement('div', { 
className: 'fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center z-50' 
},
React.createElement('div', { 
className: 'bg-white rounded-lg p-6 w-full max-w-md max-h-screen overflow-y-auto' 
},
React.createElement('h3', { 
className: 'text-lg font-medium text-gray-900 mb-4' 
}, 'Progress Lead: ' + (currentLead?.name || '')),

React.createElement('p', { 
className: 'text-sm text-gray-600 mb-4' 
}, 'Current Status: ' + window.LEAD_STATUSES[currentLead?.status]?.label),

// Status selection
React.createElement('div', { className: 'mb-4' },
React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-2' }, 'Select New Status:'),
React.createElement('select', {
value: selectedStatus,
onChange: (e) => setSelectedStatus(e.target.value),
className: 'w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500'
},
React.createElement('option', { value: '' }, 'Choose status...'),
statusProgressOptions.map(option =>
React.createElement('option', { 
key: option.value, 
value: option.value 
}, `${option.icon || ''} ${option.label}`)
)
)
),

// Follow-up date field (shown when required)
selectedStatus && window.LEAD_STATUSES[selectedStatus]?.requires_followup_date && 
React.createElement('div', { className: 'mb-4' },
React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-2' }, 
'üìÖ Follow-up Date: *'
),
React.createElement('input', {
type: 'datetime-local',
value: followUpDate,
onChange: (e) => setFollowUpDate(e.target.value),
className: 'w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500',
min: new Date().toISOString().slice(0, 16) // Prevent past dates
}),
React.createElement('p', { className: 'text-xs text-gray-500 mt-1' },
'This will create an automatic reminder for follow-up'
)
),

// Follow-up notes field (shown when follow-up date is required)
selectedStatus && window.LEAD_STATUSES[selectedStatus]?.requires_followup_date && 
React.createElement('div', { className: 'mb-4' },
React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-2' }, 
'üìù Follow-up Notes:'
),
React.createElement('textarea', {
value: followUpNotes,
onChange: (e) => setFollowUpNotes(e.target.value),
placeholder: selectedStatus === 'pickup_later' 
? 'Why are we picking this up later? Add context for future reference...'
: 'Add notes for the follow-up...',
rows: 3,
className: 'w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500'
})
),

// Action buttons
React.createElement('div', { className: 'flex justify-end space-x-3 mt-6' },
React.createElement('button', {
type: 'button',
onClick: handleModalClose,
className: 'px-4 py-2 border border-gray-300 rounded-md text-sm font-medium text-gray-700 hover:bg-gray-50 focus:ring-2 focus:ring-blue-500'
}, 'Cancel'),
React.createElement('button', {
type: 'button',
onClick: handleStatusUpdate,
disabled: loading,
className: 'px-4 py-2 bg-blue-600 text-white text-sm font-medium rounded-md hover:bg-blue-700 disabled:opacity-50 focus:ring-2 focus:ring-blue-500'
}, loading ? 'Updating...' : 'Update Status')
)
)
);
};



const handleLeadProgression = (lead) => {
if (!window.hasPermission('leads', 'progress')) {
alert('You do not have permission to progress leads');
return;
}

const currentStatus = lead.status;
const nextOptions = window.LEAD_STATUSES[currentStatus]?.next || [];

if (nextOptions.length === 0) {
alert('This lead is already at the final stage.');
return;
}

// Check if any of the next options require follow-up date (like pickup_later)
const hasFollowUpOptions = nextOptions.some(status => 
window.LEAD_STATUSES[status]?.requires_followup_date
);

if (nextOptions.length === 1) {
const nextStatus = nextOptions[0];

// Handle pickup_later status (requires follow-up date)
if (nextStatus === 'pickup_later') {
setCurrentLead(lead);
setShowStatusProgressModal(true);
setStatusProgressOptions([{
value: 'pickup_later',
label: window.LEAD_STATUSES['pickup_later'].label,
color: window.LEAD_STATUSES['pickup_later'].color,
requires_followup_date: true
}]);
return;
}

// Handle payment status (existing logic)
if (nextStatus === 'payment') {
if (currentStatus === 'payment_post_service') {
// Coming from payment_post_service, collect payment
const receivable = receivables.find(r => r.lead_id === lead.id && r.status === 'pending');
if (receivable) {
collectPostServicePayment(receivable);
} else {
openPaymentForm(lead);
}
} else {
openPaymentForm(lead);
}
return;
}

// For other single status transitions (including attempts)
updateLeadStatus(lead.id, nextStatus);
} else {
// Multiple options available - need to show choice modal

// Handle special case for converted status with payment options (existing logic)
if (currentStatus === 'converted' && 
nextOptions.includes('payment') && 
nextOptions.includes('payment_post_service')) {

// Check if pickup_later is also an option
if (nextOptions.includes('pickup_later')) {
// Show enhanced choice modal with pickup_later option
setCurrentLeadForChoice(lead);
setChoiceOptions([
{ value: 'payment', label: 'Collect Payment Now', icon: 'üí≥' },
{ value: 'payment_post_service', label: 'Payment Post Service', icon: 'üìÖ' },
{ value: 'pickup_later', label: 'Pick Up Later', icon: '‚è∞', requires_followup_date: true }
]);
setShowChoiceModal(true);
} else {
// Original logic for payment choices
setCurrentLeadForChoice(lead);
setChoiceOptions([
{ value: 'payment', label: 'Collect Payment Now', icon: 'üí≥' },
{ value: 'payment_post_service', label: 'Payment Post Service', icon: 'üìÖ' }
]);
setShowChoiceModal(true);
}
} 
// If any option requires follow-up date, use the enhanced modal
else if (hasFollowUpOptions) {
setCurrentLead(lead);
setShowStatusProgressModal(true);
setStatusProgressOptions(nextOptions.map(status => ({
value: status,
label: window.LEAD_STATUSES[status].label,
color: window.LEAD_STATUSES[status].color,
requires_followup_date: window.LEAD_STATUSES[status].requires_followup_date,
icon: window.getStatusIcon(status) // Helper function for icons
})));
} 
// Otherwise use the existing choice modal (this handles attempts and all other flows)
else {
setCurrentLeadForChoice(lead);
setChoiceOptions(nextOptions.map(status => ({
value: status,
label: window.LEAD_STATUSES[status].label,
icon: window.getStatusIcon(status)
})));
setShowChoiceModal(true);
}
}
};



const handleQuoteRequestStage = async (lead, newStatus) => {
try {
setLoading(true);

// Preserve temperature when moving to quote_requested
const currentTemperature = getLeadTemperature(lead);

const updateData = {
...lead,
status: newStatus,
temperature: currentTemperature, // Preserve the temperature
quote_requested_date: new Date().toISOString(),
last_contact_date: new Date().toISOString(),
updated_date: new Date().toISOString(),
// Dual assignment: keep original assignee and add sales service manager
quote_assigned_to: user.role === 'supply_manager' ? user.email : 'supply.service@fantopark.com', // Auto-assign based on role
dual_assignment: true
};



const response = await window.apicall(`/leads/${lead.id}`, {
method: 'PUT',
body: JSON.stringify(updateData)
});

// Update local state
setLeads(prevLeads => 
prevLeads.map(l => 
l.id === lead.id ? response.data : l
)
);

// Update current lead if in detail view
if (showLeadDetail && currentLead?.id === lead.id) {
setCurrentLead(response.data);
}

setLoading(false);
alert('Lead moved to Quote Requested stage and assigned to Sales Service Manager!');
} catch (error) {
console.error('Error updating lead to quote requested:', error);
setLoading(false);
alert('Failed to update lead status: ' + error.message);
}
};



// Enhanced Choice Modal Handler to support pickup_later
const handleChoiceSelection = async (choice) => {
try {
setLoading(true);

// If choice requires follow-up date, switch to the enhanced modal
if (choice.requires_followup_date) {
setShowChoiceModal(false);
setCurrentLead(currentLeadForChoice);
setShowStatusProgressModal(true);
setStatusProgressOptions([{
value: choice.value,
label: choice.label,
color: window.LEAD_STATUSES[choice.value]?.color || 'bg-gray-100 text-gray-800',
requires_followup_date: true
}]);
setLoading(false);
return;
}

// Handle payment choices (existing logic)
if (choice.value === 'payment') {
setShowChoiceModal(false);
openPaymentForm(currentLeadForChoice);
setLoading(false);
return;
}

if (choice.value === 'payment_post_service') {
setShowChoiceModal(false);
openPaymentPostServiceForm(currentLeadForChoice);
setLoading(false);
return;
}

// For regular status updates
await updateLeadStatus(currentLeadForChoice.id, choice.value);
setShowChoiceModal(false);
setLoading(false);
} catch (error) {
console.error('Error handling choice selection:', error);
setLoading(false);
alert('Failed to update lead status: ' + error.message);
}
};





// Form handlers with permission checks
const openAddForm = (type) => {
if (!window.hasPermission(type === 'lead' ? 'leads' : (type === 'order' ? 'orders' : type), 'write')) {
alert('You do not have permission to create ' + (type) + 's');
return;
}
setCurrentForm(type);
setFormData({});
setShowAddForm(true);
};



const openEditForm = (lead) => {
if (!window.hasPermission('leads', 'write')) {
alert('You do not have permission to edit leads');
return;
}

setCurrentLead(lead);

// ‚úÖ FIXED: Convert date format for HTML date input
const processedLead = { ...lead };
if (processedLead.date_of_enquiry) {
try {
const date = new Date(processedLead.date_of_enquiry);
if (!isNaN(date.getTime())) {
// Convert to YYYY-MM-DD format for HTML date input
processedLead.date_of_enquiry = date.toISOString().split('T')[0];
}
} catch (error) {
console.warn('Could not parse date:', processedLead.date_of_enquiry);
// Set to current date as fallback
const now = new Date();
processedLead.date_of_enquiry = now.toISOString().split('T')[0];
}
}

setFormData(processedLead);
setShowEditForm(true);
};



const openAssignForm = (lead) => {
if (!window.hasPermission('leads', 'assign')) {
alert('You do not have permission to assign leads');
return;
}
setCurrentLead(lead);
setFormData({ assigned_team: 'sales', assigned_to: '' });
setShowAssignForm(true);
};



const openPaymentForm = (lead) => {
  if (!window.hasPermission('leads', 'write')) {
    alert('You do not have permission to manage payments');
    return;
  }
  
  setCurrentLead(lead);
  
  // Initialize payment data with defaults
  const initialPaymentData = {
    // Basic payment details
    advance_amount: '', // Changed from payment_amount
    payment_method: 'bank_transfer', // ADD: Default payment method
    transaction_id: '',
    payment_date: new Date().toISOString().split('T')[0],
    payment_proof: '',
    notes: '',
    
    // NEW: Enhanced customer classification
    customer_type: 'indian', // 'indian', 'nri', 'foreigner'
    event_location: 'india', // 'india', 'outside_india'
    payment_currency: 'INR', // 'INR', 'USD', 'EUR', 'GBP'
    
    // NEW: TCS fields with enhanced support
    tcs_applicable: false,
    tcs_rate: 5, // Default to 5%
    tcs_amount: 0,
    tcs_rate_manual: false, // Track if rate was manually selected
    
    // GST and Legal details
    gstin: lead.gstin || '', // ADD: Get from lead if available
    legal_name: lead.legal_name || lead.name || '', // CHANGE: Prioritize legal_name
    category_of_sale: lead.business_type === 'B2B' ? 'Corporate' : 'Retail', // CHANGE: Map to Corporate/Retail
    type_of_sale: 'Tour', // Tour or Service Fee
    registered_address: lead.registered_address || '', // ADD: Get from lead if available
    indian_state: 'Haryana',
    is_outside_india: false,
    gst_certificate: null,
    pan_card: null,
    
    // ENHANCED: Multi-row invoice items with additional info support
    invoice_items: [{
      description: lead.lead_for_event || 'Travel Package',
      additional_info: '', // NEW: For bracket info like (Lorem Ipsum)
      quantity: lead.number_of_people || 1,
      rate: lead.last_quoted_price || 0
    }],
    
    // GST calculations
    gst_rate: 5, // Default to 5% for Tour packages
    service_fee_amount: 0, // Only for Service Fee type
    
    // ADD: Missing fields for receivables and post-service payments
    from_receivable: false,
    payment_post_service: false,
    receivable_id: null,
    receivable_amount: 0
  };
  
  // Calculate initial TCS applicability and rate
  const baseAmount = lead.last_quoted_price * (lead.number_of_people || 1) || 0;
  if (baseAmount > 0) {
    const calculation = calculateGSTAndTCS(baseAmount, initialPaymentData);
    initialPaymentData.tcs_applicable = calculation.tcs.applicable;
    initialPaymentData.tcs_rate = calculation.tcs.rate;
    initialPaymentData.tcs_amount = calculation.tcs.amount;
  }
  
  setPaymentData(initialPaymentData);
  setShowPaymentForm(true);
};



const handleMarkPaymentFromReceivable = async (receivable) => {
console.log('Mark Payment clicked for receivable:', receivable);

// Check different possible field names for lead ID
const leadId = receivable.lead_id || receivable.leadId || receivable.lead;

if (!leadId) {
// If still no lead ID, check if there's an order we can get the lead from
if (receivable.order_id) {
const order = orders.find(o => o.id === receivable.order_id);
if (order && order.lead_id) {
const lead = leads.find(l => l.id === order.lead_id);
if (lead) {
setCurrentLead(lead);
openPaymentForm(lead);
setPaymentData(prev => ({
...prev,
payment_post_service: true,
advance_amount: receivable.balance_amount || receivable.expected_amount || receivable.amount || ''
,
from_receivable: true,
receivable_id: receivable.id,
receivable_amount: receivable.balance_amount || receivable.expected_amount || receivable.amount || 0
}));
return;
}
}
}

alert('Cannot find associated lead for this receivable.');
console.error('Receivable structure:', receivable);
return;
}

// Continue with normal flow if lead_id exists
const lead = leads.find(l => l.id === leadId);

if (!lead) {
try {
console.log('Fetching lead from API:', leadId);
const response = await window.apicall('/leads/' + leadId);
const leadData = response.data || response;

setCurrentLead(leadData);
openPaymentForm(leadData);
setPaymentData(prev => ({
...prev,
payment_post_service: true,
advance_amount: receivable.balance_amount || receivable.expected_amount || receivable.amount || ''
,
from_receivable: true,
receivable_id: receivable.id,
receivable_amount: receivable.balance_amount || receivable.expected_amount || receivable.amount || 0
}));
} catch (error) {
console.error('Error fetching lead:', error);
alert('Could not find associated lead: ' + error.message);
}
} else {
setCurrentLead(lead);
openPaymentForm(lead);
setPaymentData(prev => ({
...prev,
payment_post_service: true,
advance_amount: receivable.balance_amount || receivable.expected_amount || receivable.amount || ''
,
from_receivable: true,
receivable_id: receivable.id,
receivable_amount: receivable.balance_amount || receivable.expected_amount || receivable.amount || 0
}));
}
};



const openLeadDetail = (lead) => {
setCurrentLead(lead);
setShowLeadDetail(true);
};



const openAllocationForm = (inventoryItem) => {
if (!window.hasPermission('inventory', 'allocate')) {
alert('You do not have permission to allocate inventory');
return;
}
setCurrentInventory(inventoryItem);
setAllocationData({
lead_id: '',
tickets_allocated: 1,
allocation_date: new Date().toISOString().split('T')[0],
notes: ''
});
setShowAllocationForm(true);
};



const openEditInventoryForm = (inventoryItem) => {
if (!window.hasPermission('inventory', 'write')) {
alert('You do not have permission to edit inventory');
return;
}
setCurrentInventory(inventoryItem);
setFormData(inventoryItem);
setShowEditInventoryForm(true);
};



// Add this right after the openEditInventoryForm function
const handleEditInventory = async (inventoryData) => {
try {
setLoading(true);

console.log('Updating inventory with data:', inventoryData);

// Validate payment amounts
const totalAmount = parseFloat(inventoryData.totalPurchaseAmount || 0);
const amountPaid = parseFloat(inventoryData.amountPaid || 0);

if (amountPaid > totalAmount) {
alert('Amount paid cannot be greater than total purchase amount.');
setLoading(false);
return;
}

// Auto-set payment status
if (amountPaid >= totalAmount) {
inventoryData.paymentStatus = 'paid';
} else if (amountPaid > 0) {
inventoryData.paymentStatus = 'partial';
} else {
inventoryData.paymentStatus = 'pending';
}

// Update inventory (this will automatically sync payables via backend)
const response = await window.apicall(`/inventory/${editingInventory.id}`, {
method: 'PUT',
body: JSON.stringify(inventoryData)
});

if (response.error) {
throw new Error(response.error);
}

// Update local state
setInventory(prev => prev.map(item => 
item.id === editingInventory.id 
? { ...item, ...inventoryData }
: item
));

// Refresh financial data to show updated payables
if (window.hasPermission('finance', 'read')) {
await fetchFinancialData();
}

alert(response.message || 'Inventory updated successfully! Payables have been synced automatically.');
setShowInventoryForm(false);
setEditingInventory(null);

} catch (error) {
console.error('Error updating inventory:', error);
alert('Failed to update inventory: ' + error.message);
} finally {
setLoading(false);
}
};



const openInventoryDetail = (inventoryItem) => {
setCurrentInventoryDetail(inventoryItem);
setShowInventoryDetail(true);
};



// 3. ADD THIS FUNCTION to close inventory detail:
const closeInventoryDetail = () => {
setShowInventoryDetail(false);
setCurrentInventoryDetail(null);
};



const openAddInventoryForm = () => {
console.log('openAddInventoryForm called');

// Fetch stadiums if not already loaded
if (stadiums.length === 0) {
fetchStadiums();
}

// Set up for new inventory item
setEditingInventory({ 
id: null, // Indicates this is a new item
event_name: '',
event_date: '',
event_type: '',
sports: '',
venue: '',
// Add other default fields as needed
});

// Initialize form data with empty values
setFormData({
event_name: '',
event_date: '',
event_type: '',
sports: '',
venue: '',
day_of_match: '',
category_of_ticket: '',
total_tickets: '',
available_tickets: '',
mrp_of_ticket: '',
buying_price: '',
selling_price: '',
stand: '',
inclusions: '',
booking_person: '',
procurement_type: '',
notes: '',
paymentStatus: 'pending',
supplierName: '',
supplierInvoice: '',
totalPurchaseAmount: '',
amountPaid: '',
paymentDueDate: ''
});

setShowInventoryForm(true);
console.log('Inventory form should now be visible with empty form data');
};



const handleCopyInventory = async (item) => {
try {
setLoading(true);

// Create a copy of the inventory item with modified fields
const copiedData = {
...item,
// Remove ID and system fields that shouldn't be copied
id: undefined,
created_date: undefined,
updated_date: undefined,

// Modify the event name to indicate it's a copy
event_name: item.event_name + ' (Copy)',

// Reset availability to match total tickets (fresh inventory)
available_tickets: item.total_tickets,

// Clear payment-related fields for fresh start
paymentStatus: 'pending',
amountPaid: 0,
supplierInvoice: '',

// Update creation info
created_by: JSON.parse(localStorage.getItem('crm_user') || '{}').name || 'Unknown User',
notes: (item.notes || '') + (item.notes ? '\n\n' : '') + 'Copied from original inventory on ' + new Date().toLocaleDateString()
};



console.log('Creating copy of inventory:', copiedData);

// Call API to create the copied inventory
const response = await window.apicall('/inventory', {
method: 'POST',
body: JSON.stringify(copiedData)
});

if (response.error) {
throw new Error(response.error);
}

console.log('Copy created successfully:', response.data);

// Update local state by adding the new item to the inventory array
setInventory(prev => [...prev, response.data]);

alert(`‚úÖ Inventory copied successfully!\n\nNew event: "${copiedData.event_name}"\nTotal tickets: ${copiedData.total_tickets}\nAvailable tickets: ${copiedData.available_tickets}`);

} catch (error) {
console.error('Error copying inventory:', error);
alert('‚ùå Failed to copy inventory: ' + error.message);
} finally {
setLoading(false);
}
};





const openDeliveryForm = (delivery) => {
if (!window.hasPermission('delivery', 'write')) {
alert('You do not have permission to manage deliveries');
return;
}
setCurrentDelivery(delivery);
setDeliveryFormData({
delivery_type: delivery.delivery_type || 'offline',
pickup_location: delivery.pickup_location || '',
delivery_location: delivery.delivery_location || '',
pickup_date: '',
pickup_time: '',
delivery_date: '',
delivery_time: '',
delivery_person: delivery.assigned_to || '',
delivery_notes: '',
online_platform: '',
online_link: ''
});
setShowDeliveryForm(true);
};



const openPaymentPostServiceForm = (lead) => {
if (!window.hasPermission('leads', 'write')) {
alert('You do not have permission to manage payment post service');
return;
}
setCurrentLead(lead);
setPaymentPostServiceData({
expected_payment_date: '',
expected_amount: lead.last_quoted_price || 0,
service_date: '',
service_details: '',
payment_terms: '30 days',
reminder_days: '7',
notes: ''
});
setShowPaymentPostServiceForm(true);
};



const handlePaymentPostServiceInputChange = (field, value) => {
setPaymentPostServiceData(prev => ({ ...prev, [field]: value }));
};



const handlePaymentPostServiceSubmit = async (e) => {
e.preventDefault();

if (!window.hasPermission('leads', 'write')) {
alert('You do not have permission to manage payment post service');
return;
}

setLoading(true);

try {
// Update lead status via API
const leadResponse = await window.apicall('/leads/' + (currentLead.id), {
method: 'PUT',
body: JSON.stringify({
status: 'payment_post_service',
payment_post_service_details: paymentPostServiceData,
payment_post_service_date: new Date().toISOString()
})
});

// Update local state
setLeads(prev => 
prev.map(lead => 
lead.id === currentLead.id ? leadResponse : lead
)
);

// Create order with all required fields
const newOrder = {
order_number: 'ORD-' + (Date.now()),
lead_id: currentLead.id,
client_name: currentLead.name,
client_email: currentLead.email,
client_phone: currentLead.phone,

// Required order fields for backend
event_name: currentLead?.lead_for_event || 'Post Service Payment',
event_date: paymentPostServiceData.service_date || new Date().toISOString().split('T')[0],
tickets_allocated: 1,
ticket_category: 'Post Service',
price_per_ticket: parseFloat(paymentPostServiceData.expected_amount) || 0,
total_amount: parseFloat(paymentPostServiceData.expected_amount) || 0,

// Payment post service specific fields
expected_amount: parseFloat(paymentPostServiceData.expected_amount),
expected_payment_date: paymentPostServiceData.expected_payment_date,
service_description: paymentPostServiceData.service_details,
notes: paymentPostServiceData.notes,
payment_terms: paymentPostServiceData.payment_terms,

// Order metadata
order_type: 'payment_post_service',
payment_status: 'pending',
status: 'pending_approval',
requires_gst_invoice: true,
created_date: new Date().toISOString(),
created_by: user.name,
assigned_to: ''  // Will be assigned later
};



// Create order in backend
try {
console.log('Creating payment post service order:', JSON.stringify(newOrder, null, 2));
const orderResponse = await window.apicall('/orders', {
method: 'POST',
body: JSON.stringify(newOrder)
});
console.log('Order created in backend (Post Service):', orderResponse);

// Use the response data or fallback to newOrder
const finalOrder = orderResponse.data || orderResponse || newOrder;
if (!finalOrder.id && newOrder.order_number) {
finalOrder.id = newOrder.order_number;
}

setOrders(prev => [...prev, finalOrder]);

setLoading(false);
alert('Payment Post Service order created successfully! Awaiting approval.');
closeForm();
} catch (orderError) {
console.error('Failed to create order in backend:', orderError);

// Add to local state with the order_number as id
newOrder.id = newOrder.order_number;
setOrders(prev => [...prev, newOrder]);

setLoading(false);
alert('Warning: Order may not have been saved to server. Please check orders page.');
closeForm();
}
} catch (error) {
setLoading(false);
alert('Failed to process payment post service. Please try again.');
console.error('Payment post service error:', error);
}
};




const collectPostServicePayment = (receivable) => {
const lead = leads.find(l => l.id === receivable.lead_id);
if (lead) {
setCurrentLead(lead);
setPaymentData({
...paymentData,
advance_amount: receivable.expected_amount,
payment_post_service: true,
from_receivable: true,
receivable_id: receivable.id,
receivable_amount: receivable.expected_amount || receivable.balance_amount || receivable.amount || 0
});
setShowPaymentForm(true);
}
};



const sendEmailNotification = (notification) => {
console.log('Email Notification:', {
to: notification.recipient,
subject: notification.subject,
body: notification.body,
sent_at: new Date().toISOString()
});

// Update notification status
setEmailNotifications(prev => 
prev.map(n => 
n.id === notification.id 
? { ...n, status: 'sent', sent_date: new Date().toISOString() }
: n
)
);
};



const handleDeliverySubmit = async (e) => {
e.preventDefault();
if (!window.hasPermission('delivery', 'write')) {
alert('You do not have permission to manage deliveries');
return;
}

setLoading(true);

try {
await new Promise(resolve => setTimeout(resolve, 1000));

// Update delivery in backend
try {
await window.apicall('/deliveries/' + (currentDelivery.id), {
method: 'PUT',
body: JSON.stringify({
...currentDelivery,
...deliveryFormData,
status: 'scheduled',
scheduled_date: new Date().toISOString()
})
});
console.log('Delivery updated in backend');
} catch (error) {
console.error('Failed to update delivery in backend:', error);
}

setDeliveries(prev => 
prev.map(delivery => 
delivery.id === currentDelivery.id 
? { 
...delivery, 
...deliveryFormData,
status: 'scheduled',
scheduled_date: new Date().toISOString().split('T')[0]
} 
: delivery
)
);

setLoading(false);
alert('Delivery scheduled successfully!');
closeForm();
} catch (error) {
setLoading(false);
alert('Failed to schedule delivery. Please try again.');
}
};



const deleteDelivery = async (deliveryId) => {
if (!window.hasPermission('delivery', 'write')) {
alert('You do not have permission to delete deliveries');
return;
}

if (!confirm('Are you sure you want to delete this delivery? This action cannot be undone.')) {
return;
}

setLoading(true);
try {
await window.apicall('/deliveries/' + (deliveryId), {
method: 'DELETE'
});

setDeliveries(prev => prev.filter(d => d.id !== deliveryId));

alert('Delivery deleted successfully!');
} catch (error) {
console.error('Failed to delete delivery:', error);
alert('Failed to delete delivery. Please try again.');
} finally {
setLoading(false);
}
};



const closeForm = () => {
setShowAddForm(false);
setShowEditForm(false);
setShowAssignForm(false);
setShowPaymentForm(false);
setShowLeadDetail(false);
setShowAllocationForm(false);
setShowEditInventoryForm(false);
setShowChoiceModal(false);
setShowInvoicePreview(false);
setShowDeliveryForm(false);
setShowPaymentPostServiceForm(false);
setCurrentForm('');
setCurrentLead(null);
setCurrentInventory(null);
setCurrentLeadForChoice(null);
setCurrentInvoice(null);
setCurrentDelivery(null);
setChoiceOptions([]);
setFormData({});
setPaymentData({});
setAllocationData({});
setDeliveryFormData({});
setPaymentPostServiceData({});
};



const handleInputChange = (field, value, itemIndex = null, itemField = null) => {
if (itemIndex !== null && itemField !== null) {
updateInvoiceItem(itemIndex, itemField, value);
} else {
setPaymentData(prevData => ({
...prevData,
[field]: value
}));
}
};



const handleFormDataChange = (field, value) => {
console.log('Form field changed:', field, '=', value);
setFormData(prev => ({
...prev,
[field]: value
}));
}; 

const handleUserInputChange = (field, value) => {
setUserFormData(prev => ({ ...prev, [field]: value }));
};



const handleAllocationInputChange = (field, value) => {
setAllocationData(prev => ({ ...prev, [field]: value }));
};


const handleDeliveryInputChange = (field, value) => {
setDeliveryFormData(prev => ({ ...prev, [field]: value }));
};



// Delete function with permission check
const handleDelete = async (type, id, name) => {
console.log("handleDelete called:", type, id, name);
const modulePermissions = {
'leads': 'leads',
'inventory': 'inventory',
'orders': 'orders'
};



if (!window.hasPermission(modulePermissions[type], 'delete')) {
alert('You do not have permission to delete ' + (type));
return;
}

if (!confirm('Are you sure you want to delete ' + (name) + '?')) return;

setLoading(true);
try {
// Special handling for orders - convert delete to cancel
console.log("Processing order deletion as cancellation");
if (type === 'orders') {
console.log("Deleting order permanently");
try {
// Actually delete the order
await window.apicall('/' + (type) + '/' + (id), {
method: 'DELETE'
});

// If successful, remove from local state
setOrders(prev => prev.filter(order => order.id !== id));

setLoading(false);
alert('Order deleted successfully!');
} catch (deleteError) {
console.error("Delete failed:", deleteError);
console.log("Delete error details:", deleteError.message, deleteError.status);

// If backend doesn't support DELETE, mark as deleted instead
if (deleteError.message && (deleteError.message.includes('404') || deleteError.message.includes('405'))) {
console.log("Backend doesn't support DELETE, marking as deleted");
try {
await window.apicall('/orders/' + (id), {
method: 'PUT',
body: JSON.stringify({
status: 'deleted',
deleted_date: new Date().toISOString(),
deleted_by: user?.name || 'Admin',
is_deleted: true
})
});

// Remove from local view
setOrders(prev => prev.filter(order => order.id !== id));
alert('Order marked as deleted successfully!');
return;
} catch (putError) {
console.error("PUT also failed:", putError);
}
}
// If DELETE not supported, remove locally with warning
setOrders(prev => prev.filter(order => order.id !== id));
setLoading(false);
alert('Order removed. Note: This may reappear on refresh if server delete is not supported.');
}setLoading(false);
alert('Order cancelled successfully!');
} else {
// For leads and inventory, try actual DELETE
try {
console.log("Making API call to:", '/' + (type) + '/' + (id));
await window.apicall('/' + (type) + '/' + (id), {
method: 'DELETE'
});

// If successful, update local state
switch (type) {
case 'leads':
setLeads(prev => prev.filter(item => item.id !== id));
break;
case 'inventory':
setInventory(prev => prev.filter(item => item.id !== id));
break;
}

setLoading(false);
alert((type === 'inventory' ? 'Event' : type.slice(0, -1)) + ' deleted successfully!');
} catch (deleteError) {
// If DELETE fails, just remove from local state with warning
switch (type) {
case 'leads':
setLeads(prev => prev.filter(item => item.id !== id));
break;
case 'inventory':
setInventory(prev => prev.filter(item => item.id !== id));
break;
}

setLoading(false);
alert((type === 'inventory' ? 'Event' : type.slice(0, -1)) + ' removed locally. May reappear on refresh if server delete is not supported.');
}
}
} catch (error) {
setLoading(false);
alert('Failed to process ' + (type === 'inventory' ? 'event' : type.slice(0, -1)) + ': ' + (error.message));
}
};

const ReminderCard = (reminder, isOverdue) => {
const lead = leads.find(l => l.id === reminder.lead_id);

return React.createElement('div', {
key: reminder.id,
className: `border rounded-lg p-4 ${isOverdue ? 'border-red-300 bg-red-50 dark:bg-red-900/20' : 'border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800'}`
},
React.createElement('div', {
className: 'flex items-start justify-between'
},
React.createElement('div', {
className: 'flex-1'
},
React.createElement('div', {
className: 'flex items-center space-x-3 mb-2'
},
React.createElement('span', {
className: `px-2 py-1 rounded text-xs font-medium ${getPriorityColor(reminder.priority)}`
}, reminder.priority.toUpperCase()),
React.createElement('span', {
className: `text-sm ${isOverdue ? 'text-red-600 font-semibold' : 'text-gray-600 dark:text-gray-400'}`
}, formatRelativeTime(reminder.due_date)),
reminder.auto_generated && React.createElement('span', {
className: 'px-2 py-1 bg-purple-100 text-purple-600 rounded text-xs'
}, 'Auto')
),
React.createElement('h4', {
className: 'font-semibold text-gray-900 dark:text-white mb-1'
}, reminder.title),
React.createElement('p', {
className: 'text-sm text-gray-600 dark:text-gray-400 mb-2'
}, reminder.description),
lead && React.createElement('div', {
className: 'text-sm text-blue-600 dark:text-blue-400'
}, `üë§ ${lead.name} - ${lead.phone} - ${lead.lead_for_event || 'General'}`)
),
React.createElement('div', {
className: 'flex space-x-2'
},
React.createElement('button', {
onClick: () => completeReminder(reminder.id, 'Completed from dashboard'),
className: 'px-3 py-1 bg-green-600 text-white rounded text-sm hover:bg-green-700'
}, '‚úì Complete'),
React.createElement('button', {
onClick: () => snoozeReminder(reminder.id, 24),
className: 'px-3 py-1 bg-yellow-600 text-white rounded text-sm hover:bg-yellow-700'
}, '‚è∞ Snooze'),
lead && React.createElement('button', {
onClick: () => {
setCurrentLead(lead);
setShowEditForm(true);
setShowReminderDashboard(false);
},
className: 'px-3 py-1 bg-blue-600 text-white rounded text-sm hover:bg-blue-700'
}, 'üë§ View Lead')
)
)
);
};



const ReminderDashboard = () => {
if (!showReminderDashboard) return null;

const pendingReminders = reminders.filter(r => r.status === 'pending');
const overdueReminders = pendingReminders.filter(r => new Date(r.due_date) < new Date());
const todayReminders = pendingReminders.filter(r => {
const today = new Date();
const reminderDate = new Date(r.due_date);
return reminderDate.toDateString() === today.toDateString();
});

return React.createElement('div', {
className: 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50'
},
React.createElement('div', {
className: 'bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-6xl h-5/6 flex flex-col'
},
// Header
React.createElement('div', {
className: 'flex items-center justify-between p-6 border-b border-gray-200 dark:border-gray-700'
},
React.createElement('h2', {
className: 'text-2xl font-bold text-gray-900 dark:text-white flex items-center'
},
React.createElement('span', { className: 'mr-3' }, 'üîî'),
'Smart Follow-up Reminders'
),
React.createElement('button', {
onClick: () => setShowReminderDashboard(false),
className: 'text-gray-400 hover:text-gray-600 text-2xl'
}, '√ó')
),

// Stats Cards
React.createElement('div', {
className: 'grid grid-cols-4 gap-4 p-6 bg-gray-50 dark:bg-gray-900'
},
React.createElement('div', {
className: 'bg-white dark:bg-gray-800 rounded-lg p-4 text-center shadow'
},
React.createElement('div', {
className: 'text-2xl font-bold text-blue-600'
}, reminderStats.total),
React.createElement('div', {
className: 'text-sm text-gray-600 dark:text-gray-400'
}, 'Total Reminders')
),
React.createElement('div', {
className: 'bg-white dark:bg-gray-800 rounded-lg p-4 text-center shadow'
},
React.createElement('div', {
className: 'text-2xl font-bold text-red-600'
}, reminderStats.overdue),
React.createElement('div', {
className: 'text-sm text-gray-600 dark:text-gray-400'
}, 'Overdue')
),
React.createElement('div', {
className: 'bg-white dark:bg-gray-800 rounded-lg p-4 text-center shadow'
},
React.createElement('div', {
className: 'text-2xl font-bold text-orange-600'
}, reminderStats.due_today),
React.createElement('div', {
className: 'text-sm text-gray-600 dark:text-gray-400'
}, 'Due Today')
),
React.createElement('div', {
className: 'bg-white dark:bg-gray-800 rounded-lg p-4 text-center shadow'
},
React.createElement('div', {
className: 'text-2xl font-bold text-green-600'
}, reminderStats.pending),
React.createElement('div', {
className: 'text-sm text-gray-600 dark:text-gray-400'
}, 'Pending')
)
),

// Reminders List
React.createElement('div', {
className: 'flex-1 overflow-auto p-6'
},
// Overdue Section
overdueReminders.length > 0 && React.createElement('div', {
className: 'mb-8'
},
React.createElement('h3', {
className: 'text-lg font-semibold text-red-600 mb-4 flex items-center'
},
React.createElement('span', { className: 'mr-2' }, 'üö®'),
`Overdue (${overdueReminders.length})`
),
React.createElement('div', {
className: 'space-y-3'
},
overdueReminders.map(reminder => 
ReminderCard(reminder, true)
)
)
),

// Due Today Section
todayReminders.length > 0 && React.createElement('div', {
className: 'mb-8'
},
React.createElement('h3', {
className: 'text-lg font-semibold text-orange-600 mb-4 flex items-center'
},
React.createElement('span', { className: 'mr-2' }, '‚è∞'),
`Due Today (${todayReminders.length})`
),
React.createElement('div', {
className: 'space-y-3'
},
todayReminders.map(reminder => 
ReminderCard(reminder, false)
)
)
),

// All Pending Reminders
React.createElement('div', null,
React.createElement('h3', {
className: 'text-lg font-semibold text-gray-700 dark:text-gray-300 mb-4 flex items-center'
},
React.createElement('span', { className: 'mr-2' }, 'üìã'),
`All Pending (${pendingReminders.length})`
),
React.createElement('div', {
className: 'space-y-3'
},
pendingReminders.map(reminder => 
ReminderCard(reminder, new Date(reminder.due_date) < new Date())
)
)
)
)
)
);
};

// Communication Timeline Component
const CommunicationTimeline = ({ leadId, leadName }) => {
const [communications, setCommunications] = React.useState([]);
const [loading, setLoading] = React.useState(false);
const [showAddForm, setShowAddForm] = React.useState(false);

const fetchCommunications = async () => {
if (!leadId) return;

try {
setLoading(true);
const response = await window.apicall(`/communications/lead/${leadId}`);
setCommunications(response.data || []);
} catch (error) {
console.error('Error fetching communications:', error);
} finally {
setLoading(false);
}
};



React.useEffect(() => {
fetchCommunications();
}, [leadId]);

const addCommunication = async (commData) => {
try {
const response = await window.apicall('/communications', {
method: 'POST',
body: JSON.stringify({
...commData,
lead_id: leadId
})
});

if (response.data) {
setCommunications(prev => [response.data, ...prev]);
setShowAddForm(false);
alert('Communication logged successfully!');
}
} catch (error) {
console.error('Error adding communication:', error);
alert('Failed to log communication: ' + error.message);
}
};



const getCommIcon = (type) => {
const icons = {
call: 'üìû',
email: 'üìß', 
whatsapp: 'üí¨',
meeting: 'ü§ù',
sms: 'üì±',
system: 'ü§ñ'
};


return icons[type] || 'üìù';
};



const getOutcomeColor = (outcome) => {
const colors = {
interested: 'bg-green-100 text-green-800',
not_interested: 'bg-red-100 text-red-800',
follow_up: 'bg-yellow-100 text-yellow-800',
closed: 'bg-gray-100 text-gray-800'
};


return colors[outcome] || 'bg-blue-100 text-blue-800';
};



return React.createElement('div', { className: 'bg-white rounded-lg shadow-sm border mt-6' },
React.createElement('div', { className: 'p-4 border-b flex justify-between items-center' },
React.createElement('h3', { className: 'text-lg font-semibold flex items-center gap-2' },
React.createElement('span', null, 'üìû'),
`Communication Timeline (${communications.length})`
),
React.createElement('button', {
onClick: () => setShowAddForm(true),
className: 'px-3 py-1 bg-blue-600 text-white text-sm rounded hover:bg-blue-700'
}, '+ Add Communication')
),

showAddForm && React.createElement('div', { className: 'p-4 bg-gray-50 border-b' },
React.createElement(CommunicationForm, {
onSubmit: addCommunication,
onCancel: () => setShowAddForm(false)
})
),

React.createElement('div', { className: 'p-4' },
loading ? React.createElement('div', { className: 'text-center py-8' }, 'Loading communications...') :
communications.length === 0 ? React.createElement('div', { className: 'text-center py-8 text-gray-500' },
'No communications yet. Click "Add Communication" to start tracking interactions.'
) :
React.createElement('div', { className: 'space-y-4' },
communications.map((comm, index) => 
React.createElement('div', { 
key: comm.id,
className: 'flex gap-4 p-3 border-l-4 border-blue-200 bg-gray-50 rounded-r'
},
React.createElement('div', { className: 'flex-shrink-0' },
React.createElement('div', { className: 'w-10 h-10 bg-blue-100 rounded-full flex items-center justify-center text-lg' },
getCommIcon(comm.communication_type)
)
),

React.createElement('div', { className: 'flex-1' },
React.createElement('div', { className: 'flex items-start justify-between' },
React.createElement('div', null,
React.createElement('h4', { className: 'font-medium text-gray-900' }, comm.subject || `${comm.communication_type} ${comm.direction}`),
React.createElement('p', { className: 'text-sm text-gray-600 mt-1' }, comm.content)
),
React.createElement('div', { className: 'text-xs text-gray-500 text-right' },
React.createElement('div', null, new Date(comm.created_date).toLocaleDateString()),
React.createElement('div', null, new Date(comm.created_date).toLocaleTimeString())
)
),

React.createElement('div', { className: 'flex gap-2 mt-2 flex-wrap' },
comm.duration_minutes && React.createElement('span', { className: 'px-2 py-1 bg-gray-200 text-xs rounded' }, 
`${comm.duration_minutes} min`
),
comm.outcome && React.createElement('span', { className: `px-2 py-1 text-xs rounded ${getOutcomeColor(comm.outcome)}` }, 
comm.outcome.replace('_', ' ')
),
comm.temperature && comm.temperature !== 'warm' && React.createElement('span', { 
className: `px-2 py-1 text-xs rounded ${comm.temperature === 'hot' ? 'bg-red-100 text-red-800' : 'bg-blue-100 text-blue-800'}`
}, comm.temperature),
comm.is_auto_logged && React.createElement('span', { className: 'px-2 py-1 bg-purple-100 text-purple-800 text-xs rounded' }, 'Auto-logged')
),

React.createElement('div', { className: 'text-xs text-gray-500 mt-1' },
`by ${comm.created_by_name || comm.created_by}`
)
)
)
)
)
)
);
};

// Set display name for debugging
window.AssignmentRulesManager.displayName = 'window.AssignmentRulesManager';

// ULTRA-FIX: Add display name for debugging
window.AssignmentRulesManager.displayName = 'window.AssignmentRulesManager';

const refreshAssignmentRules = async () => {
try {
// This will clear any cached assignment data and reload fresh rules
await window.apicall('/assignment-rules/refresh', 'POST');
} catch (error) {
console.log('Assignment rules refresh failed (non-critical):', error);
// Non-critical - rules will still work
}
}; 

// Communication Form Component
const CommunicationForm = ({ onSubmit, onCancel }) => {
const [formData, setFormData] = React.useState({
communication_type: 'call',
direction: 'outbound',
subject: '',
content: '',
duration_minutes: '',
outcome: '',
temperature: 'warm'
});

const handleSubmit = (e) => {
e.preventDefault();
if (!formData.subject && !formData.content) {
alert('Please provide a subject or content');
return;
}

onSubmit({
...formData,
duration_minutes: formData.duration_minutes ? parseInt(formData.duration_minutes) : null
});
};



return React.createElement('form', { onSubmit: handleSubmit, className: 'space-y-4' },
React.createElement('div', { className: 'grid grid-cols-1 md:grid-cols-2 gap-4' },
React.createElement('div', null,
React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-1' }, 'Type'),
React.createElement('select', {
value: formData.communication_type,
onChange: (e) => setFormData(prev => ({ ...prev, communication_type: e.target.value })),
className: 'w-full p-2 border border-gray-300 rounded text-sm'
},
React.createElement('option', { value: 'call' }, 'üìû Phone Call'),
React.createElement('option', { value: 'email' }, 'üìß Email'),
React.createElement('option', { value: 'whatsapp' }, 'üí¨ WhatsApp'),
React.createElement('option', { value: 'meeting' }, 'ü§ù Meeting')
)
),

React.createElement('div', null,
React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-1' }, 'Direction'),
React.createElement('select', {
value: formData.direction,
onChange: (e) => setFormData(prev => ({ ...prev, direction: e.target.value })),
className: 'w-full p-2 border border-gray-300 rounded text-sm'
},
React.createElement('option', { value: 'outbound' }, 'üì§ Outbound'),
React.createElement('option', { value: 'inbound' }, 'üì• Inbound')
)
)
),

React.createElement('div', null,
React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-1' }, 'Subject'),
React.createElement('input', {
type: 'text',
value: formData.subject,
onChange: (e) => setFormData(prev => ({ ...prev, subject: e.target.value })),
className: 'w-full p-2 border border-gray-300 rounded text-sm',
placeholder: 'Brief summary...'
})
),

React.createElement('div', null,
React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-1' }, 'Details'),
React.createElement('textarea', {
value: formData.content,
onChange: (e) => setFormData(prev => ({ ...prev, content: e.target.value })),
className: 'w-full p-2 border border-gray-300 rounded text-sm',
rows: 3,
placeholder: 'Detailed notes...'
})
),

React.createElement('div', { className: 'grid grid-cols-1 md:grid-cols-3 gap-4' },
React.createElement('div', null,
React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-1' }, 'Outcome'),
React.createElement('select', {
value: formData.outcome,
onChange: (e) => setFormData(prev => ({ ...prev, outcome: e.target.value })),
className: 'w-full p-2 border border-gray-300 rounded text-sm'
},
React.createElement('option', { value: '' }, 'Select outcome...'),
React.createElement('option', { value: 'interested' }, '‚úÖ Interested'),
React.createElement('option', { value: 'not_interested' }, '‚ùå Not Interested'),
React.createElement('option', { value: 'follow_up' }, 'üîÑ Follow Up Required')
)
),

formData.communication_type === 'call' && React.createElement('div', null,
React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-1' }, 'Duration (min)'),
React.createElement('input', {
type: 'number',
value: formData.duration_minutes,
onChange: (e) => setFormData(prev => ({ ...prev, duration_minutes: e.target.value })),
className: 'w-full p-2 border border-gray-300 rounded text-sm',
placeholder: '15'
})
),

React.createElement('div', null,
React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-1' }, 'Temperature'),
React.createElement('select', {
value: formData.temperature,
onChange: (e) => setFormData(prev => ({ ...prev, temperature: e.target.value })),
className: 'w-full p-2 border border-gray-300 rounded text-sm'
},
React.createElement('option', { value: 'hot' }, 'üî• Hot'),
React.createElement('option', { value: 'warm' }, 'üå°Ô∏è Warm'),
React.createElement('option', { value: 'cold' }, '‚ùÑÔ∏è Cold')
)
)
),

React.createElement('div', { className: 'flex gap-2 justify-end' },
React.createElement('button', {
type: 'button',
onClick: onCancel,
className: 'px-4 py-2 text-gray-600 hover:text-gray-800'
}, 'Cancel'),
React.createElement('button', {
type: 'submit',
className: 'px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700'
}, 'Log Communication')
)
);
};



// ===== END OF COMMUNICATION COMPONENTS =====

// Enhanced sidebar with user access control
const renderSidebar = () => {
const menuItems = [
{ id: 'dashboard', label: 'Dashboard', icon: 'üìä' },
{ id: 'leads', label: 'Leads', icon: 'üë•' },
{ id: 'inventory', label: 'Inventory', icon: 'üé´' },
{ id: 'orders', label: 'Orders', icon: 'üìã' },
{ id: 'delivery', label: 'Delivery', icon: 'üöö' },
{ id: 'finance', label: 'Financials', icon: 'üí∞' },
{ id: 'stadiums', label: 'Stadiums', icon: 'üèüÔ∏è' },
{ id: 'sports-calendar', label: 'Sports Calendar', icon: 'üìÖ' }, // ADD THIS LINE
{ id: 'reminders', label: 'Reminders', icon: 'üîî' },
{ id: 'myactions', label: 'My Actions', icon: 'üìå' },
{ id: 'assignment-rules', label: 'Assignment Rules', icon: '‚öôÔ∏è' }

];

return React.createElement('div', { className: 'w-64 bg-white shadow-lg' },
React.createElement('div', { className: 'p-4' },
React.createElement('div', { className: 'flex items-center space-x-3' },
React.createElement('div', { className: 'w-8 h-8 bg-blue-600 rounded-lg flex items-center justify-center' },
React.createElement('span', { className: 'text-white' }, 'üèÜ')
),
React.createElement('h2', { className: 'text-xl font-bold text-gray-900 dark:text-white' }, 'FanToPark CRM')
),
user && React.createElement('div', { className: 'mt-4 p-3 bg-blue-50 rounded-lg' },
React.createElement('div', { className: 'text-sm font-medium text-blue-900' }, user.name),
React.createElement('div', { className: 'text-xs text-blue-600' }, window.USER_ROLES[user.role]?.label || user.role),
React.createElement('div', { className: 'text-xs text-blue-500' }, user.department)
)
),
React.createElement('nav', { className: 'mt-8' },
menuItems.filter(item => canAccessTab(item.id)).map(item =>
React.createElement('button', {
key: item.id,
onClick: () => setActiveTab(item.id),
className: 'w-full flex items-center px-4 py-3 text-left hover:bg-gray-50 ' + (activeTab === item.id ? 'bg-blue-50 border-r-2 border-blue-600 text-blue-600' : 'text-gray-700')
},
React.createElement('span', { className: 'mr-3' }, item.icon),
item.label
)
),
// User Management - only for users with permission
window.hasPermission('users', 'read') && React.createElement('button', {
onClick: openUserManagement,
className: 'w-full flex items-center px-4 py-3 text-left hover:bg-gray-50 text-gray-700'
},
React.createElement('span', { className: 'mr-3' }, 'üë§'),
'User Management'
),
// Role Management - only for super admin
user && user.role === 'super_admin' && React.createElement('button', {
onClick: () => setActiveTab('roles'),
className: 'w-full flex items-center px-4 py-3 text-left hover:bg-gray-50 text-gray-700'
},
React.createElement('span', { className: 'mr-3' }, 'üõ°Ô∏è'),
'Role Management'
)
),
React.createElement('div', { className: 'mt-auto p-4' },
React.createElement('button', {
onClick: handleLogout,
className: 'w-full flex items-center px-4 py-3 text-gray-700 hover:bg-gray-50 rounded overflow-hidden'
},
React.createElement('span', { className: 'mr-3' }, 'üö™'),
'Logout'
)
)
);
};

const updateDeliveryStatus = (deliveryId) => {
// Implement delivery status update
alert('Delivery status update coming soon!');
};



const approveOrder = async (orderId) => {
if (confirm('Are you sure you want to approve this order?')) {
try {
await window.apicall('/orders/' + (orderId), {
method: 'PUT',
body: JSON.stringify({ status: 'approved' })
});
alert('Order approved successfully!');
fetchMyActions();
} catch (error) {
alert('Failed to approve order: ' + error.message);
}
}
};



const viewOrderDetails = (order) => {
setCurrentOrderDetail(order);
setShowOrderDetail(true);
};



const viewLeadDetails = (lead) => {
setCurrentLead(lead);
setShowLeadDetail(true);
};

// FIXED: Add this BEFORE the renderContent function to create a stable AssignmentRulesTab
const AssignmentRulesTab = React.useMemo(() => {
  return window.hasPermission('leads', 'assign') ? 
    React.createElement(window.AssignmentRulesManager, { 
      key: 'assignment-rules-stable',
      currentUser: user 
    }) :
    React.createElement('div', { className: 'text-center py-12' },
      React.createElement('p', { className: 'text-red-500 text-lg' }, 
        'Access Denied: You do not have permission to manage assignment rules.'
      )
    );
}, [user]); // Only recreate when user changes

// Login screen
if (!isLoggedIn) {
return React.createElement('div', { className: 'min-h-screen bg-gray-100 flex items-center justify-center'},
React.createElement('div', { className: 'max-w-md w-full bg-white rounded-lg shadow-md p-6' },
React.createElement('div', { className: 'text-center mb-8' },
React.createElement('div', { className: 'w-12 h-12 bg-blue-600 rounded-lg flex items-center justify-center mx-auto mb-4' },
React.createElement('span', { className: 'text-white text-xl' }, 'ÔøΩÔøΩ')
),
React.createElement('h2', { className: 'text-2xl font-bold text-gray-900' }, 'FanToPark CRM'),
React.createElement('p', { className: 'text-gray-600' }, 'Sign in to your account')
),
React.createElement('form', { onSubmit: handleLogin },
React.createElement('div', { className: 'mb-4' },
React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-2' }, 'Email'),
React.createElement('input', {
type: 'email',
value: email,
onChange: (e) => setEmail(e.target.value),
className: 'w-full px-3 py-2 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded-md focus:ring-2 focus:ring-blue-500',
required: true
})
),
React.createElement('div', { className: 'mb-6' },
React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-2' }, 'Password'),
React.createElement('input', {
type: 'password',
autoComplete: 'current-password',
value: password,
onChange: (e) => setPassword(e.target.value),
className: 'w-full px-3 py-2 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded-md focus:ring-2 focus:ring-blue-500',
required: true
})
),
React.createElement('button', {
type: 'submit',
disabled: loading,
className: 'w-full bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 disabled:opacity-50'
}, loading ? 'Signing in...' : 'Sign In')
),
React.createElement('div', { className: 'mt-6 text-sm text-gray-600' },
React.createElement('p', { className: 'font-medium mb-2' }, 'Demo Accounts:'),
React.createElement('div', { className: 'space-y-1 text-xs' },
React.createElement('p', null, React.createElement('strong', null, 'Super Admin:'), ' admin@fantopark.com / admin123'),
React.createElement('p', null, React.createElement('strong', null, 'Sales Manager:'), ' varun@fantopark.com / sales123'),
React.createElement('p', null, React.createElement('strong', null, 'Sales Executive:'), ' pratik@fantopark.com / sales123'),
React.createElement('p', null, React.createElement('strong', null, 'Supply Manager:'), ' akshay@fantopark.com / supply123'),
React.createElement('p', null, React.createElement('strong', null, 'Finance Manager:'), ' finance@fantopark.com / finance123')
)
)
)
);
}

// [Include all the missing rendering functions with permission checks]

// Form fields remain the same
const leadFormFields = [
{ name: 'name', label: 'Contact Name', type: 'text', required: true, section: 'basic' },
{ name: 'email', label: 'Email', type: 'email', required: true, section: 'basic' },
{ name: 'phone', label: 'Phone', type: 'tel', required: true, section: 'basic' },
{ name: 'company', label: 'Company', type: 'text', section: 'basic' },
{ name: 'business_type', label: 'Business Type', type: 'select', options: ['B2C', 'B2B'], required: true, section: 'basic' },
{ name: 'source', label: 'Source of Lead', type: 'select', options: [
'Facebook', 'Instagram', 'LinkedIn', 'Friends and Family', 'Through Champion', 
'Website', 'Existing Client', 'Contacted on Social Media', 'Middlemen', 
'Wealth Management Firm', 'Media Agency', 'Concierge Desk', 
'Travel Partner', 'Travel OTA'
], required: true, section: 'source' },
{ name: 'date_of_enquiry', label: 'Date of Enquiry', type: 'date', required: true, section: 'source' },
{ name: 'first_touch_base_done_by', label: 'First Touch Base Done By', type: 'text', required: true, section: 'source' },
{ name: 'city_of_residence', label: 'City of Residence', type: 'text', required: true, section: 'location' },
{ name: 'country_of_residence', label: 'Country of Residence', type: 'select', options: [
'India', 'United States', 'United Kingdom', 'Australia', 'Canada', 'Singapore', 
'UAE', 'Saudi Arabia', 'Germany', 'France', 'Italy', 'Spain', 'Netherlands', 
'Switzerland', 'Japan', 'South Korea', 'Other'
], required: true, section: 'location' },
{ name: 'lead_for_event', label: 'Lead for Event', type: 'inventory_select', required: true, section: 'event' },
{ name: 'number_of_people', label: 'Number of People Going', type: 'number', required: true, min: 1, section: 'event' },
{ name: 'has_valid_passport', label: 'Has Valid Passport', type: 'select', options: ['Yes', 'No', 'Not Sure'], section: 'travel' },
{ name: 'visa_available', label: 'Visa Available', type: 'select', options: ['Yes', 'No', 'Not Required', 'In Process'], section: 'travel' },
{ name: 'attended_sporting_event_before', label: 'Attended Sporting Event Before', type: 'select', options: ['Yes', 'No'], required: true, section: 'experience' },
{ name: 'annual_income_bracket', label: 'Annual Income Bracket', type: 'select', options: [
'Below ‚Çπ5 Lakhs', '‚Çπ5-10 Lakhs', '‚Çπ10-25 Lakhs', '‚Çπ25-50 Lakhs', 
'‚Çπ50 Lakhs - ‚Çπ1 Crore', '‚Çπ1-2 Crores', '‚Çπ2-5 Crores', 'Above ‚Çπ5 Crores'
], required: true, section: 'financial' },
{ name: 'status', label: 'Lead Status', type: 'select', options: Object.keys(window.LEAD_STATUSES), section: 'sales', editOnly: true },
{ name: 'assigned_to', label: 'Assigned To', type: 'select', options: [...(users || []).filter(u => ['sales_executive', 'sales_manager'].includes(u.role)), ...(users || []).filter(u => ['supply_executive', 'supply_sales_service_manager'].includes(u.role))], section: 'sales', editOnly: true},
{ name: 'last_quoted_price', label: 'Last Quoted Price (‚Çπ)', type: 'number', section: 'sales', editOnly: true },
{ name: 'potential_value', label: 'Potential Value (‚Çπ)', type: 'number', section: 'business' },
{ name: 'notes', label: 'Additional Notes', type: 'textarea', section: 'business' }
];

// Enhanced Event Form Fields based on Excel structure
const eventFormFields = [
  // Core Event Information
  { name: 'event_name', label: 'Event Name', type: 'text', required: true, section: 'basic' },
  { name: 'event_type', label: 'Event Type', type: 'select', options: ['Sport', 'Concert', 'Conference', 'Exhibition', 'Other'], required: true, section: 'basic' },
  { name: 'sport_type', label: 'Sport Type', type: 'select', options: ['Cricket', 'Football', 'Tennis', 'Basketball', 'Golf', 'Formula 1', 'Marathon', 'Boxing', 'Wrestling', 'Hockey', 'Badminton', 'Other'], required: true, section: 'basic' },
  { name: 'geography', label: 'Geography/Location', type: 'select', options: ['India', 'UAE - Dubai', 'UAE - Abu Dhabi', 'UK', 'USA', 'Australia', 'South Africa', 'New Zealand', 'Other'], required: true, section: 'basic' },
  
  // Date and Time Information
  { name: 'start_date', label: 'Start Date', type: 'date', required: true, section: 'datetime' },
  { name: 'end_date', label: 'End Date', type: 'date', required: false, section: 'datetime' },
  { name: 'start_time', label: 'Start Time', type: 'time', required: false, section: 'datetime' },
  { name: 'end_time', label: 'End Time', type: 'time', required: false, section: 'datetime' },
  
  // Venue Information
  { name: 'venue', label: 'Venue', type: 'text', required: true, section: 'venue' },
  { name: 'venue_capacity', label: 'Venue Capacity', type: 'number', required: false, section: 'venue' },
  { name: 'venue_address', label: 'Venue Address', type: 'textarea', required: false, section: 'venue' },
  
  // Ticketing Information
  { name: 'official_ticketing_partners', label: 'Official Ticketing Partners', type: 'textarea', required: false, section: 'ticketing' },
  { name: 'primary_source', label: 'Primary Source', type: 'text', required: false, section: 'ticketing' },
  { name: 'secondary_source', label: 'Secondary Source', type: 'text', required: false, section: 'ticketing' },
  { name: 'ticket_available', label: 'Tickets Available for Sale', type: 'checkbox', required: false, section: 'ticketing' },
  
  // Priority and Status
  { name: 'priority', label: 'Priority', type: 'select', options: ['P1', 'P2', 'P3'], required: true, section: 'status' },
  { name: 'status', label: 'Status', type: 'select', options: ['upcoming', 'live', 'completed', 'cancelled', 'postponed'], required: true, section: 'status' },
  { name: 'sold_out_potential', label: 'Sold Out Potential', type: 'select', options: ['High', 'Medium', 'Low', 'No'], required: false, section: 'status' },
  
  // Additional Information
  { name: 'remarks', label: 'Remarks/Description', type: 'textarea', required: false, section: 'additional' },
  { name: 'fantopark_package', label: 'FanToPark Package Details', type: 'textarea', required: false, section: 'additional' }
];  

const inventoryFormFields = [
{ name: 'event_name', label: 'Event Name', type: 'text', required: true },
{ name: 'event_date', label: 'Event Date', type: 'date', required: true },
{ name: 'event_type', label: 'Event Type', type: 'select', options: ['IPL', 'India Cricket + ICC', 'Football', 'Tennis', 'F1', 'Miscellaneous'], required: true },
{ name: 'sports', label: 'Sports Category', type: 'select', options: ['Cricket', 'Football', 'Tennis', 'Formula 1', 'Olympics', 'Basketball', 'Badminton', 'Hockey', 'Golf', 'Wrestling'], required: true },
{ name: 'venue', label: 'Venue', type: 'select', options: 'dynamic', required: true },
{ name: 'day_of_match', label: 'Day of Match (for Test/Multi-day)', type: 'select', options: ['Day 1', 'Day 2', 'Day 3', 'Day 4', 'Day 5', 'Not Applicable'], required: false },
{ name: 'category_of_ticket', label: 'Category of Ticket', type: 'select', options: ['VIP', 'Premium', 'Gold', 'Silver', 'Bronze', 'General', 'Corporate Box', 'Hospitality'], required: true },
{ name: 'stand', label: 'Stand/Section', type: 'text', required: false, placeholder: 'e.g., North Stand, East Pavilion' },
{ name: 'total_tickets', label: 'Total Tickets', type: 'number', required: true },
{ name: 'available_tickets', label: 'Available Tickets', type: 'number', required: true },
{ name: 'mrp_of_ticket', label: 'MRP of Ticket (‚Çπ)', type: 'number', required: true },
{ name: 'buying_price', label: 'Buying Price (‚Çπ)', type: 'number', required: true },
{ name: 'selling_price', label: 'Selling Price (‚Çπ)', type: 'number', required: true },
{ name: 'inclusions', label: 'Inclusions', type: 'textarea', required: false, placeholder: 'e.g., Food, Beverages, Parking, Merchandise, Meet & Greet' },
{ name: 'booking_person', label: 'Booking Person (Who Purchased)', type: 'text', required: true, placeholder: 'Name of person/company who purchased inventory' },
{ name: 'procurement_type', label: 'Procurement Type', type: 'select', options: ['pre_inventory', 'on_demand', 'partnership', 'direct_booking'], required: true },
{ name: 'notes', label: 'Additional Notes', type: 'textarea', required: false, placeholder: 'Any special conditions, restrictions, or notes' },

// Payment Information Fields
{ name: 'paymentStatus', label: 'Payment Status', type: 'select', options: ['paid', 'pending'], required: true },
{ name: 'supplierName', label: 'Supplier Name', type: 'text', required: false },
{ name: 'supplierInvoice', label: 'Supplier Invoice #', type: 'text', required: false },
{ name: 'purchasePrice', label: 'Purchase Price (per ticket)', type: 'number', required: false },
{ name: 'totalPurchaseAmount', label: 'Total Purchase Amount', type: 'number', required: false },
{ name: 'amountPaid', label: 'Amount Paid', type: 'number', required: false },
{ name: 'paymentDueDate', label: 'Payment Due Date', type: 'date', required: false }
];

const orderFormFields = [
{ name: 'client_name', label: 'Client Name', type: 'text', required: true },
{ name: 'client_email', label: 'Client Email', type: 'email', required: true },
{ name: 'client_phone', label: 'Client Phone', type: 'tel', required: true },
{ name: 'event_name', label: 'Event Name', type: 'text', required: true },
{ name: 'event_date', label: 'Event Date', type: 'date', required: true },
{ name: 'tickets_allocated', label: 'Number of Tickets', type: 'number', required: true },
{ name: 'ticket_category', label: 'Ticket Category', type: 'select', options: ['VIP', 'Premium', 'Gold', 'Silver', 'Bronze', 'General'], required: true },
{ name: 'price_per_ticket', label: 'Price per Ticket (‚Çπ)', type: 'number', required: true },
{ name: 'total_amount', label: 'Total Amount (‚Çπ)', type: 'number', required: true },
{ name: 'payment_method', label: 'Payment Method', type: 'select', options: ['Bank Transfer', 'UPI', 'Credit Card', 'Debit Card', 'Cheque', 'Cash'], required: true },
{ name: 'transaction_id', label: 'Transaction ID', type: 'text', required: true },
{ name: 'allocation_notes', label: 'Order Notes', type: 'textarea' }
];

// Enhanced allocation handling with permission check
// Enhanced allocation handling with permission check
const handleAllocation = async (e) => {
e.preventDefault();
if (!window.hasPermission('inventory', 'allocate')) {
alert('You do not have permission to allocate inventory');
return;
}

setLoading(true);

try {
// FIX: Don't use parseInt for lead ID comparison
const selectedLead = leads.find(lead => lead.id === allocationData.lead_id);

if (!selectedLead) {
throw new Error('Lead not found');
}

// Define the validation function
const isConvertedOrLater = (status) => {
const postConvertedStages = ['converted', 'payment', 'payment_post_service', 'payment_received'];
return postConvertedStages.includes(status);
};



// Use it in the validation
if (!isConvertedOrLater(selectedLead.status)) {
throw new Error('Lead must be in converted status or later to allocate inventory');
}

if (allocationData.tickets_allocated > currentInventory.available_tickets) {
throw new Error('Not enough tickets available');
}

// Call the fixed backend endpoint
const response = await window.apicall(`/inventory/${currentInventory.id}/allocate`, {
method: 'POST',
body: JSON.stringify({
lead_id: allocationData.lead_id,
tickets_allocated: parseInt(allocationData.tickets_allocated),
allocation_date: allocationData.allocation_date,
notes: allocationData.notes
})
});

if (response.error) {
throw new Error(response.error);
}

// Update local inventory state
setInventory(prev => 
prev.map(item => 
item.id === currentInventory.id 
? { ...item, available_tickets: response.remaining_tickets }
: item
)
);

// Close the allocation form and show success
setShowAllocationForm(false);
alert('Inventory allocated successfully!');

} catch (error) {
console.error('Allocation error:', error);
alert('Error: ' + error.message);
} finally {
setLoading(false);
}
};



// Function to open allocation management
const openAllocationManagement = async (inventoryItem) => {
try {
setLoading(true);
setAllocationManagementInventory(inventoryItem);

// Fetch allocations for this inventory
const response = await window.apicall(`/inventory/${inventoryItem.id}/allocations`);

if (response.error) {
throw new Error(response.error);
}

setCurrentAllocations(response.data.allocations);
setShowAllocationManagement(true);

} catch (error) {
console.error('Error fetching allocations:', error);
alert('Error fetching allocations: ' + error.message);
} finally {
setLoading(false);
}
};



// Function to unallocate tickets
const handleUnallocate = async (allocationId, ticketsToReturn) => {
if (!confirm(`Are you sure you want to unallocate ${ticketsToReturn} tickets?`)) {
return;
}

try {
setLoading(true);

const response = await window.apicall(`/inventory/${allocationManagementInventory.id}/allocations/${allocationId}`, {
method: 'DELETE'
});

if (response.error) {
throw new Error(response.error);
}

// Refresh allocations
await openAllocationManagement(allocationManagementInventory);

// Update inventory in main list
setInventory(prev => 
prev.map(item => 
item.id === allocationManagementInventory.id 
? { ...item, available_tickets: response.new_available_tickets }
: item
)
);

alert(`Successfully unallocated ${ticketsToReturn} tickets`);

} catch (error) {
console.error('Error unallocating tickets:', error);
alert('Error unallocating tickets: ' + error.message);
} finally {
setLoading(false);
}
};



// ADD this enhanced order approval function
const handleEnhancedOrderApproval = async (orderId, action, notes = '') => {
if (!window.hasPermission('orders', 'approve')) {
alert('You do not have permission to approve orders');
return;
}

setLoading(true);

try {
const newStatus = action === 'approve' ? 'approved' : 'rejected';

setOrders(prev => 
prev.map(order => {
if (order.id === orderId) {
const updatedOrder = { 
...order, 
status: newStatus, 
approved_date: new Date().toISOString().split('T')[0],
approval_notes: notes,
approved_by: user.name
};



// Generate GST invoice if approved
if (action === 'approve' && order.requires_gst_invoice) {
const invoiceNumber = 'STTS/INV/' + (new Date().getFullYear()) + '/' + (String(Date.now()).slice(-6));

const newInvoice = {
id: Date.now(),
invoice_number: invoiceNumber,
order_id: orderId,
order_number: order.order_number,
client_name: order.legal_name || order.client_name,
client_email: order.client_email,

// GST Details
gstin: order.gstin,
legal_name: order.legal_name,
category_of_sale: order.category_of_sale,
type_of_sale: order.type_of_sale,
registered_address: order.registered_address,
indian_state: order.indian_state,
is_outside_india: order.is_outside_india,

// Invoice calculation
invoice_items: order.invoice_items,
base_amount: order.base_amount,
gst_calculation: order.gst_calculation,
total_tax: order.total_tax,
final_amount: order.final_amount,

invoice_date: new Date().toISOString().split('T')[0],
due_date: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
status: 'generated',
generated_by: user.name
};



setInvoices(prev => [...prev, newInvoice]);
updatedOrder.invoice_id = newInvoice.id;
updatedOrder.invoice_number = invoiceNumber;
}

return updatedOrder;
}
return order;
})
);

setLoading(false);
alert(action === 'approve' 
? 'Order approved successfully! GST Invoice has been generated.' 
: 'Order rejected successfully.'
);
} catch (error) {
setLoading(false);
alert('Failed to update order status');
}
};



// ADD this GST invoice preview function
const openInvoicePreview = (invoice) => {
setCurrentInvoice(invoice);
setShowInvoicePreview(true);
};



// Enhanced GST and TCS Calculation Preview Function
const renderEnhancedGSTCalculationPreview = () => {
  // ADD: Calculate invoiceTotal first
  const invoiceTotal = paymentData.invoice_items?.reduce((sum, item) => 
    sum + ((item.quantity || 0) * (item.rate || 0)), 0
  ) || 0;
  
  const baseAmount = window.getBaseAmount(paymentData);
  const calculation = calculateGSTAndTCS(baseAmount, paymentData);
  const isIntraState = paymentData.indian_state === 'Haryana' && !paymentData.is_outside_india;
  const advanceAmount = parseFloat(paymentData.advance_amount) || 0;
  const isReceivablePayment = paymentData.from_receivable || paymentData.payment_post_service;

  // CALCULATE: Final amount with custom TCS rate
  const finalAmount = baseAmount + calculation.gst.total + 
    (calculation.tcs.applicable ? (baseAmount * (paymentData.tcs_rate || calculation.tcs.rate)) / 100 : 0);

  return React.createElement('div', { className: 'mb-6 p-4 bg-gray-50 rounded-lg' },
    React.createElement('h3', { className: 'text-lg font-semibold text-gray-800 mb-4' }, 
      'üßÆ Enhanced Tax Calculation Preview'
    ),
    React.createElement('div', { className: 'grid grid-cols-1 md:grid-cols-2 gap-6' },

      // Left Column - Basic Amounts
      React.createElement('div', { className: 'space-y-3' },
        React.createElement('h4', { className: 'font-medium text-gray-700 border-b pb-2' }, 'Base Amounts'),
        React.createElement('div', { className: 'space-y-2 text-sm' },
          React.createElement('div', { className: 'flex justify-between' },
            React.createElement('span', null, 'Invoice Total:'),
            React.createElement('span', { className: 'font-medium' }, 
              (paymentData.payment_currency || 'INR'), ' ', invoiceTotal.toFixed(2)
            )
          ),
          paymentData.type_of_sale === 'Service Fee' && 
          React.createElement('div', { className: 'flex justify-between border-t pt-2' },
            React.createElement('span', null, 'Service Fee:'),
            React.createElement('span', { className: 'font-medium' }, 
              (paymentData.payment_currency || 'INR'), ' ', (parseFloat(paymentData.service_fee_amount) || 0).toFixed(2)
            )
          ),
          React.createElement('div', { className: 'flex justify-between font-medium border-t pt-2' },
            React.createElement('span', null, 'Taxable Amount:'),
            React.createElement('span', null, 
              (paymentData.payment_currency || 'INR'), ' ', baseAmount.toFixed(2)
            )
          )
        )
      ),

      // Right Column - Tax Breakdown
      React.createElement('div', { className: 'space-y-3' },
        React.createElement('h4', { className: 'font-medium text-gray-700 border-b pb-2' }, 'Tax Breakdown'),
        React.createElement('div', { className: 'space-y-2 text-sm' },

          // GST Section
          calculation.gst.applicable ? [
            isIntraState ? [
              React.createElement('div', { key: 'cgst', className: 'flex justify-between' },
                React.createElement('span', null, `CGST (${calculation.gst.rate/2}%):`),
                React.createElement('span', { className: 'font-medium' }, 
                  (paymentData.payment_currency || 'INR'), ' ', calculation.gst.cgst.toFixed(2)
                )
              ),
              React.createElement('div', { key: 'sgst', className: 'flex justify-between' },
                React.createElement('span', null, `SGST (${calculation.gst.rate/2}%):`),
                React.createElement('span', { className: 'font-medium' }, 
                  (paymentData.payment_currency || 'INR'), ' ', calculation.gst.sgst.toFixed(2)
                )
              )
            ] : React.createElement('div', { key: 'igst', className: 'flex justify-between' },
              React.createElement('span', null, `IGST (${calculation.gst.rate}%):`),
              React.createElement('span', { className: 'font-medium' }, 
                (paymentData.payment_currency || 'INR'), ' ', calculation.gst.igst.toFixed(2)
              )
            )
          ] : React.createElement('div', { key: 'no-gst', className: 'flex justify-between text-gray-500' },
            React.createElement('span', null, 'GST:'),
            React.createElement('span', null, 'Not Applicable')
          ),

          // TCS Section with dynamic rate
          calculation.tcs.applicable ? 
          React.createElement('div', { className: 'flex justify-between text-yellow-700' },
            React.createElement('span', null, `TCS (${paymentData.tcs_rate || calculation.tcs.rate}%):`),
            React.createElement('span', { className: 'font-medium' }, 
              paymentData.payment_currency || 'INR', ' ', 
              ((baseAmount * (paymentData.tcs_rate || calculation.tcs.rate)) / 100).toFixed(2)
            )
          ) : React.createElement('div', { className: 'flex justify-between text-gray-500' },
            React.createElement('span', null, 'TCS:'),
            React.createElement('span', null, 'Not Applicable')
          ),

          // Final Amount with custom TCS rate
          React.createElement('div', { className: 'flex justify-between text-lg font-bold border-t pt-2 mt-2' },
            React.createElement('span', null, 'Final Amount:'),
            React.createElement('span', null, 
              paymentData.payment_currency || 'INR', ' ', finalAmount.toFixed(2)
            )
          ),

          // Payment Information
          !isReceivablePayment && React.createElement('div', { className: 'flex justify-between border-t pt-2' },
            React.createElement('span', { className: 'font-semibold' }, 'Advance Received:'),
            React.createElement('span', { className: 'font-semibold text-blue-600' }, 
              (paymentData.payment_currency || 'INR'), ' ', advanceAmount.toFixed(2)
            )
          ),
          !isReceivablePayment && React.createElement('div', { className: 'flex justify-between' },
            React.createElement('span', { className: 'font-bold' }, 'Balance Due:'),
            React.createElement('span', { className: 'font-bold text-orange-600' }, 
              (paymentData.payment_currency || 'INR'), ' ', (finalAmount - advanceAmount).toFixed(2)
            )
          ),
          isReceivablePayment && React.createElement('div', { className: 'flex justify-between border-t pt-2' },
            React.createElement('span', { className: 'font-bold' }, 'Payment Being Collected:'),
            React.createElement('span', { className: 'font-bold text-green-600' }, 
              (paymentData.payment_currency || 'INR'), ' ', advanceAmount.toFixed(2)
            )
          )
        )
      )
    )
  );
}; 

const handleOrderApproval = async (orderId, action) => {
if (!window.hasPermission('orders', 'approve')) {
alert('You do not have permission to approve orders');
return;
}

setLoading(true);

try {
const order = orders.find(o => o.id === orderId);
console.log('Approving order:', order);

// If rejecting, ask for notes
let notes = '';
if (action === 'reject') {
notes = prompt('Please provide rejection reason:');
if (!notes) {
setLoading(false);
return;
}
}

const newStatus = action === 'approve' ? 'approved' : 'rejected';
let invoiceNumber = null;
let invoiceId = null;

// Generate GST invoice if approved
if (action === 'approve' && (order.requires_gst_invoice || order.gstin)) {
invoiceNumber = 'STTS/INV/' + (new Date().getFullYear()) + '/' + (String(Date.now()).slice(-6));
invoiceId = Date.now();

const newInvoice = {
id: invoiceId,
invoice_number: invoiceNumber,
order_id: orderId,
order_number: order.order_number,
client_name: order.legal_name || order.client_name,
client_email: order.client_email,

// GST Details
gstin: order.gstin,
legal_name: order.legal_name,
category_of_sale: order.category_of_sale,
type_of_sale: order.type_of_sale,
registered_address: order.registered_address,
indian_state: order.indian_state,
is_outside_india: order.is_outside_india,

// Invoice calculation
invoice_items: order.invoice_items,
base_amount: order.base_amount,
gst_calculation: order.gst_calculation,
total_tax: order.total_tax,
final_amount: order.final_amount || order.total_amount,

invoice_date: new Date().toISOString().split('T')[0],
due_date: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
status: 'generated',
generated_by: user.name
};



setInvoices(prev => [...prev, newInvoice]);
}

// Update order in backend with all necessary fields including invoice info
const updateData = {
status: newStatus,
approved_date: new Date().toISOString(),
approval_notes: notes,
approved_by: user.name,
payment_status: order.payment_status || 'pending'
};



// Add invoice fields if invoice was generated
if (invoiceNumber && invoiceId) {
updateData.invoice_number = invoiceNumber;
updateData.invoice_id = invoiceId;
}

// Send update to backend
await window.apicall('/orders/' + orderId, {
method: 'PUT',
body: JSON.stringify(updateData)
});

// CREATE RECEIVABLES FOR PARTIAL/POST-SERVICE PAYMENTS
if (action === 'approve') {
console.log('Order approved, checking if receivable needed...');
console.log('Order type:', order.order_type);
console.log('Payment status:', order.payment_status);

// Check if it's a post-service payment or partial payment
const isPostService = order.order_type === 'payment_post_service' || 
order.lead_status === 'payment_post_service';
const isPartialPayment = order.payment_status === 'partial' || 
(order.amount_paid && order.amount_paid < order.total_amount);

console.log('Is post service:', isPostService);
console.log('Is partial payment:', isPartialPayment);

if (isPostService || isPartialPayment) {
// Calculate pending amount
const paidAmount = parseFloat(order.amount_paid || 0);
const totalAmount = parseFloat(order.total_amount || order.final_amount || 0);
const pendingAmount = totalAmount - paidAmount;

console.log('Total amount:', totalAmount);
console.log('Paid amount:', paidAmount);
console.log('Pending amount:', pendingAmount);

if (pendingAmount > 0) {
// Create receivable entry
const receivableData = {
order_id: orderId,
order_number: order.order_number,
client_name: order.client_name || order.lead_name,
client_email: order.client_email,
client_phone: order.client_phone,
invoice_number: invoiceNumber || order.invoice_number || 'INV-' + orderId,
expected_amount: pendingAmount,
amount_paid: paidAmount,
balance_amount: pendingAmount,
due_date: order.expected_payment_date || 
new Date(Date.now() + 30*24*60*60*1000).toISOString(),
payment_terms: order.payment_terms || 'Net 30',
assigned_to: order.assigned_to || order.created_by,
status: 'pending',
created_date: new Date().toISOString(),
created_by: user.name,
is_post_service: isPostService,
event_date: order.event_date,
event_name: order.event_name
};



console.log('Creating receivable with data:', receivableData);

try {
const receivableResponse = await window.apicall('/receivables', {
method: 'POST',
body: JSON.stringify(receivableData)
});
console.log('Receivable created successfully:', receivableResponse);

// Update local receivables state if it exists
if (typeof setReceivables === 'function') {
setReceivables(prev => [...prev, receivableResponse.data || receivableResponse]);
}
} catch (error) {
console.error('Failed to create receivable:', error);
alert('Order approved but failed to create receivable. Please create it manually.');
}
}
}
}

// Update local state
setOrders(prev => 
prev.map(o => o.id === orderId ? { ...o, ...updateData } : o)
);

// Refresh financial data if user has permission
if (window.hasPermission('finance', 'read')) {
await fetchFinancialData();
}

setLoading(false);

// Custom alert message based on what happened
let alertMessage = action === 'approve' ? 'Order approved successfully!' : 'Order rejected successfully.';
if (action === 'approve' && invoiceNumber) {
alertMessage += ' GST Invoice has been generated.';
}
alert(alertMessage);

} catch (error) {
console.error('Order approval error:', error);
setLoading(false);
alert('Failed to update order status');
}
};

const handleFormSubmit = async (e) => {
e.preventDefault();
setLoading(true);

try {
if (showEditForm) {
// Update lead via API
const response = await window.apicall('/leads/' + (currentLead.id), {
method: 'PUT',
body: JSON.stringify(formData)
});
setLeads(prev => prev.map(lead => 
lead.id === currentLead.id ? response.data : lead
));

// ‚úÖ ADD: Refresh assignment rules after lead update
if (window.refreshAssignmentRules && typeof window.refreshAssignmentRules === 'function') {
try {
await window.refreshAssignmentRules();
console.log('‚úÖ Assignment rules refreshed after lead update');
} catch (refreshError) {
console.log('‚ö†Ô∏è Assignment rules refresh failed (non-critical):', refreshError);
}
}

alert('Lead updated successfully!');

} else if (showEditInventoryForm) {
// Add debug logging
console.log('=== FRONTEND INVENTORY UPDATE DEBUG (Regular Form) ===');
console.log('Inventory ID being updated:', currentInventory.id);
console.log('Complete form data being sent:', formData);
console.log('Payment fields specifically:', {
totalPurchaseAmount: formData.totalPurchaseAmount,
amountPaid: formData.amountPaid,
paymentStatus: formData.paymentStatus,
supplierName: formData.supplierName,
supplierInvoice: formData.supplierInvoice
});

// Update inventory via API
const response = await window.apicall('/inventory/' + (currentInventory.id), {
method: 'PUT',
body: JSON.stringify(formData)
});

console.log('Backend response:', response);

setInventory(prev => prev.map(item => 
item.id === currentInventory.id ? response.data : item
));
alert('Inventory updated successfully!');
} else {
// Create new items
switch (currentForm) {
case 'lead':
const leadResponse = await window.apicall('/leads', {
method: 'POST',
body: JSON.stringify({
...formData,
status: 'unassigned',
created_by: user.name,
created_date: new Date().toISOString()
})
});
setLeads(prev => [...prev, leadResponse.data]);

// ‚úÖ ADD: Refresh assignment rules after new lead creation
if (window.refreshAssignmentRules && typeof window.refreshAssignmentRules === 'function') {
try {
await window.refreshAssignmentRules();
console.log('‚úÖ Assignment rules refreshed after lead creation');
} catch (refreshError) {
console.log('‚ö†Ô∏è Assignment rules refresh failed (non-critical):', refreshError);
}
}

alert('Lead added successfully!');
break;

case 'inventory':
console.log('Sending inventory data:', formData);
const invResponse = await window.apicall('/inventory', {
method: 'POST',
body: JSON.stringify({
...formData,
created_by: user.name,
created_date: new Date().toISOString()
})
});
console.log("Inventory API Response:", invResponse);
setInventory(prev => [...prev, invResponse.data]);
alert('Inventory added successfully!');

// Create payable entry if payment is pending or partial
if (formData.paymentStatus === 'pending' || formData.paymentStatus === 'partial') {
try {
const pendingAmount = parseFloat(formData.totalPurchaseAmount || 0) - parseFloat(formData.amountPaid || 0);

if (pendingAmount > 0) {
const payableData = {
supplierName: formData.supplierName || 'Unknown Supplier',
invoiceNumber: formData.supplierInvoice || 'INV-' + (Date.now()),
amount: pendingAmount,
dueDate: formData.paymentDueDate || new Date(Date.now() + 30*24*60*60*1000).toISOString().split('T')[0], // 30 days from now
description: 'Inventory purchase: ' + (formData.event_name || 'Event') + ' - ' + (formData.category_of_ticket || 'Tickets'),
inventoryId: invResponse.data?.id || invResponse.id,
status: 'pending'
};



console.log('Creating payable for inventory:', payableData);

const payableResponse = await window.apicall('/finance/payables', {
method: 'POST',
body: JSON.stringify(payableData)
});

console.log('Payable created:', payableResponse);
}
} catch (payableError) {
console.error('Failed to create payable:', payableError);
// Don't show error to user - payable creation is secondary
}
}
break;

case 'order':
console.log('Creating order with data:', JSON.stringify(orderData, null, 2));
console.log('Key fields:', {
event_name: orderData.event_name,
tickets_allocated: orderData.tickets_allocated,
ticket_category: orderData.ticket_category,
total_amount: orderData.total_amount
});
const orderResponse = await window.apicall('/orders', {
method: 'POST',
body: JSON.stringify({
...formData,
order_number: 'ORD-' + (Date.now()),
status: 'pending_approval',
requires_gst_invoice: true,
total_amount: formData.tickets_allocated * formData.price_per_ticket,
created_by: user.name,
created_date: new Date().toISOString()
})
});
setOrders(prev => [...prev, orderResponse]);
alert('Order created successfully!');
break;
}
}

closeForm();
} catch (error) {
alert('Operation failed: ' + error.message);
} finally {
setLoading(false);
}
};



const handleDeleteLead = async (leadId) => {
if (!confirm('Are you sure you want to delete this lead?')) return;

try {
await window.apicall('/leads/' + (leadId), { method: 'DELETE' });
setLeads(prev => prev.filter(lead => lead.id !== leadId));

// ‚úÖ ADD: Refresh assignment rules after lead deletion
if (window.refreshAssignmentRules && typeof window.refreshAssignmentRules === 'function') {
try {
await window.refreshAssignmentRules();
console.log('‚úÖ Assignment rules refreshed after lead deletion');
} catch (refreshError) {
console.log('‚ö†Ô∏è Assignment rules refresh failed (non-critical):', refreshError);
}
}

alert('Lead deleted successfully!');
} catch (error) {
alert('Failed to delete lead: ' + error.message);
}
};

const togglePremiumStatus = async (leadId, isPremium) => {
  try {
    setLoading(true);
    
    const response = await window.apicall(`/leads/${leadId}`, {
      method: 'PUT',
      body: JSON.stringify({ is_premium: isPremium })
    });
    
    // Update the leads list
    setLeads(prev => prev.map(lead => 
      lead.id === leadId ? { ...lead, is_premium: isPremium } : lead
    ));
    
    // Update currentLead if viewing the lead details
    if (showLeadDetail && currentLead?.id === leadId) {
      setCurrentLead(prev => ({ ...prev, is_premium: isPremium }));
    }
    
    console.log(`‚úÖ Lead ${leadId} premium status updated to ${isPremium}`);
    
  } catch (error) {
    console.error('Error updating premium status:', error);
    alert('Failed to update premium status: ' + error.message);
  } finally {
    setLoading(false);
  }
};

const handleDeleteInventory = async (inventoryId) => {
if (!confirm('Are you sure you want to delete this event?')) return;

try {
await window.apicall('/inventory/' + (inventoryId), { method: 'DELETE' });
setInventory(prev => prev.filter(item => item.id !== inventoryId));
alert('Event deleted successfully!');
} catch (error) {
alert('Failed to delete event: ' + error.message);
}
};



// Assignment with permission check
const handleAssignLead = async (e) => {
e.preventDefault();

console.log('\nüîç === ASSIGNMENT DEBUGGING START ===');
console.log('1. Form Data:', formData);
console.log('3. Current dropdown value (assigned_to):', formData.assigned_to);

// Check what type of value we have
if (formData.assigned_to) {
if (formData.assigned_to.includes('@')) {
console.log('‚úÖ Value contains @ - appears to be an email');
} else {
console.log('‚ùå Value does NOT contain @ - appears to be a name');
}
}
setLoading(true);

try {
const response = await window.apicall('/leads/' + (currentLead.id), {
method: 'PUT',
body: JSON.stringify({
status: 'assigned',
assigned_to: formData.assigned_to,
assignment_date: new Date().toISOString()
})
});

setLeads(prev => prev.map(lead => 
lead.id === currentLead.id ? response.data : lead
));

// Update currentLead if viewing the assigned lead
if (showLeadDetail && currentLead?.id === response.data.id) {
setCurrentLead(response.data);
}

// ‚úÖ ADD: Refresh assignment rules after lead assignment
if (window.refreshAssignmentRules && typeof window.refreshAssignmentRules === 'function') {
try {
await window.refreshAssignmentRules();
console.log('‚úÖ Assignment rules refreshed after lead assignment');
} catch (refreshError) {
console.log('‚ö†Ô∏è Assignment rules refresh failed (non-critical):', refreshError);
}
}

alert('Lead assigned successfully!');
closeForm();
} catch (error) {
alert('Assignment failed: ' + error.message);
} finally {
setLoading(false);
}
};



// Payment submission with permission check
const handlePaymentSubmit = async (e) => {
e.preventDefault();

// ADD THESE DEBUG LINES
console.log('=== PAYMENT SUBMIT DEBUG ===');
console.log('Full paymentData:', paymentData);
console.log('GST Certificate:', paymentData.gst_certificate);
console.log('PAN Card:', paymentData.pan_card);

if (!window.hasPermission('leads', 'write')) {
alert('You do not have permission to manage payments');
return;
}

setLoading(true);

try {
await new Promise(resolve => setTimeout(resolve, 1000));

// Check if this is a post-service payment
if (paymentData.payment_post_service && paymentData.receivable_id) {
// Update receivable status
setReceivables(prev => 
prev.map(r => 
r.id === paymentData.receivable_id 
? { ...r, status: 'paid', paid_date: new Date().toISOString().split('T')[0] }
: r
)
);

// Update order payment status
const order = orders.find(o => o.lead_id === currentLead.id && o.payment_type === 'post_service');
if (order) {
setOrders(prev => 
prev.map(o => 
o.id === order.id 
? { ...o, payment_received: true, payment_date: new Date().toISOString().split('T')[0] }
: o
)
);
}
}

// FIXED: Use helper function and correct GST calculation
const baseAmount = window.getBaseAmount(paymentData);
const isIntraState = paymentData.indian_state === 'Haryana' && !paymentData.is_outside_india;

// FIXED: Use the correct calculateGSTAndTCS function
const calculation = calculateGSTAndTCS(baseAmount, paymentData);
const totalTax = calculation.gst.total;
const finalAmount = calculation.finalAmount;

// Update lead with payment details
const updatedLead = {
...currentLead,
payment_details: {
...paymentData,
advance_amount: parseFloat(paymentData.advance_amount) || 0,
base_amount: baseAmount,
gst_calculation: calculation.gst,
tcs_calculation: calculation.tcs,
total_tax: totalTax,
final_amount: finalAmount
},
payment_received_date: new Date().toISOString().split('T')[0]
};



// Update local state with payment details
setLeads(prev => 
prev.map(lead => 
lead.id === currentLead.id ? updatedLead : lead
)
);

console.log('=== REACHED ORDER CREATION SECTION ===');

// Check if order already exists for this lead
const existingOrder = orders.find(order => 
order.lead_id === currentLead.id && 
order.status !== 'rejected'
);

if (existingOrder) {
// UPDATE existing order
console.log('Updating order with GST details:', {
gstin: paymentData.gstin,
legal_name: paymentData.legal_name,
registered_address: paymentData.registered_address,
category_of_sale: paymentData.category_of_sale,
type_of_sale: paymentData.type_of_sale,
indian_state: paymentData.indian_state
});

// FIXED: Correct API call format
const updateResponse = await window.apicall(`/orders/${existingOrder.id}`, {
method: 'PUT',
body: JSON.stringify({
// Start with existing order data
...existingOrder,

// Payment fields (will override existing)
payment_amount: paymentData.advance_amount,
payment_method: paymentData.payment_method,
transaction_id: paymentData.transaction_id,
payment_date: paymentData.payment_date,
payment_proof: paymentData.payment_proof,
payment_status: 'paid',

// Amount fields
amount: paymentData.advance_amount,
total_amount: existingOrder.total_amount || existingOrder.final_amount,
final_amount: existingOrder.final_amount || existingOrder.total_amount,

// GST fields - IMPORTANT: These will override existing values
legal_name: paymentData.legal_name || existingOrder.legal_name,
gstin: paymentData.gstin || existingOrder.gstin,
registered_address: paymentData.registered_address || existingOrder.registered_address,
category_of_sale: paymentData.category_of_sale || existingOrder.category_of_sale,
type_of_sale: paymentData.type_of_sale || existingOrder.type_of_sale,
indian_state: paymentData.indian_state || existingOrder.indian_state,
is_outside_india: paymentData.is_outside_india || existingOrder.is_outside_india,
gst_certificate: paymentData.gst_certificate || existingOrder.gst_certificate,
pan_card: paymentData.pan_card || existingOrder.pan_card,

// Invoice details
invoice_items: paymentData.invoice_items || existingOrder.invoice_items,
base_amount: baseAmount,
gst_calculation: calculation.gst,
tcs_calculation: calculation.tcs,
total_tax: totalTax,
final_amount: finalAmount,
gst_rate: calculation.gst.rate,
service_fee_amount: paymentData.service_fee_amount || existingOrder.service_fee_amount,

// Clear post-service fields if this was a post-service order
expected_amount: null,
expected_payment_date: null,
order_type: 'standard',

// Metadata
notes: paymentData.notes || existingOrder.notes,
updated_date: new Date().toISOString(),
updated_by: user.name
})
});

console.log('Order update response:', updateResponse);

// FIXED: Handle response structure properly
const updatedOrderData = updateResponse.data || updateResponse;
setOrders(prev => prev.map(o => 
o.id === existingOrder.id ? {...o, ...updatedOrderData} : o
));

// IMPORTANT: Update lead status for payment_post_service to payment_received
if (paymentData.payment_post_service) {
await updateLeadStatus(currentLead.id, 'payment_received');
}

// Update lead status if this is payment collection after service
if (paymentData.payment_post_service || currentLead.status === 'payment_post_service') {
await updateLeadStatus(currentLead.id, 'payment_received');
}

// Handle receivable updates/deletion if payment is from receivables
if (paymentData.from_receivable && paymentData.receivable_id) {
console.log('Processing receivable payment...');
console.log('Receivable ID:', paymentData.receivable_id);
console.log('Original receivable amount:', paymentData.receivable_amount);

// For receivable payments, the advance_amount field contains the actual payment amount
const paidAmount = parseFloat(paymentData.advance_amount) || 0;
const receivableAmount = parseFloat(paymentData.receivable_amount) || 0;

console.log('Payment being collected:', paidAmount);
console.log('Original receivable amount:', receivableAmount);
console.log('Calculated invoice amount with GST:', finalAmount);

if (paidAmount >= receivableAmount) {
// Full payment - delete the receivable
try {
await window.apicall(`/receivables/${paymentData.receivable_id}`, {
method: 'DELETE'
});

// Remove from local state
if (typeof setReceivables === 'function') {
setReceivables(prev => prev.filter(r => r.id !== paymentData.receivable_id));
}
console.log('Receivable deleted after full payment');
} catch (error) {
console.error('Failed to delete receivable:', error);
}
} else {
// Partial payment - ask user what to do
const remainingAmount = receivableAmount - paidAmount;
const userChoice = confirm(
`You are receiving only partial payment of ‚Çπ${paidAmount.toFixed(2)} out of ‚Çπ${receivableAmount.toFixed(2)} (inclusive of GST).\n\n` +
`Remaining balance: ‚Çπ${remainingAmount.toFixed(2)}\n\n` +
`Click OK to update this receivable with the balance payment.\n` +
`Click Cancel to mark this receivable as closed and update the order value.`
);

if (userChoice) {
// Update receivable with remaining amount
try {
await window.apicall(`/receivables/${paymentData.receivable_id}`, {
method: 'PUT',
body: JSON.stringify({
balance_amount: remainingAmount,
amount: remainingAmount,
expected_amount: remainingAmount,
partial_payment_received: paidAmount,
last_payment_date: new Date().toISOString(),
updated_date: new Date().toISOString()
})
});

// Update local state
if (typeof setReceivables === 'function') {
setReceivables(prev => prev.map(r => 
r.id === paymentData.receivable_id 
? { ...r, balance_amount: remainingAmount, amount: remainingAmount }
: r
));
}
alert(`Receivable updated with remaining balance of ‚Çπ${remainingAmount.toFixed(2)}`);
} catch (error) {
console.error('Failed to update receivable:', error);
alert('Failed to update receivable with remaining balance');
}
} else {
// Close receivable and update order total
try {
// Delete the receivable
await window.apicall(`/receivables/${paymentData.receivable_id}`, {
method: 'DELETE'
});

// FIXED: Use existingOrder.id instead of undefined existingOrderId
await window.apicall(`/orders/${existingOrder.id}`, {
method: 'PUT',
body: JSON.stringify({
total_amount: paidAmount,
original_amount: receivableAmount,
amount_adjusted: true,
adjustment_reason: 'Partial payment accepted',
updated_date: new Date().toISOString()
})
});

// Update local states
if (typeof setReceivables === 'function') {
setReceivables(prev => prev.filter(r => r.id !== paymentData.receivable_id));
}
setOrders(prev => prev.map(o => 
o.id === existingOrder.id 
? { ...o, total_amount: paidAmount, amount_adjusted: true }
: o
));

alert(`Receivable closed. Order value updated to ‚Çπ${paidAmount.toFixed(2)}`);
} catch (error) {
console.error('Failed to close receivable:', error);
alert('Failed to close receivable');
}
}
}
}

// FIXED: Refresh orders data to ensure updated order shows correctly
try {
console.log('Refreshing orders after update...');
const freshOrdersResponse = await window.apicall('/orders');
const freshOrders = freshOrdersResponse.data || freshOrdersResponse || [];
setOrders(freshOrders);
console.log('Orders refreshed after update:', freshOrders.length);
} catch (refreshError) {
console.error('Failed to refresh orders after update:', refreshError);
}

setLoading(false);
alert(paymentData.payment_post_service 
? 'Payment collected successfully! Invoice can now be generated.' 
: 'Payment updated successfully!'
);
closeForm();
return; // Exit here, don't create new order
}

// ENHANCED: Create NEW order after successful payment
const orderData = {
order_number: 'ORD-' + (Date.now()),
lead_id: currentLead.id,
lead_name: currentLead.name,
client_name: currentLead.name,
lead_email: currentLead.email,
client_email: currentLead.email,
lead_phone: currentLead.phone,
client_phone: currentLead.phone,
legal_name: paymentData.legal_name || currentLead.legal_name,
gstin: paymentData.gstin,
registered_address: paymentData.registered_address,
category_of_sale: paymentData.category_of_sale,
type_of_sale: paymentData.type_of_sale,
indian_state: paymentData.indian_state,
is_outside_india: paymentData.is_outside_india || false,
payment_amount: paymentData.advance_amount,
payment_method: paymentData.payment_method,
transaction_id: paymentData.transaction_id,
payment_date: paymentData.payment_date,
payment_proof: paymentData.payment_proof,
notes: paymentData.notes,
gst_rate: calculation.gst.rate,
service_fee_amount: paymentData.service_fee_amount,
invoice_items: paymentData.invoice_items,
status: 'pending_approval',
requires_gst_invoice: true,

// Add the missing fields by extracting from invoice items
event_name: paymentData.invoice_items?.[0]?.description || currentLead?.lead_for_event || 'General Event',
event_date: paymentData.payment_date || new Date().toISOString().split('T')[0],
tickets_allocated: parseInt(paymentData.invoice_items?.[0]?.quantity) || 1,
ticket_category: paymentData.category_of_sale || 'General',
price_per_ticket: paymentData.invoice_items?.[0]?.rate || 0,
total_amount: baseAmount,
base_amount: baseAmount,
gst_calculation: calculation.gst,
tcs_calculation: calculation.tcs,
total_tax: totalTax,
final_amount: finalAmount,

// CRITICAL: Add required fields that might be missing
created_date: new Date().toISOString(),
created_at: new Date().toISOString(),
created_by: user.name || user.email || 'System',
payment_currency: paymentData.payment_currency || 'INR',
payment_status: 'paid',
order_type: 'standard'
};



console.log('=== ENHANCED ORDER CREATION DEBUG ===');
console.log('Order data to create:', JSON.stringify(orderData, null, 2));
console.log('Order data size:', JSON.stringify(orderData).length, 'characters');

let orderResponse;
try {
console.log('=== CREATING ORDER WITH FIXED API CALL ===');

// FIXED: Use correct window.apicall format
orderResponse = await window.apicall('/orders', {
method: 'POST',
body: JSON.stringify(orderData)
});

console.log('=== ORDER CREATION RESPONSE ===');
console.log('Response:', orderResponse);
console.log('Response type:', typeof orderResponse);
console.log('Response keys:', Object.keys(orderResponse || {}));

// CRITICAL CHECK: Validate this is actually a created order, not a list
if (Array.isArray(orderResponse)) {
console.error('‚ùå API RETURNED ARRAY INSTEAD OF CREATED ORDER');
console.error('This means the POST request was treated as GET');
throw new Error('API returned orders list instead of creating new order. Check backend routes.');
}

if (orderResponse && Array.isArray(orderResponse.data)) {
console.error('‚ùå API RETURNED ORDERS LIST INSTEAD OF CREATED ORDER');
console.error('Response data is array of length:', orderResponse.data.length);
throw new Error('API returned existing orders list instead of creating new order. Backend routing issue.');
}

// Check if we got a valid order back
const createdOrder = orderResponse.data || orderResponse;
if (!createdOrder || (!createdOrder.id && !createdOrder.order_number)) {
console.error('‚ùå INVALID ORDER RESPONSE');
console.error('Expected: order object with id or order_number');
console.error('Received:', createdOrder);
throw new Error('Server did not return a valid created order');
}

console.log('‚úÖ ORDER CREATED SUCCESSFULLY');
console.log('Created order ID:', createdOrder.id);
console.log('Created order number:', createdOrder.order_number);
console.log('Created order status:', createdOrder.status);

} catch (error) {
console.error('=== ORDER CREATION FAILED ===');
console.error('Error type:', error.constructor.name);
console.error('Error message:', error.message);
console.error('Full error:', error);

// Specific error messages for common issues
if (error.message.includes('orders list')) {
alert('‚ùå Backend Issue: The API is returning existing orders instead of creating a new one.\n\nThis indicates a problem with your backend routing for POST /orders.\n\nPlease check your backend orders.js route file.');
} else {
alert(`‚ùå Order creation failed: ${error.message}\n\nCheck console for full details.`);
}

setLoading(false);
return;
}

console.log('=== VERIFYING ORDER IN BACKEND ===');

// Wait a moment then verify
await new Promise(resolve => setTimeout(resolve, 2000));

try {
console.log('Verifying order was actually saved...');

// FIXED: Use correct window.apicall format for verification
const verifyResponse = await window.apicall('/orders');
const allOrders = verifyResponse.data || verifyResponse;

console.log('Total orders in backend after creation:', allOrders.length);
console.log('Previous count was: 3');

if (allOrders.length > 3) {
console.log('‚úÖ ORDER COUNT INCREASED - SUCCESS!');

// Find our new order
const newOrder = allOrders.find(o => 
o.lead_id === currentLead.id || 
o.order_number === orderData.order_number
);

if (newOrder) {
console.log('‚úÖ FOUND OUR NEW ORDER:', newOrder.id);
console.log('New order details:', newOrder);
}

// Update local state with all fresh orders
setOrders(allOrders);
console.log('‚úÖ LOCAL STATE UPDATED');

} else {
console.error('‚ùå ORDER COUNT DID NOT INCREASE');
console.error('Expected more than 3 orders, got:', allOrders.length);
alert('‚ö†Ô∏è Order creation may have failed. The order count did not increase.');
}

} catch (verifyError) {
console.error('Failed to verify order creation:', verifyError);

// Fallback: try using window.apicall for refresh
try {
const fallbackResponse = await window.apicall('/orders');
const fallbackOrders = fallbackResponse.data || fallbackResponse || [];
setOrders(fallbackOrders);
console.log('Fallback refresh completed, orders:', fallbackOrders.length);
} catch (fallbackError) {
console.error('Fallback refresh also failed:', fallbackError);
}
}

// Update lead status
await updateLeadStatus(currentLead.id, 'payment_received');

setLoading(false);
alert(paymentData.payment_post_service 
? 'Payment collected successfully! Invoice can now be generated.' 
: 'Payment details submitted successfully! Order created and sent for finance approval.'
);
closeForm();

// Enhanced page refresh trigger
setTimeout(() => {
if (activeTab === 'orders') {
console.log('Triggering orders page refresh...');
// Force re-render of orders page
setActiveTab('dashboard');
setTimeout(() => setActiveTab('orders'), 100);
}

// Additional verification
setTimeout(() => {
console.log('=== FINAL VERIFICATION ===');
console.log('Orders in state after 3 seconds:', orders.length);
if (window.debugOrders) {
console.log('Running final API check...');
window.debugOrders().then(apiOrders => {
console.log('Final API check shows:', apiOrders.length, 'orders');
if (apiOrders.length > orders.length) {
console.log('‚ö†Ô∏è API has more orders than local state - refreshing...');
setOrders(apiOrders);
}
});
}
}, 3000);
}, 1000);

} catch (error) {
console.error('=== PAYMENT SUBMISSION ERROR ===');
console.error('Payment submission error:', error);
setLoading(false);
alert('Payment submission failed: ' + (error.message || 'Unknown error'));
}
};

const renderClientDetailModal = () => {
if (!showClientDetail || !selectedClient) return null;

const primaryLead = selectedClient.leads[0];
const sortedLeads = selectedClient.leads.sort((a, b) => 
new Date(a.date_of_enquiry || a.created_date) - new Date(b.date_of_enquiry || b.created_date)
);

return React.createElement('div', {
className: 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50',
onClick: (e) => {
if (e.target === e.currentTarget) {
setShowClientDetail(false);
setSelectedClient(null);
}
}
},
React.createElement('div', {
className: 'bg-white rounded-lg shadow-xl max-w-6xl w-full max-h-[90vh] overflow-hidden',
onClick: (e) => e.stopPropagation()
},
// Modal Header
React.createElement('div', { className: 'bg-gradient-to-r from-blue-600 to-blue-700 text-white p-6' },
React.createElement('div', { className: 'flex justify-between items-start' },
React.createElement('div', null,
React.createElement('h2', { className: 'text-2xl font-bold mb-2' }, 
'üë• Client Profile: ' + primaryLead.name
),
React.createElement('div', { className: 'flex flex-wrap gap-4 text-blue-100' },
React.createElement('span', null, 'üìû ' + primaryLead.phone),
React.createElement('span', null, 'üìß ' + primaryLead.email),
React.createElement('span', null, 'üè¢ ' + (primaryLead.company || 'No Company')),
React.createElement('span', null, 'üìç ' + (primaryLead.city_of_residence || 'Unknown') + ', ' + (primaryLead.country_of_residence || 'Unknown'))
)
),
React.createElement('button', {
onClick: () => {
setShowClientDetail(false);
setSelectedClient(null);
},
className: 'text-white hover:text-gray-200 text-2xl font-bold'
}, '√ó')
)
),

// Modal Content
React.createElement('div', { className: 'p-6 overflow-y-auto max-h-[calc(90vh-140px)]' },

// Client Summary Cards
React.createElement('div', { className: 'grid grid-cols-1 md:grid-cols-4 gap-4 mb-6' },
React.createElement('div', { className: 'bg-blue-50 border border-blue-200 rounded-lg p-4 text-center' },
React.createElement('div', { className: 'text-2xl font-bold text-blue-900' }, selectedClient.total_leads),
React.createElement('div', { className: 'text-sm text-blue-700' }, 'Total Leads'),
React.createElement('div', { className: 'text-xs text-blue-600 mt-1' }, 
selectedClient.total_leads > 1 ? 'Multi-lead client' : 'Single lead client'
)
),
React.createElement('div', { className: 'bg-green-50 border border-green-200 rounded-lg p-4 text-center' },
React.createElement('div', { className: 'text-2xl font-bold text-green-900' }, 
selectedClient.events.length
),
React.createElement('div', { className: 'text-sm text-green-700' }, 'Events Interested'),
React.createElement('div', { className: 'text-xs text-green-600 mt-1' }, 
selectedClient.events.slice(0, 2).join(', ') || 'None specified'
)
),
React.createElement('div', { className: 'bg-purple-50 border border-purple-200 rounded-lg p-4 text-center' },
React.createElement('div', { className: 'text-2xl font-bold text-purple-900' }, 
'‚Çπ' + (selectedClient.total_value || 0).toLocaleString()
),
React.createElement('div', { className: 'text-sm text-purple-700' }, 'Total Value'),
React.createElement('div', { className: 'text-xs text-purple-600 mt-1' }, 
'Across all leads'
)
),
React.createElement('div', { className: 'bg-orange-50 border border-orange-200 rounded-lg p-4 text-center' },
React.createElement('div', { className: 'text-2xl font-bold text-orange-900' }, 
Math.ceil((new Date() - new Date(selectedClient.first_contact)) / (1000 * 60 * 60 * 24))
),
React.createElement('div', { className: 'text-sm text-orange-700' }, 'Days as Client'),
React.createElement('div', { className: 'text-xs text-orange-600 mt-1' }, 
'Since first contact'
)
)
),

// Client Relationship Info
React.createElement('div', { className: 'bg-gray-50 border border-gray-200 rounded-lg p-4 mb-6' },
React.createElement('h3', { className: 'text-lg font-semibold text-gray-900 mb-3 flex items-center' },
React.createElement('span', { className: 'mr-2' }, 'üîó'),
'Client Relationship Summary'
),
React.createElement('div', { className: 'grid grid-cols-1 md:grid-cols-3 gap-4' },
React.createElement('div', null,
React.createElement('label', { className: 'block text-sm font-medium text-gray-700' }, 'Assigned To'),
React.createElement('div', { className: 'mt-1 text-sm text-gray-900' }, 
selectedClient.assigned_to ? window.getUserDisplayName(selectedClient.assigned_to, users) : 'Unassigned'
)
),
React.createElement('div', null,
React.createElement('label', { className: 'block text-sm font-medium text-gray-700' }, 'Client Status'),
React.createElement('span', { 
className: `inline-flex mt-1 px-2 py-1 text-xs rounded-full ${
selectedClient.status === 'converted' ? 'bg-green-100 text-green-800' :
selectedClient.status === 'dropped' ? 'bg-red-100 text-red-800' :
'bg-yellow-100 text-yellow-800'
}`
}, selectedClient.status || 'Active')
),
React.createElement('div', null,
React.createElement('label', { className: 'block text-sm font-medium text-gray-700' }, 'Last Activity'),
React.createElement('div', { className: 'mt-1 text-sm text-gray-900' }, 
new Date(selectedClient.last_activity).toLocaleDateString()
)
)
)
),

// Lead Timeline Section
React.createElement('div', { className: 'mb-6' },
React.createElement('h3', { className: 'text-lg font-semibold text-gray-900 mb-4 flex items-center' },
React.createElement('span', { className: 'mr-2' }, 'üìã'),
'Complete Lead Timeline (' + sortedLeads.length + ' leads)'
),

// Timeline Container
React.createElement('div', { className: 'space-y-4' },
sortedLeads.map((lead, index) => {
const status = window.LEAD_STATUSES[lead.status] || { label: lead.status, color: 'bg-gray-100 text-gray-800' };
const isLatest = index === sortedLeads.length - 1;

return React.createElement('div', { 
key: lead.id, 
className: `relative ${isLatest ? 'ring-2 ring-blue-200' : ''} bg-white border border-gray-200 rounded-lg p-4 hover:shadow-md transition-shadow`
},
// Timeline Connector (except for last item)
index < sortedLeads.length - 1 && React.createElement('div', {
className: 'absolute left-8 -bottom-4 w-0.5 h-8 bg-gray-300'
}),

// Lead Content
React.createElement('div', { className: 'flex items-start space-x-4' },
// Timeline Dot
React.createElement('div', { 
className: `flex-shrink-0 w-8 h-8 rounded-full flex items-center justify-center text-white text-sm font-bold ${
isLatest ? 'bg-blue-600' : 'bg-gray-400'
}`
}, index + 1),

// Lead Details
React.createElement('div', { className: 'flex-grow' },
React.createElement('div', { className: 'flex justify-between items-start mb-2' },
React.createElement('div', null,
  React.createElement('h4', { 
      className: `font-medium text-gray-900 ${isLatest ? 'text-blue-900' : ''}`
  }, 
      'Lead #' + (index + 1) + (isLatest ? ' (Latest)' : ''),
      lead.lead_for_event && React.createElement('span', { className: 'ml-2 text-sm text-gray-600' }, 
          '‚Üí ' + lead.lead_for_event
      )
  ),
  React.createElement('div', { className: 'text-sm text-gray-600 mt-1' },
      'Created: ' + new Date(lead.date_of_enquiry || lead.created_date).toLocaleDateString(),
      lead.updated_date && lead.updated_date !== lead.created_date && 
      React.createElement('span', { className: 'ml-3' }, 
          'Updated: ' + new Date(lead.updated_date).toLocaleDateString()
      )
  )
),
React.createElement('div', { className: 'flex items-center space-x-2' },
  React.createElement('span', {
      className: 'px-2 py-1 text-xs rounded-full ' + status.color
  }, status.label),
  isLatest && React.createElement('span', {
      className: 'px-2 py-1 text-xs rounded-full bg-blue-100 text-blue-800'
  }, 'Current')
)
),

// Lead Details Grid
React.createElement('div', { className: 'grid grid-cols-1 md:grid-cols-3 gap-4 mt-3' },
React.createElement('div', null,
  React.createElement('label', { className: 'block text-xs font-medium text-gray-500' }, 'Event & People'),
  React.createElement('div', { className: 'text-sm text-gray-900' }, 
      (lead.lead_for_event || 'Not specified'),
      lead.number_of_people && React.createElement('span', { className: 'text-gray-600 ml-2' }, 
          '(' + lead.number_of_people + ' people)'
      )
  )
),
React.createElement('div', null,
  React.createElement('label', { className: 'block text-xs font-medium text-gray-500' }, 'Source & Type'),
  React.createElement('div', { className: 'text-sm text-gray-900' }, 
      (lead.source || 'Unknown') + ' ‚Ä¢ ' + (lead.business_type || 'B2C')
  )
),
React.createElement('div', null,
  React.createElement('label', { className: 'block text-xs font-medium text-gray-500' }, 'Value'),
  React.createElement('div', { className: 'text-sm text-gray-900' }, 
      lead.potential_value ? '‚Çπ' + lead.potential_value.toLocaleString() : 'Not specified',
      lead.last_quoted_price && React.createElement('div', { className: 'text-xs text-green-600' }, 
          'Quoted: ‚Çπ' + lead.last_quoted_price.toLocaleString()
      )
  )
)
),

// Notes Section (if exists)
lead.notes && React.createElement('div', { className: 'mt-3 p-3 bg-gray-50 rounded-md' },
React.createElement('label', { className: 'block text-xs font-medium text-gray-500 mb-1' }, 'Notes'),
React.createElement('div', { className: 'text-sm text-gray-700' }, lead.notes)
),

// Action Buttons for this lead
React.createElement('div', { className: 'mt-3 flex space-x-2' },
React.createElement('button', {
  onClick: () => {
      setShowClientDetail(false);
      setSelectedClient(null);
      openLeadDetail(lead);
  },
  className: 'text-xs text-blue-600 hover:text-blue-800 bg-blue-50 hover:bg-blue-100 px-2 py-1 rounded border'
}, 'üëÅÔ∏è View Details'),
window.hasPermission('leads', 'write') && React.createElement('button', {
  onClick: () => {
      setShowClientDetail(false);
      setSelectedClient(null);
      openEditForm(lead);
  },
  className: 'text-xs text-green-600 hover:text-green-800 bg-green-50 hover:bg-green-100 px-2 py-1 rounded border'
}, '‚úèÔ∏è Edit Lead'),
window.hasPermission('leads', 'progress') && React.createElement('button', {
  onClick: () => {
      setShowClientDetail(false);
      setSelectedClient(null);
      if (lead.status === 'unassigned' && !lead.assigned_to) {
          openAssignForm(lead);
      } else {
          handleLeadProgression(lead);
      }
  },
  className: 'text-xs text-purple-600 hover:text-purple-800 bg-purple-50 hover:bg-purple-100 px-2 py-1 rounded border'
}, '‚Üí Progress')
)
)
)
);
})
)
),

// Client Actions Section
React.createElement('div', { className: 'bg-gray-50 border border-gray-200 rounded-lg p-4' },
React.createElement('h3', { className: 'text-lg font-semibold text-gray-900 mb-3 flex items-center' },
React.createElement('span', { className: 'mr-2' }, '‚ö°'),
'Client Actions'
),
React.createElement('div', { className: 'flex flex-wrap gap-3' },
window.hasPermission('leads', 'write') && React.createElement('button', {
onClick: () => {
setShowClientDetail(false);
setSelectedClient(null);
// Pre-fill lead form with client data
setFormData({
name: primaryLead.name,
email: primaryLead.email,
phone: primaryLead.phone,
company: primaryLead.company || '',
business_type: primaryLead.business_type || 'B2C',
source: '',
date_of_enquiry: (() => {
const now = new Date();
const year = now.getFullYear();
const month = String(now.getMonth() + 1).padStart(2, '0');
const day = String(now.getDate()).padStart(2, '0');
return `${year}-${month}-${day}`;
})(),
first_touch_base_done_by: '',
city_of_residence: primaryLead.city_of_residence || '',
country_of_residence: primaryLead.country_of_residence || 'India',
lead_for_event: '',
number_of_people: 1,
has_valid_passport: primaryLead.has_valid_passport || 'Not Sure',
visa_available: primaryLead.visa_available || 'Not Required',
attended_sporting_event_before: primaryLead.attended_sporting_event_before || 'No',
annual_income_bracket: primaryLead.annual_income_bracket || '',
potential_value: 0,
status: 'unassigned',
assigned_to: selectedClient.assigned_to || '',
last_quoted_price: 0,
notes: ''
});
setShowLeadForm(true);
},
className: 'bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg font-medium flex items-center gap-2'
}, 
React.createElement('span', null, '+'),
'Add New Lead for this Client'
),
window.hasPermission('leads', 'assign') && selectedClient.total_leads > 1 && React.createElement('button', {
onClick: () => {
// Bulk reassign functionality - placeholder for now
if (confirm(`Reassign all ${selectedClient.total_leads} leads for this client to a new sales person?`)) {
alert(`Bulk reassign for ${selectedClient.total_leads} leads coming in next update!`);
}
},
className: 'bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg font-medium flex items-center gap-2'
}, 
React.createElement('span', null, 'üë•'),
'Bulk Reassign All Leads'
),
React.createElement('button', {
onClick: () => setViewMode('leads'),
className: 'bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-lg font-medium flex items-center gap-2'
}, 
React.createElement('span', null, 'üìã'),
'Switch to Lead View'
),
React.createElement('button', {
onClick: () => {
setShowClientDetail(false);
setSelectedClient(null);
},
className: 'bg-gray-300 hover:bg-gray-400 text-gray-800 px-4 py-2 rounded-lg font-medium'
}, 'Close')
)
)
)
)
);
};

const renderPaymentPostServiceForm = () => {
if (!showPaymentPostServiceForm || !currentLead) return null;

return React.createElement('div', { 
className: 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50',
onClick: (e) => e.target === e.currentTarget && closeForm()
},
React.createElement('div', { className: 'bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-2xl max-h-[95vh] overflow-y-auto' },
React.createElement('div', { className: 'flex justify-between items-center mb-6' },
React.createElement('h2', { className: 'text-xl font-bold text-gray-900 dark:text-white' }, 
'Payment Post Service: ' + (currentLead.name)
),
React.createElement('button', {
onClick: closeForm,
className: 'text-gray-400 hover:text-gray-600 text-2xl'
}, '‚úï')
),

React.createElement('div', { className: 'mb-4 p-4 bg-purple-50 rounded-lg' },
React.createElement('p', { className: 'text-sm text-purple-800' }, 
'üìÖ This option allows service delivery before payment collection. The order will require approval and payment will be tracked as receivable.'
)
),

React.createElement('form', { onSubmit: handlePaymentPostServiceSubmit },
React.createElement('div', { className: 'grid grid-cols-1 md:grid-cols-2 gap-4 mb-6' },
React.createElement('div', null,
React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-1' }, 'Expected Payment Amount (‚Çπ) - Inclusive of GST *'),
React.createElement('input', {
type: 'number',
value: paymentPostServiceData.expected_amount || '',
onChange: (e) => handlePaymentPostServiceInputChange('expected_amount', e.target.value),
className: 'w-full px-3 py-2 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded-md focus:ring-2 focus:ring-blue-500',
required: true,
min: 0
})
),
React.createElement('div', null,
React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-1' }, 'Expected Payment Date *'),
React.createElement('input', {
type: 'date',
value: paymentPostServiceData.expected_payment_date || '',
onChange: (e) => handlePaymentPostServiceInputChange('expected_payment_date', e.target.value),
className: 'w-full px-3 py-2 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded-md focus:ring-2 focus:ring-blue-500',
required: true,
min: new Date().toISOString().split('T')[0]
})
),
React.createElement('div', null,
React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-1' }, 'Service Date *'),
React.createElement('input', {
type: 'date',
value: paymentPostServiceData.service_date || '',
onChange: (e) => handlePaymentPostServiceInputChange('service_date', e.target.value),
className: 'w-full px-3 py-2 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded-md focus:ring-2 focus:ring-blue-500',
required: true
})
),
React.createElement('div', null,
React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-1' }, 'Payment Terms'),
React.createElement('select', {
value: paymentPostServiceData.payment_terms || '30 days',
onChange: (e) => handlePaymentPostServiceInputChange('payment_terms', e.target.value),
className: 'w-full px-3 py-2 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded-md focus:ring-2 focus:ring-blue-500'
},
React.createElement('option', { value: '7 days' }, '7 days'),
React.createElement('option', { value: '15 days' }, '15 days'),
React.createElement('option', { value: '30 days' }, '30 days'),
React.createElement('option', { value: '45 days' }, '45 days'),
React.createElement('option', { value: '60 days' }, '60 days'),
React.createElement('option', { value: 'custom' }, 'Custom')
)
)
),

React.createElement('div', { className: 'mb-4' },
React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-1' }, 'Service Details *'),
React.createElement('textarea', {
value: paymentPostServiceData.service_details || '',
onChange: (e) => handlePaymentPostServiceInputChange('service_details', e.target.value),
className: 'w-full px-3 py-2 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded-md focus:ring-2 focus:ring-blue-500',
rows: 3,
required: true,
placeholder: 'Describe the service to be delivered'
})
),

React.createElement('div', { className: 'mb-4' },
React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-1' }, 'Send Payment Reminder'),
React.createElement('div', { className: 'flex items-center space-x-4' },
React.createElement('select', {
value: paymentPostServiceData.reminder_days || '7',
onChange: (e) => handlePaymentPostServiceInputChange('reminder_days', e.target.value),
className: 'px-3 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500'
},
React.createElement('option', { value: '3' }, '3 days before'),
React.createElement('option', { value: '7' }, '7 days before'),
React.createElement('option', { value: '14' }, '14 days before'),
React.createElement('option', { value: '30' }, '30 days before')
),
React.createElement('span', { className: 'text-sm text-gray-600 dark:text-gray-400' }, 'payment due date')
)
),

React.createElement('div', { className: 'mb-6' },
React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-1' }, 'Additional Notes'),
React.createElement('textarea', {
value: paymentPostServiceData.notes || '',
onChange: (e) => handlePaymentPostServiceInputChange('notes', e.target.value),
className: 'w-full px-3 py-2 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded-md focus:ring-2 focus:ring-blue-500',
rows: 3,
placeholder: 'Any additional notes or special conditions'
})
),

React.createElement('div', { className: 'flex space-x-4 pt-4 border-t' },
React.createElement('button', {
type: 'button',
onClick: closeForm,
className: 'flex-1 px-4 py-2 border border-gray-300 rounded-md hover:bg-gray-50'
}, 'Cancel'),
React.createElement('button', {
type: 'submit',
disabled: loading,
className: 'flex-1 bg-purple-600 text-white px-4 py-2 rounded-md hover:bg-purple-700 disabled:opacity-50'
}, loading ? 'Creating...' : 'Create Payment Post Service Order')
)
)
)
);
};

// Allocation form
const renderAllocationForm = () => {
if (!showAllocationForm || !currentInventory) return null;

const convertedLeads = leads.filter(lead => 
['converted', 'payment', 'payment_post_service', 'payment_received'].includes(lead.status)
);

return React.createElement('div', { 
className: 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50',
onClick: (e) => e.target === e.currentTarget && closeForm()
},
React.createElement('div', { className: 'bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-md' },
React.createElement('div', { className: 'flex justify-between items-center mb-6' },
React.createElement('h2', { className: 'text-xl font-bold text-gray-900 dark:text-white' }, 
'Allocate: ' + (currentInventory.event_name)
),
React.createElement('button', {
onClick: closeForm,
className: 'text-gray-400 hover:text-gray-600 text-2xl'
}, '‚úï')
),
React.createElement('div', { className: 'mb-4 p-3 bg-blue-50 rounded' },
React.createElement('p', { className: 'text-sm text-blue-800' }, 
'Available Tickets: ' + (currentInventory.available_tickets)
),
React.createElement('p', { className: 'text-sm text-blue-800' }, 
'Price per Ticket: ‚Çπ' + (currentInventory.selling_price?.toLocaleString())
)
),
React.createElement('form', { onSubmit: handleAllocation },
React.createElement('div', { className: 'mb-4' },
React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-2' }, 
'Select Lead (Converted or Later) *'
),
React.createElement('select', {
value: allocationData.lead_id || '',
onChange: (e) => handleAllocationInputChange('lead_id', e.target.value),
className: 'w-full px-3 py-2 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded-md focus:ring-2 focus:ring-blue-500',
required: true
},
React.createElement('option', { value: '' }, 'Select Lead'),
convertedLeads.map(lead =>
React.createElement('option', { key: lead.id, value: lead.id }, 
(lead.name) + ' - ' + (lead.number_of_people) + ' people'
)
)
)
),
React.createElement('div', { className: 'mb-4' },
React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-2' }, 
'Tickets to Allocate *'
),
React.createElement('input', {
type: 'number',
value: allocationData.tickets_allocated || '',
onChange: (e) => handleAllocationInputChange('tickets_allocated', parseInt(e.target.value)),
className: 'w-full px-3 py-2 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded-md focus:ring-2 focus:ring-blue-500',
required: true,
min: 1,
max: currentInventory.available_tickets
})
),
React.createElement('div', { className: 'mb-6' },
React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-2' }, 
'Allocation Notes'
),
React.createElement('textarea', {
value: allocationData.notes || '',
onChange: (e) => handleAllocationInputChange('notes', e.target.value),
className: 'w-full px-3 py-2 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded-md focus:ring-2 focus:ring-blue-500',
rows: 3,
placeholder: 'Any special notes for this allocation'
})
),
React.createElement('div', { className: 'flex space-x-4' },
React.createElement('button', {
type: 'button',
onClick: closeForm,
className: 'flex-1 px-4 py-2 border border-gray-300 rounded-md hover:bg-gray-50'
}, 'Cancel'),
React.createElement('button', {
type: 'submit',
disabled: loading,
className: 'flex-1 bg-green-600 text-white px-4 py-2 rounded-md hover:bg-green-700 disabled:opacity-50'
}, loading ? 'Allocating...' : 'Allocate & Create Order')
)
)
)
);
};

// Allocation Management Modal
const renderAllocationManagement = () => {
if (!showAllocationManagement || !allocationManagementInventory) return null;

return React.createElement('div', { 
className: 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50'
},
React.createElement('div', { 
className: 'bg-white p-6 rounded-lg w-full max-w-4xl max-h-[90vh] overflow-y-auto'
},
React.createElement('div', { className: 'flex justify-between items-center mb-4' },
React.createElement('h2', { className: 'text-xl font-bold' }, 
'Allocations for ' + allocationManagementInventory.event_name
),
React.createElement('button', {
onClick: () => setShowAllocationManagement(false),
className: 'text-gray-500 hover:text-gray-700'
}, '‚úï')
),

React.createElement('div', { className: 'mb-4 p-4 bg-gray-50 rounded' },
React.createElement('h3', { className: 'font-semibold' }, 'Inventory Details'),
React.createElement('p', null, 'Total Tickets: ' + (allocationManagementInventory.total_tickets || 'N/A')),
React.createElement('p', null, 'Available Tickets: ' + (allocationManagementInventory.available_tickets || 0)),
React.createElement('p', null, 'Allocated Tickets: ' + ((allocationManagementInventory.total_tickets || 0) - (allocationManagementInventory.available_tickets || 0)))
),

currentAllocations.length === 0 ? 
React.createElement('div', { className: 'text-center py-8 text-gray-500' },
'No allocations found for this inventory item.'
) :
React.createElement('div', { className: 'overflow-x-auto' },
React.createElement('table', { className: 'min-w-full bg-white border border-gray-300' },
React.createElement('thead', { className: 'bg-gray-50' },
React.createElement('tr', null,
React.createElement('th', { className: 'px-4 py-2 border text-left' }, 'Lead Name'),
React.createElement('th', { className: 'px-4 py-2 border text-left' }, 'Email'),
React.createElement('th', { className: 'px-4 py-2 border text-left' }, 'Tickets Allocated'),
React.createElement('th', { className: 'px-4 py-2 border text-left' }, 'Allocation Date'),
React.createElement('th', { className: 'px-4 py-2 border text-left' }, 'Notes'),
React.createElement('th', { className: 'px-4 py-2 border text-left' }, 'Actions')
)
),
React.createElement('tbody', null,
currentAllocations.map(allocation =>
React.createElement('tr', { key: allocation.id, className: 'hover:bg-gray-50' },
React.createElement('td', { className: 'px-4 py-2 border' },
allocation.lead_details ? allocation.lead_details.name : (allocation.lead_name || 'Unknown')
),
React.createElement('td', { className: 'px-4 py-2 border' },
allocation.lead_details ? allocation.lead_details.email : (allocation.lead_email || 'N/A')
),
React.createElement('td', { className: 'px-4 py-2 border' }, allocation.tickets_allocated),
React.createElement('td', { className: 'px-4 py-2 border' },
new Date(allocation.allocation_date).toLocaleDateString()
),
React.createElement('td', { className: 'px-4 py-2 border' }, allocation.notes || 'No notes'),
React.createElement('td', { className: 'px-4 py-2 border' },
React.createElement('button', {
onClick: () => handleUnallocate(allocation.id, allocation.tickets_allocated),
className: 'bg-red-500 text-white px-3 py-1 rounded text-sm hover:bg-red-600',
disabled: loading
}, 'Unallocate')
)
)
)
)
)
),

React.createElement('div', { className: 'mt-6 flex justify-between' },
React.createElement('button', {
onClick: () => openAllocationForm(allocationManagementInventory),
className: 'bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600',
disabled: allocationManagementInventory.available_tickets <= 0
}, 'Add New Allocation'),
React.createElement('button', {
onClick: () => setShowAllocationManagement(false),
className: 'bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600'
}, 'Close')
)
)
);
};



const renderStadiumForm = () => {
if (!showStadiumForm) return null;

return React.createElement('div', {
className: 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50'
},
React.createElement('div', {
className: 'bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-2xl max-h-[90vh] overflow-y-auto'
},
React.createElement('div', { className: 'flex justify-between items-center mb-6' },
React.createElement('h2', { className: 'text-xl font-bold text-gray-900 dark:text-white' },
editingStadium ? `Edit Stadium: ${editingStadium.name}` : 'Add New Stadium'
),
React.createElement('button', {
onClick: closeStadiumForm,
className: 'text-gray-400 hover:text-gray-600 text-2xl'
}, '‚úï')
),

React.createElement('form', { onSubmit: handleStadiumFormSubmit },
React.createElement('div', { className: 'grid grid-cols-1 md:grid-cols-2 gap-4' },
window.stadiumFormFields.map(field =>
React.createElement('div', {
key: field.name,
className: field.type === 'textarea' ? 'md:col-span-2' : ''
},
React.createElement('label', { className: 'block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1' },
field.label + (field.required ? ' *' : '')
),
field.type === 'select' ?
React.createElement('select', {
value: stadiumFormData[field.name] || '',
onChange: (e) => handleStadiumInputChange(field.name, e.target.value),
className: 'w-full px-3 py-2 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded-md focus:ring-2 focus:ring-blue-500',
required: field.required
},
React.createElement('option', { value: '' }, `Select ${field.label}`),
field.options.map(option =>
React.createElement('option', { key: option, value: option }, option)
)
) :
field.type === 'textarea' ?
React.createElement('textarea', {
value: stadiumFormData[field.name] || '',
onChange: (e) => handleStadiumInputChange(field.name, e.target.value),
className: 'w-full px-3 py-2 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded-md focus:ring-2 focus:ring-blue-500',
rows: 3,
placeholder: field.placeholder,
required: field.required
}) :
React.createElement('input', {
type: field.type,
value: stadiumFormData[field.name] || '',
onChange: (e) => handleStadiumInputChange(field.name, e.target.value),
className: 'w-full px-3 py-2 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded-md focus:ring-2 focus:ring-blue-500',
required: field.required,
placeholder: field.placeholder,
min: field.type === 'number' ? 0 : undefined
})
)
)
),

React.createElement('div', { className: 'flex space-x-4 mt-6 pt-4 border-t border-gray-200' },
React.createElement('button', {
type: 'button',
onClick: closeStadiumForm,
className: 'flex-1 px-4 py-2 border border-gray-300 rounded-md hover:bg-gray-50 dark:border-gray-600 dark:hover:bg-gray-700'
}, 'Cancel'),
React.createElement('button', {
type: 'submit',
disabled: loading,
className: 'flex-1 bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 disabled:opacity-50'
}, loading ? 'Saving...' : (editingStadium ? 'Update Stadium' : 'Add Stadium'))
)
)
)
);
};



const populateDefaultStadiums = async () => {
if (!confirm('This will add popular stadiums to your database. Continue?')) return;

const defaultStadiums = [
// Cricket Stadiums - India
{ 
name: 'Wankhede Stadium', 
city: 'Mumbai', 
state: 'Maharashtra', 
country: 'India', 
sport_type: 'Cricket', 
capacity: 33000, 
opened_year: 1974,
nickname: 'Home of Indian Cricket',
notes: 'Famous for hosting Cricket World Cup finals'
},
{ 
name: 'Eden Gardens', 
city: 'Kolkata', 
state: 'West Bengal', 
country: 'India', 
sport_type: 'Cricket', 
capacity: 66000, 
opened_year: 1864,
nickname: 'Cricket\'s Colosseum',
notes: 'One of the oldest and largest cricket stadiums'
},
{ 
name: 'M. Chinnaswamy Stadium', 
city: 'Bangalore', 
state: 'Karnataka', 
country: 'India', 
sport_type: 'Cricket', 
capacity: 40000, 
opened_year: 1969,
notes: 'Known for high-scoring matches and IPL games'
},
{ 
name: 'Feroz Shah Kotla Ground', 
city: 'Delhi', 
state: 'Delhi', 
country: 'India', 
sport_type: 'Cricket', 
capacity: 41000, 
opened_year: 1883,
notes: 'One of the oldest cricket grounds in India'
},
{ 
name: 'MA Chidambaram Stadium', 
city: 'Chennai', 
state: 'Tamil Nadu', 
country: 'India', 
sport_type: 'Cricket', 
capacity: 50000, 
opened_year: 1916,
nickname: 'Chepauk Stadium',
notes: 'Known for its spinning pitches'
},
{ 
name: 'Narendra Modi Stadium', 
city: 'Ahmedabad', 
state: 'Gujarat', 
country: 'India', 
sport_type: 'Cricket', 
capacity: 132000, 
opened_year: 2020,
nickname: 'Motera Stadium',
notes: 'World\'s largest cricket stadium'
},

// Cricket Stadiums - International
{ 
name: 'Lord\'s Cricket Ground', 
city: 'London', 
country: 'United Kingdom', 
sport_type: 'Cricket', 
capacity: 31000, 
opened_year: 1814, 
nickname: 'Home of Cricket',
notes: 'Most famous cricket ground in the world'
},
{ 
name: 'Melbourne Cricket Ground', 
city: 'Melbourne', 
state: 'Victoria',
country: 'Australia', 
sport_type: 'Cricket', 
capacity: 100024, 
opened_year: 1853, 
nickname: 'MCG',
notes: 'Largest cricket stadium in the Southern Hemisphere'
},
{ 
name: 'The Oval', 
city: 'London', 
country: 'United Kingdom', 
sport_type: 'Cricket', 
capacity: 23500, 
opened_year: 1845,
notes: 'Famous for hosting the final Test of English summer'
},
{ 
name: 'Sydney Cricket Ground', 
city: 'Sydney', 
state: 'New South Wales',
country: 'Australia', 
sport_type: 'Cricket', 
capacity: 48000, 
opened_year: 1848, 
nickname: 'SCG',
notes: 'Hosts New Year Test matches'
},

// Football Stadiums - International
{ 
name: 'Camp Nou', 
city: 'Barcelona', 
country: 'Spain', 
sport_type: 'Football', 
capacity: 99354, 
opened_year: 1957,
notes: 'Home of FC Barcelona, largest stadium in Europe'
},
{ 
name: 'Wembley Stadium', 
city: 'London', 
country: 'United Kingdom', 
sport_type: 'Football', 
capacity: 90000, 
opened_year: 2007,
nickname: 'The Home of Football',
notes: 'England national team home, hosts FA Cup finals'
},
{ 
name: 'Old Trafford', 
city: 'Manchester', 
country: 'United Kingdom', 
sport_type: 'Football', 
capacity: 74140, 
opened_year: 1910, 
nickname: 'Theatre of Dreams',
notes: 'Home of Manchester United'
},
{ 
name: 'Santiago Bernab√©u', 
city: 'Madrid', 
country: 'Spain', 
sport_type: 'Football', 
capacity: 81044, 
opened_year: 1947,
notes: 'Home of Real Madrid, hosts Champions League finals'
},
{ 
name: 'Allianz Arena', 
city: 'Munich', 
country: 'Germany', 
sport_type: 'Football', 
capacity: 75000, 
opened_year: 2005,
notes: 'Famous for its color-changing exterior'
},

// Multi-Sport & Other Venues
{ 
name: 'Madison Square Garden', 
city: 'New York', 
state: 'New York',
country: 'United States', 
sport_type: 'Multi-Sport', 
capacity: 20000, 
opened_year: 1968, 
nickname: 'The Garden',
notes: 'Famous for basketball, hockey, and concerts'
},
{ 
name: 'Maracan√£ Stadium', 
city: 'Rio de Janeiro', 
country: 'Brazil', 
sport_type: 'Football', 
capacity: 78838, 
opened_year: 1950,
notes: 'Hosted 2014 FIFA World Cup final'
},
{ 
name: 'Wimbledon', 
city: 'London', 
country: 'United Kingdom', 
sport_type: 'Tennis', 
capacity: 15000, 
opened_year: 1877,
nickname: 'All England Club',
notes: 'Most prestigious tennis tournament venue'
}
];

try {
setLoading(true);
console.log(`üèüÔ∏è Adding ${defaultStadiums.length} popular stadiums...`);

const response = await window.apicall('/stadiums/bulk', {
method: 'POST',
body: JSON.stringify({ stadiums: defaultStadiums })
});

// Refresh stadiums list
await fetchStadiums();

alert(`‚úÖ Successfully added ${response.success || defaultStadiums.length} popular stadiums!${response.errors > 0 ? ` (${response.errors} duplicates skipped)` : ''}`);

} catch (error) {
console.error('‚ùå Error adding default stadiums:', error);
alert('‚ùå Error adding stadiums: ' + error.message);
} finally {
setLoading(false);
}
}; 

// Close inventory form
const closeInventoryForm = () => {
setShowInventoryForm(false);
setEditingInventory(null);
setFormData({});
};



// Handle inventory form submission (specifically for payables integration)
const handleInventoryFormSubmit = async (e) => {
e.preventDefault();

try {
setLoading(true);

// Enhanced debug logging
console.log('=== FRONTEND INVENTORY SUBMISSION DEBUG ===');
console.log('Inventory ID:', editingInventory.id);
console.log('Complete form data being sent:', formData);
console.log('Payment fields specifically:', {
totalPurchaseAmount: formData.totalPurchaseAmount,
amountPaid: formData.amountPaid,
paymentStatus: formData.paymentStatus,
supplierName: formData.supplierName,
supplierInvoice: formData.supplierInvoice
});
console.log('Is from payables?', editingInventory._payableContext?.fromPayables);
console.log('Payable amount:', editingInventory._payableContext?.payableAmount);

if (editingInventory.id === null || editingInventory.id === undefined) {
// CREATE NEW INVENTORY
console.log('Creating new inventory item...');

const response = await window.apicall('/inventory', {
method: 'POST',
body: JSON.stringify({
...formData,
created_by: user.name || 'Unknown User',
created_date: new Date().toISOString()
})
});

console.log('Backend response:', response);

if (response.error) {
throw new Error(response.error);
}

// Add to local state
setInventory(prev => [...prev, response.data]);

alert('Inventory created successfully!');

} else {
// UPDATE EXISTING INVENTORY (your original code)
console.log('Updating existing inventory...');

const response = await window.apicall(`/inventory/${editingInventory.id}`, {
method: 'PUT',
body: JSON.stringify(formData)
});

console.log('Backend response:', response);

if (response.error) {
throw new Error(response.error);
}

// Update local state
setInventory(prev => prev.map(item => 
item.id === editingInventory.id ? { ...item, ...formData } : item
));

// Refresh financial data to show updated payables
await fetchFinancialData();

alert('Inventory updated successfully! Payables have been synced automatically.');
}

closeInventoryForm();

} catch (error) {
console.error('Error with inventory:', error);
alert('Error saving inventory: ' + error.message);
} finally {
setLoading(false);
}
};

// NEW: Client View Content Function
const renderClientViewContent = () => {
if (clientsLoading) {
return React.createElement('div', { className: 'text-center py-12' },
React.createElement('div', { className: 'text-gray-500' }, 'Loading clients...')
);
}

if (clients.length === 0) {
return React.createElement('div', { className: 'bg-white rounded-lg shadow-sm border p-8 text-center' },
React.createElement('div', { className: 'text-gray-500 text-lg mb-2' }, 'No clients found'),
React.createElement('p', { className: 'text-gray-400' }, 'Clients will appear here when you have leads with phone numbers'),
React.createElement('div', { className: 'mt-4' },
React.createElement('button', {
onClick: () => setViewMode('leads'),
className: 'text-blue-600 hover:text-blue-800 underline'
}, 'Go to Lead View to create leads')
)
);
}

return React.createElement('div', { className: 'space-y-6' },

// Client Statistics Summary
React.createElement('div', { className: 'grid grid-cols-1 md:grid-cols-4 gap-4' },
React.createElement('div', { className: 'bg-blue-50 border border-blue-200 rounded-lg p-4' },
React.createElement('div', { className: 'text-2xl font-bold text-blue-900' }, clients.length),
React.createElement('div', { className: 'text-sm text-blue-700' }, 'Total Clients')
),
React.createElement('div', { className: 'bg-green-50 border border-green-200 rounded-lg p-4' },
React.createElement('div', { className: 'text-2xl font-bold text-green-900' }, 
clients.filter(c => c.total_leads > 1).length
),
React.createElement('div', { className: 'text-sm text-green-700' }, 'Multi-Lead Clients')
),
React.createElement('div', { className: 'bg-purple-50 border border-purple-200 rounded-lg p-4' },
React.createElement('div', { className: 'text-2xl font-bold text-purple-900' }, 
clients.reduce((sum, c) => sum + c.total_leads, 0)
),
React.createElement('div', { className: 'text-sm text-purple-700' }, 'Total Leads')
),
React.createElement('div', { className: 'bg-orange-50 border border-orange-200 rounded-lg p-4' },
React.createElement('div', { className: 'text-2xl font-bold text-orange-900' }, 
'‚Çπ' + clients.reduce((sum, c) => sum + (parseFloat(c.total_value) || 0), 0).toLocaleString()
),
React.createElement('div', { className: 'text-sm text-orange-700' }, 'Total Client Value')
)
),

// Client Table
React.createElement('div', { className: 'bg-white rounded-lg shadow-sm border overflow-hidden' },
React.createElement('div', { className: 'px-6 py-4 border-b border-gray-200 bg-gray-50' },
React.createElement('h3', { className: 'text-lg font-medium text-gray-900' }, 'Clients Overview'),
React.createElement('p', { className: 'text-sm text-gray-600 mt-1' }, 
'Leads grouped by phone number - Click to see complete client timeline'
)
),
React.createElement('div', { className: 'overflow-x-auto' },
React.createElement('table', { className: 'w-full' },
React.createElement('thead', { className: 'bg-gray-50' },
React.createElement('tr', null,
React.createElement('th', { className: 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase' }, 'Client'),
React.createElement('th', { className: 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase' }, 'Leads'),
React.createElement('th', { className: 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase' }, 'Events'),
React.createElement('th', { className: 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase' }, 'Assigned To'),
React.createElement('th', { className: 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase' }, 'Status'),
React.createElement('th', { className: 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase' }, 'Value'),
React.createElement('th', { className: 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase' }, 'Actions')
)
),
React.createElement('tbody', { className: 'bg-white divide-y divide-gray-200' },
clients.map(client => {
const primaryLead = client.leads[0];
return React.createElement('tr', { key: client.client_id, className: 'hover:bg-gray-50' },
React.createElement('td', { className: 'px-6 py-4' },
React.createElement('div', { 
className: 'cursor-pointer hover:text-blue-600',
onClick: () => {
setSelectedClient(client);
setShowClientDetail(true);
}
},
React.createElement('div', { className: 'text-sm font-medium text-gray-900 hover:text-blue-600' }, 
primaryLead.name
),
React.createElement('div', { className: 'text-sm text-gray-500' }, primaryLead.phone),
React.createElement('div', { className: 'text-xs text-gray-400' }, 
`First contact: ${new Date(client.first_contact).toLocaleDateString()}`
)
)
),
React.createElement('td', { className: 'px-6 py-4' },
React.createElement('div', { className: 'flex items-center' },
React.createElement('span', { 
className: `inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${
  client.total_leads > 1 ? 'bg-blue-100 text-blue-800' : 'bg-gray-100 text-gray-800'
}`
}, 
client.total_leads,
client.total_leads > 1 && React.createElement('span', { className: 'ml-1' }, 'üîó')
)
)
),
React.createElement('td', { className: 'px-6 py-4' },
React.createElement('div', { className: 'text-sm text-gray-900' },
client.events.length > 0 ? client.events.slice(0, 2).join(', ') : '-'
),
client.events.length > 2 && React.createElement('div', { className: 'text-xs text-gray-500' },
`+${client.events.length - 2} more`
)
),
React.createElement('td', { className: 'px-6 py-4 text-sm text-gray-900' },
client.assigned_to || 'Unassigned'
),
React.createElement('td', { className: 'px-6 py-4' },
React.createElement('span', { 
className: `px-2 py-1 text-xs rounded-full ${
client.status === 'converted' ? 'bg-green-100 text-green-800' :
client.status === 'dropped' ? 'bg-red-100 text-red-800' :
'bg-yellow-100 text-yellow-800'
}`
}, client.status || 'active')
),
React.createElement('td', { className: 'px-6 py-4 text-sm text-gray-900' },
client.total_value ? `‚Çπ${(parseFloat(client.total_value) || 0).toLocaleString()}` : '-'
),
React.createElement('td', { className: 'px-6 py-4 text-sm font-medium space-x-2' },
React.createElement('button', {
onClick: () => {
setSelectedClient(client);
setShowClientDetail(true);
},
className: 'text-blue-600 hover:text-blue-900'
}, 'View Timeline'),
window.hasPermission('leads', 'assign') && client.total_leads > 1 &&
React.createElement('button', {
onClick: () => {
// Bulk reassign functionality - will implement in next phase
alert(`Bulk reassign for ${client.total_leads} leads coming in next update!`);
},
className: 'text-green-600 hover:text-green-900 ml-2'
}, 'Reassign All')
)
);
})
)
)
)
)
);
};




const handleEditOrderSubmit = async (e) => {
e.preventDefault();
setLoading(true);

try {
// Prepare update data
const updateData = {
...orderEditData,
updated_date: new Date().toISOString(),
updated_by: user.name
};



// Clear rejection fields if status is not rejected
if (orderEditData.status !== 'rejected') {
updateData.rejection_reason = null;
updateData.rejected_date = null;
updateData.rejected_by = null;
} else if (orderEditData.status === 'rejected' && orderEditData.rejection_reason) {
// Set rejection metadata if status is rejected
updateData.rejected_date = new Date().toISOString();
updateData.rejected_by = user.name;
}

const response = await window.apicall('/orders/' + (currentOrderForEdit.id), {
method: 'PUT',
body: JSON.stringify(updateData)
});

// Update local state
setOrders(prev => prev.map(order => 
order.id === currentOrderForEdit.id 
? { ...order, ...updateData }
: order
));

setShowEditOrderForm(false);
alert('Order updated successfully!');
} catch (error) {
console.error('Error updating order:', error);
alert('Failed to update order');
} finally {
setLoading(false);
}
};



const renderEditOrderForm = () => {
if (!showEditOrderForm || !currentOrderForEdit) return null;

return React.createElement('div', { 
className: 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50',
onClick: (e) => e.target === e.currentTarget && setShowEditOrderForm(false)
},
React.createElement('div', { className: 'bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-2xl max-h-[95vh] overflow-y-auto' },
React.createElement('h2', { className: 'text-xl font-bold mb-4' }, 'Edit Order'),
React.createElement('form', { onSubmit: handleEditOrderSubmit },
React.createElement('div', { className: 'mb-4' },
React.createElement('label', { className: 'block text-sm font-medium mb-2' }, 'Order Number'),
React.createElement('input', {
type: 'text',
value: orderEditData.order_number || '',
disabled: true,
className: 'w-full px-3 py-2 border rounded-md bg-gray-100'
})
),
React.createElement('div', { className: 'mb-4' },
React.createElement('label', { className: 'block text-sm font-medium mb-2' }, 'Client Name'),
React.createElement('input', {
type: 'text',
value: orderEditData.client_name || '',
disabled: true,
className: 'w-full px-3 py-2 border rounded-md bg-gray-100'
})
),
React.createElement('div', { className: 'mb-4' },
React.createElement('label', { className: 'block text-sm font-medium mb-2' }, 'Assigned To'),
React.createElement('select', {
value: orderEditData.assigned_to || '',
onChange: (e) => setOrderEditData(prev => ({ ...prev, assigned_to: e.target.value })),
className: 'w-full px-3 py-2 border rounded-md',
required: true
},
React.createElement('option', { value: '' }, 'Select Assignee'),
...(users || []).filter(u => ['supply_executive', 'supply_sales_service_manager'].includes(u.role)).map(user =>
React.createElement('option', { key: user.id || user.email, value: user.email }, user.name)
)
)
),
React.createElement('div', { className: 'mb-4' },
React.createElement('label', { className: 'block text-sm font-medium mb-2' }, 'Status'),
React.createElement('select', {
value: orderEditData.status || '',
onChange: (e) => setOrderEditData(prev => ({ ...prev, status: e.target.value })),
className: 'w-full px-3 py-2 border rounded-md'
},
Object.keys(window.ORDER_STATUSES).map(status =>
React.createElement('option', { key: status, value: status }, 
window.ORDER_STATUSES[status].label
)
)
)
),
React.createElement('div', { className: 'mb-4' },
React.createElement('label', { className: 'block text-sm font-medium mb-2' }, 'Rejection Reason'),
React.createElement('textarea', {
value: orderEditData.rejection_reason || '',
onChange: (e) => setOrderEditData(prev => ({ ...prev, rejection_reason: e.target.value })),
className: 'w-full px-3 py-2 border rounded-md',
rows: 3,
placeholder: orderEditData.status === 'rejected' ? 'Please provide a reason for rejection' : 'Add rejection reason if applicable',
required: orderEditData.status === 'rejected'
})
),
React.createElement('div', { className: 'flex justify-end gap-2' },
React.createElement('button', {
type: 'button',
onClick: () => setShowEditOrderForm(false),
className: 'px-4 py-2 border rounded-md hover:bg-gray-50 dark:hover:bg-gray-700'
}, 'Cancel'),
React.createElement('button', {
type: 'submit',
disabled: loading,
className: 'px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:opacity-50'
}, loading ? 'Updating...' : 'Update Order')
)
)
)
);
};

// 1. ESPN API ENDPOINTS AND FETCH FUNCTIONS
const SOFASCORE_API_BASE = "https://api.sofascore.com/api/v1";

// ESPN API fetch function with error handling
const fetchSofaScoreData = async (endpoint) => {
try {
const response = await fetch(endpoint, {
method: 'GET',
headers: {
'Accept': 'application/json',
'Content-Type': 'application/json'
}
});

if (!response.ok) {
throw new Error(`SofaScore API error: ${response.status}`);
}

const data = await response.json();
return data;
} catch (error) {
console.error('SofaScore API fetch error:', error);
return null;
}
};



// Fetch events from multiple sports leagues
const fetchAllEvents = async () => {
  try {
    console.log("Fetching all events from backend...");
    const response = await fetch(`${window.API_CONFIG.API_URL}/events`, {
      method: "GET",
      headers: { "Authorization": `Bearer ${localStorage.getItem("crm_auth_token")}` }
    });
    if (response.ok) {
      const result = await response.json();
      if (result.success && result.data) {
        const transformedEvents = result.data.map(event => ({
          id: event.id, title: event.event_name, date: event.start_date,
          time: event.start_time || "", venue: event.venue || "",
          category: event.sport_type || "", status: event.status || "upcoming",
          ...event
        }));
        setSportsEvents(transformedEvents);
      }
    }
  } catch (error) { console.error("Error fetching events:", error); }
};



const fetchSofaScoreEvents = async () => {
try {
setLoading(true);

// Define sports endpoints for different leagues
const sportsEndpoints = [
{
name: "Premier League",
endpoint: `${SOFASCORE_API_BASE}/unique-tournament/17/season/52186/events/last/0`,
category: "football"
},
{
name: "Champions League",
endpoint: `${SOFASCORE_API_BASE}/unique-tournament/7/season/52162/events/last/0`,
category: "football"
},
{
name: "NBA",
endpoint: `${SOFASCORE_API_BASE}/unique-tournament/132/season/58766/events/last/0`,
category: "basketball"
}
];

const allEvents = [];

// Fetch events from each sport
for (const sport of sportsEndpoints) {
const data = await fetchSofaScoreData(sport.endpoint);

if (data && data.events) {
const processedEvents = data.events.map(event => ({
id: `sofascore_${event.id}`,
title: `${event.name || event.shortName}`,
date: new Date(event.date).toISOString().split('T')[0],
time: new Date(event.date).toLocaleTimeString('en-US', { 
hour: '2-digit', 
minute: '2-digit',
hour12: false 
}),
venue: event.competitions?.[0]?.venue?.fullName || 'TBD',
category: sport.category,
description: `${sport.name} - ${event.status?.type?.description || 'Scheduled'}`,
ticket_available: true,
fantopark_package: generateFanToParkPackage(event, sport.name),
status: getEventStatus(event.status?.type?.name),
espn_data: {
league: sport.name,
competitors: event.competitions?.[0]?.competitors?.map(comp => ({
name: comp.team?.displayName,
logo: comp.team?.logo,
record: comp.records?.[0]?.summary
})) || [],
broadcasts: event.competitions?.[0]?.broadcasts || [],
odds: event.competitions?.[0]?.odds || []
}
}));

allEvents.push(...processedEvents);
}
}

// Sort events by date
allEvents.sort((a, b) => new Date(a.date) - new Date(b.date));

// Update state with fetched events
setSportsEvents(allEvents);
setLoading(false);

return allEvents;

} catch (error) {
console.error('Error fetching ESPN events:', error);
setLoading(false);

// Fallback to some basic events if ESPN API fails
setSportsEvents([
{
id: 'fallback_001',
title: 'ESPN API Unavailable - Sample Event',
date: new Date().toISOString().split('T')[0],
time: '20:00',
venue: 'Various Stadiums',
category: 'multi-sport',
description: 'ESPN API is currently unavailable. This is a fallback event.',
ticket_available: false,
fantopark_package: 'Please check back later for live events',
status: 'upcoming'
}
]);

return [];
}
};



// Generate FanToPark package descriptions based on event type
const generateFanToParkPackage = (event, sportName) => {
const venue = event.competitions?.[0]?.venue?.fullName || 'Stadium';
const competitors = event.competitions?.[0]?.competitors;

let packagePrice = '‚Çπ15,000';
let packageType = 'Standard Package';

// Customize package based on sport and event importance
if (sportName.includes('Cricket') || sportName.includes('ICC')) {
packagePrice = '‚Çπ25,000';
packageType = 'Cricket Premium Package';
} else if (sportName.includes('Premier League')) {
packagePrice = '‚Çπ35,000';
packageType = 'Premier League VIP Package';
} else if (sportName.includes('NFL')) {
packagePrice = '‚Çπ45,000';
packageType = 'NFL Elite Package';
} else if (sportName.includes('NBA')) {
packagePrice = '‚Çπ30,000';
packageType = 'NBA Courtside Package';
}

const teamNames = competitors?.map(c => c.team?.displayName).join(' vs ') || 'Teams TBD';

return `${packageType}: ${packagePrice} - ${teamNames} at ${venue}, Premium seating, refreshments, and match commentary`;
};



// Convert ESPN event status to our status format
const getEventStatus = (espnStatus) => {
if (!espnStatus) return 'upcoming';

switch (espnStatus.toLowerCase()) {
case 'scheduled':
case 'pre':
return 'upcoming';
case 'in':
case 'live':
return 'live';
case 'final':
case 'completed':
return 'completed';
case 'postponed':
case 'canceled':
return 'cancelled';
default:
return 'upcoming';
}
}; 

// 6. EVENT DETAIL MODAL
const renderEventDetailModal = () => {
if (!showEventDetail || !currentEvent) return null;

return React.createElement('div', {
className: 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4',
style: { backdropFilter: 'blur(4px)' },
onClick: (e) => {
if (e.target === e.currentTarget) setShowEventDetail(false);
}
},
React.createElement('div', {
className: 'bg-white rounded-xl max-w-4xl w-full max-h-[90vh] overflow-auto shadow-2xl',
onClick: (e) => e.stopPropagation()
},
React.createElement('div', {
className: `p-6 border-b ${window.getPriorityStyles(currentEvent.priority)}`
},
React.createElement('div', { className: 'flex justify-between items-start' },
React.createElement('div', { className: 'flex-1' },
React.createElement('div', { className: 'flex items-center gap-3 mb-2' },
React.createElement('h2', { className: 'text-2xl font-bold' },
currentEvent.event_name || currentEvent.title
),
React.createElement('span', {
className: `px-3 py-1 text-sm font-semibold rounded-full ${window.getPriorityBadgeColor(currentEvent.priority)}`
}, currentEvent.priority || 'N/A')
),
React.createElement('p', { className: 'text-sm opacity-75' },
`${currentEvent.sport_type || currentEvent.category || 'Event'} ‚Ä¢ ${currentEvent.geography || 'Location TBD'}`
)
),
React.createElement('button', {
onClick: () => setShowEventDetail(false),
className: 'text-gray-500 hover:text-gray-700 text-2xl p-2 rounded-lg hover:bg-gray-100'
}, '‚úï')
)
),
React.createElement('div', { className: 'p-6 grid md:grid-cols-2 gap-6' },
React.createElement('div', { className: 'space-y-6' },
React.createElement('div', null,
React.createElement('h3', { className: 'text-lg font-semibold mb-3 flex items-center' },
React.createElement('span', { className: 'mr-2' }, 'üìÖ'),
'Date & Time'
),
React.createElement('div', { className: 'space-y-2 text-sm bg-gray-50 p-4 rounded-lg' },
React.createElement('div', { className: 'flex justify-between' },
React.createElement('span', { className: 'font-medium text-gray-700' }, 'Date:'),
React.createElement('span', { className: 'text-gray-900' },
new Date(currentEvent.start_date || currentEvent.date).toLocaleDateString()
)
),
React.createElement('div', { className: 'flex justify-between' },
React.createElement('span', { className: 'font-medium text-gray-700' }, 'Time:'),
React.createElement('span', { className: 'text-gray-900 font-mono' },
currentEvent.start_time || currentEvent.time || 'TBD'
)
)
)
),
currentEvent.venue && React.createElement('div', null,
React.createElement('h3', { className: 'text-lg font-semibold mb-3 flex items-center' },
React.createElement('span', { className: 'mr-2' }, 'üèüÔ∏è'),
'Venue'
),
React.createElement('div', { className: 'bg-gray-50 p-4 rounded-lg' },
React.createElement('div', { className: 'font-medium text-gray-900' },
currentEvent.venue
)
)
),
React.createElement('div', null,
React.createElement('h3', { className: 'text-lg font-semibold mb-3 flex items-center' },
React.createElement('span', { className: 'mr-2' }, 'üìä'),
'Status & Priority'
),
React.createElement('div', { className: 'flex flex-wrap gap-2' },
React.createElement('span', {
className: `px-3 py-1 text-sm font-semibold rounded-full ${window.getPriorityBadgeColor(currentEvent.priority)}`
}, `Priority ${currentEvent.priority || 'N/A'}`),
React.createElement('span', {
className: `px-3 py-1 text-sm font-semibold rounded-full ${
currentEvent.status === 'live' ? 'bg-red-500 text-white animate-pulse' :
currentEvent.status === 'upcoming' ? 'bg-blue-500 text-white' :
currentEvent.status === 'completed' ? 'bg-gray-500 text-white' :
'bg-gray-400 text-white'
}`
}, (currentEvent.status || 'upcoming').toUpperCase())
)
)
),
React.createElement('div', { className: 'space-y-6' },
currentEvent.fantopark_package && React.createElement('div', null,
React.createElement('h3', { className: 'text-lg font-semibold mb-3 flex items-center' },
React.createElement('span', { className: 'mr-2' }, 'üì¶'),
'FanToPark Package'
),
React.createElement('div', { className: 'bg-blue-50 p-4 rounded-lg border border-blue-200' },
React.createElement('p', { className: 'text-blue-900 text-sm' },
currentEvent.fantopark_package
)
)
),
currentEvent.description && React.createElement('div', null,
React.createElement('h3', { className: 'text-lg font-semibold mb-3 flex items-center' },
React.createElement('span', { className: 'mr-2' }, 'üìù'),
'Description'
),
React.createElement('div', { className: 'bg-gray-50 p-4 rounded-lg' },
React.createElement('p', { className: 'text-gray-700 text-sm' },
currentEvent.description
)
)
)
)
),
React.createElement('div', { className: 'px-6 pb-6 flex flex-wrap gap-3' },
React.createElement('button', {
onClick: () => {
setEventFormData({
...currentEvent,
event_name: currentEvent.event_name || currentEvent.title,
start_date: currentEvent.start_date || currentEvent.date,
start_time: currentEvent.start_time || currentEvent.time,
venue: currentEvent.venue,
sport_type: currentEvent.sport_type || currentEvent.category,
priority: currentEvent.priority,
status: currentEvent.status,
description: currentEvent.description,
fantopark_package: currentEvent.fantopark_package
});
setShowEventDetail(false);
setShowEventForm(true);
},
className: 'px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-medium transition-colors flex items-center gap-2'
},
React.createElement('span', null, '‚úèÔ∏è'),
'Edit Event'
),
React.createElement('button', {
onClick: () => {
console.log('Creating lead for event:', currentEvent.id);
},
className: 'px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 font-medium transition-colors flex items-center gap-2'
},
React.createElement('span', null, 'üéØ'),
'Create Lead'
),
React.createElement('button', {
onClick: () => setShowEventDetail(false),
className: 'px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50 font-medium transition-colors'
}, 'Close')
)
)
);
};



// 7. EVENT FORM MODAL
const renderEventFormModal = () => {
  if (!showEventForm) return null;

 const handleEventSubmit = async (e) => {
  e.preventDefault();
  
  try {
    // Sanitize event data - remove undefined values completely
    const sanitizeData = (data) => {
      const sanitized = {};
      Object.keys(data).forEach(key => {
        const value = data[key];
        
        // Only include non-undefined, non-null values
        if (value !== undefined && value !== null) {
          // Convert empty strings to actual empty strings, not null
          if (typeof value === 'string') {
            sanitized[key] = value.trim();
          } else if (typeof value === 'number' && !isNaN(value)) {
            sanitized[key] = value;
          } else if (typeof value === 'boolean') {
            sanitized[key] = value;
          } else if (value !== '') {
            sanitized[key] = value;
          }
        }
        // Skip completely if undefined, null, or problematic
      });
      return sanitized;
    };

    // Build clean event data object
    const cleanEventData = {};
    
    // Required fields
    if (eventFormData.event_name && eventFormData.event_name.trim()) {
      cleanEventData.event_name = eventFormData.event_name.trim();
    }
    if (eventFormData.event_type && eventFormData.event_type.trim()) {
      cleanEventData.event_type = eventFormData.event_type.trim();
    }
    if (eventFormData.sport_type && eventFormData.sport_type.trim()) {
      cleanEventData.sport_type = eventFormData.sport_type.trim();
    }
    if (eventFormData.geography && eventFormData.geography.trim()) {
      cleanEventData.geography = eventFormData.geography.trim();
    }
    if (eventFormData.start_date && eventFormData.start_date.trim()) {
      cleanEventData.start_date = eventFormData.start_date.trim();
    }
    if (eventFormData.venue && eventFormData.venue.trim()) {
      cleanEventData.venue = eventFormData.venue.trim();
    }
    if (eventFormData.priority && eventFormData.priority.trim()) {
      cleanEventData.priority = eventFormData.priority.trim();
    }
    
    // Optional fields - only add if they have actual values
    if (eventFormData.end_date && eventFormData.end_date.trim()) {
      cleanEventData.end_date = eventFormData.end_date.trim();
    }
    if (eventFormData.start_time && eventFormData.start_time.trim()) {
      cleanEventData.start_time = eventFormData.start_time.trim();
    }
    if (eventFormData.end_time && eventFormData.end_time.trim()) {
      cleanEventData.end_time = eventFormData.end_time.trim();
    }
    if (eventFormData.venue_capacity && eventFormData.venue_capacity !== '') {
      const capacity = parseInt(eventFormData.venue_capacity);
      if (!isNaN(capacity)) {
        cleanEventData.venue_capacity = capacity;
      }
    }
    if (eventFormData.venue_address && eventFormData.venue_address.trim()) {
      cleanEventData.venue_address = eventFormData.venue_address.trim();
    }
    if (eventFormData.official_ticketing_partners && eventFormData.official_ticketing_partners.trim()) {
      cleanEventData.official_ticketing_partners = eventFormData.official_ticketing_partners.trim();
    }
    if (eventFormData.primary_source && eventFormData.primary_source.trim()) {
      cleanEventData.primary_source = eventFormData.primary_source.trim();
    }
    if (eventFormData.secondary_source && eventFormData.secondary_source.trim()) {
      cleanEventData.secondary_source = eventFormData.secondary_source.trim();
    }
    if (eventFormData.sold_out_potential && eventFormData.sold_out_potential.trim()) {
      cleanEventData.sold_out_potential = eventFormData.sold_out_potential.trim();
    }
    if (eventFormData.remarks && eventFormData.remarks.trim()) {
      cleanEventData.remarks = eventFormData.remarks.trim();
    }
    if (eventFormData.fantopark_package && eventFormData.fantopark_package.trim()) {
      cleanEventData.fantopark_package = eventFormData.fantopark_package.trim();
    }
    
    // Boolean field
    cleanEventData.ticket_available = Boolean(eventFormData.ticket_available);
    
    // Status with default
    cleanEventData.status = eventFormData.status && eventFormData.status.trim() ? eventFormData.status.trim() : 'upcoming';

    console.log('Sending clean event data:', cleanEventData); // Debug log

    const url = currentEvent ? `${window.API_CONFIG.API_URL}/events/${currentEvent.id}` : `${window.API_CONFIG.API_URL}/events`;
    const method = currentEvent ? 'PUT' : 'POST';
    
    const response = await fetch(url, {
      method: method,
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${localStorage.getItem('crm_auth_token')}`
      },
      body: JSON.stringify(cleanEventData)
    });

    const result = await response.json();
    
    if (result.success) {
      // Refresh events list
      await fetchSportsEvents();
      setShowEventForm(false);
      setCurrentEvent(null);
      resetEventForm();
      alert(currentEvent ? 'Event updated successfully!' : 'Event created successfully!');
    } else {
      throw new Error(result.error || 'Failed to save event');
    }
  } catch (error) {
    console.error('Error saving event:', error);
    alert('Error saving event: ' + error.message);
  }
};





  const resetEventForm = () => {
    setEventFormData({
      event_name: '',
      event_type: '',
      sport_type: '',
      geography: '',
      start_date: '',
      end_date: '',
      start_time: '',
      end_time: '',
      venue: '',
      venue_capacity: '',
      venue_address: '',
      official_ticketing_partners: '',
      primary_source: '',
      secondary_source: '',
      ticket_available: false,
      priority: '',
      status: 'upcoming',
      sold_out_potential: '',
      remarks: '',
      fantopark_package: ''
    });
  };

  const renderFormSection = (sectionName, title) => {
    const sectionFields = eventFormFields.filter(field => field.section === sectionName);
    
    return React.createElement('div', { className: 'mb-6' },
      React.createElement('h3', { className: 'text-lg font-semibold text-gray-900 mb-3 border-b pb-2' }, title),
      React.createElement('div', { className: 'grid grid-cols-1 md:grid-cols-2 gap-4' },
        ...sectionFields.map(field => {
          if (field.type === 'textarea') {
            return React.createElement('div', { key: field.name, className: 'md:col-span-2' },
              React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-1' }, 
                field.label + (field.required ? ' *' : '')
              ),
              React.createElement('textarea', {
                value: eventFormData[field.name] || '',
                onChange: (e) => setEventFormData({...eventFormData, [field.name]: e.target.value}),
                className: 'w-full p-2 border border-gray-300 rounded-lg',
                required: field.required,
                rows: 3,
                placeholder: field.placeholder || ''
              })
            );
          } else if (field.type === 'select') {
            return React.createElement('div', { key: field.name },
              React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-1' }, 
                field.label + (field.required ? ' *' : '')
              ),
              React.createElement('select', {
                value: eventFormData[field.name] || '',
                onChange: (e) => setEventFormData({...eventFormData, [field.name]: e.target.value}),
                className: 'w-full p-2 border border-gray-300 rounded-lg',
                required: field.required
              },
                React.createElement('option', { value: '' }, `Select ${field.label}`),
                ...field.options.map(option =>
                  React.createElement('option', { key: option, value: option }, option)
                )
              )
            );
          } else if (field.type === 'checkbox') {
            return React.createElement('div', { key: field.name, className: 'flex items-center' },
              React.createElement('input', {
                type: 'checkbox',
                checked: eventFormData[field.name] || false,
                onChange: (e) => setEventFormData({...eventFormData, [field.name]: e.target.checked}),
                className: 'mr-2',
                id: field.name
              }),
              React.createElement('label', { 
                htmlFor: field.name,
                className: 'text-sm font-medium text-gray-700' 
              }, field.label)
            );
          } else {
            return React.createElement('div', { key: field.name },
              React.createElement('label', { className: 'block text-sm font-medium text-gray-700 mb-1' }, 
                field.label + (field.required ? ' *' : '')
              ),
              React.createElement('input', {
                type: field.type,
                value: eventFormData[field.name] || '',
                onChange: (e) => setEventFormData({...eventFormData, [field.name]: e.target.value}),
                className: 'w-full p-2 border border-gray-300 rounded-lg',
                required: field.required,
                placeholder: field.placeholder || ''
              })
            );
          }
        })
      )
    );
  };

  return React.createElement('div', {
    className: 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50',
    onClick: () => setShowEventForm(false)
  },
    React.createElement('div', {
      className: 'bg-white dark:bg-gray-800 rounded-lg w-full max-w-4xl max-h-[90vh] overflow-y-auto',
      onClick: (e) => e.stopPropagation()
    },
      React.createElement('form', { onSubmit: handleEventSubmit, className: 'p-6' },
        React.createElement('div', { className: 'flex justify-between items-center mb-6' },
          React.createElement('h2', { className: 'text-2xl font-bold' }, 
            currentEvent ? 'Edit Event' : 'Add New Event'
          ),
          React.createElement('button', {
            type: 'button',
            onClick: () => setShowEventForm(false),
            className: 'text-gray-400 hover:text-gray-600 text-2xl'
          }, '‚úï')
        ),

        // Form sections
        renderFormSection('basic', 'üìÖ Basic Information'),
        renderFormSection('datetime', '‚è∞ Date & Time'),
        renderFormSection('venue', 'üèüÔ∏è Venue Details'),
        renderFormSection('ticketing', 'üé´ Ticketing Information'),
        renderFormSection('status', 'üìä Priority & Status'),
        renderFormSection('additional', 'üìù Additional Information'),

        // Form actions
        React.createElement('div', { className: 'flex justify-end space-x-3 mt-6 pt-6 border-t' },
          React.createElement('button', {
            type: 'button',
            onClick: () => setShowEventForm(false),
            className: 'px-6 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50'
          }, 'Cancel'),
          React.createElement('button', {
            type: 'submit',
            className: 'px-6 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-medium'
          }, currentEvent ? 'Update Event' : 'Create Event')
        )
      )
    )
  );
};

// FIXED: CSVUploadModal with proper preview flow handling
const CSVUploadModal = ({ isOpen, onClose, type }) => {
const [file, setFile] = useState(null);
const [uploading, setUploading] = useState(false);
const [uploadResult, setUploadResult] = useState(null);
const [proceedAfterPreview, setProceedAfterPreview] = useState(false); // NEW: Track if we should proceed after preview

// Enhanced file validation for both CSV and Excel (keeping your existing logic)
const handleFileChange = (e) => {
const selectedFile = e.target.files[0];
const allowedTypes = [
'text/csv',
'application/vnd.ms-excel',
'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
];

const isValidFile = allowedTypes.includes(selectedFile.type) || 
selectedFile.name.endsWith('.csv') || 
selectedFile.name.endsWith('.xlsx') || 
selectedFile.name.endsWith('.xls');

if (selectedFile && isValidFile) {
setFile(selectedFile);
window.currentUploadFile = selectedFile; // Store globally for preview flow
setUploadResult(null); // Clear previous results
setProceedAfterPreview(false); // Reset proceed flag
} else {
alert('Please select a valid CSV or Excel file (.csv, .xlsx, .xls)');
}
};



// NEW: Preview function for smart client detection (only for leads)
const handlePreview = async () => {
if (!file) {
alert('Please select a file first');
return;
}

setPreviewLoading(true);
const formData = new FormData();
formData.append('file', file);

try {
const response = await fetch(`${window.API_CONFIG.API_URL}/upload/leads/csv/preview`, {
method: 'POST',
headers: {
'Authorization': authToken ? 'Bearer ' + authToken : undefined
},
body: formData
});

const result = await response.json();
if (response.ok) {
setUploadPreview(result);
setShowPreview(true);
} else {
alert('Preview failed: ' + (result.error || 'Unknown error'));
}
} catch (error) {
alert('Preview error: ' + error.message);
} finally {
setPreviewLoading(false);
}
};



// Enhanced upload function (updated from your existing one)
const handleUpload = async () => {
if (!file) {
alert('Please select a file first');
return;
}

setUploading(true);
const formData = new FormData();
formData.append('file', file);

try {
const response = await fetch(`${window.API_CONFIG.API_URL}/upload/${type}/csv`, {
method: 'POST',
headers: {
'Authorization': authToken ? 'Bearer ' + authToken : undefined
},
body: formData
});

const result = await response.json();
if (response.ok) {
setUploadResult(result);

// NEW: Handle smart client detection results
if (result.clientDetectionResults && result.clientDetectionResults.length > 0) {
setClientDetectionResults(result.clientDetectionResults);
setShowClientDetectionResults(true);
}

// Refresh data (keeping your existing logic)
if (type === 'leads') {
const leadsData = await window.apicall('/leads');
setLeads(leadsData.data || []);
} else if (type === 'inventory') {
const inventoryData = await window.apicall('/inventory');
setInventory(inventoryData.data || []);
}

// NEW: Show enhanced success message
showEnhancedUploadSummary(result);

} else {
alert('Upload failed: ' + (result.error || 'Unknown error'));
}
} catch (error) {
alert('Upload error: ' + error.message);
} finally {
setUploading(false);
}
};



// NEW: Function to handle proceed from preview
const handleProceedFromPreview = () => {
setShowPreview(false);
setProceedAfterPreview(true);
// Trigger upload after a small delay to ensure state is updated
setTimeout(() => {
handleUpload();
}, 100);
};



// NEW: Enhanced upload summary function
const showEnhancedUploadSummary = (result) => {
let message = `üéâ Upload completed!\n\n`;
message += `‚úÖ Successfully imported: ${result.successCount} ${type}\n`;

if (result.errorCount > 0) {
message += `‚ùå Failed: ${result.errorCount} ${type}\n`;
}

// Smart client detection summary (only for leads)
if (type === 'leads' && result.clientDetectionCount > 0) {
message += `\nüîç Smart Client Detection:\n`;
message += `üìû Existing clients found: ${result.clientDetectionCount}\n`;
message += `üë§ New clients: ${result.summary?.new_clients || 0}\n`;
}

if (type === 'leads' && result.autoAssignmentCount > 0) {
message += `\nüéØ Auto-assignments: ${result.autoAssignmentCount}\n`;
}

if (type === 'leads' && result.clientAssignmentCount > 0) {
message += `üìã Client-based assignments: ${result.clientAssignmentCount}\n`;
}

if (type === 'leads' && result.summary) {
message += `\nüìä Assignment Summary:\n`;
message += `‚Ä¢ Auto-assigned: ${result.summary.auto_assigned}\n`;
message += `‚Ä¢ Client-assigned: ${result.summary.client_assigned}\n`;
message += `‚Ä¢ Manually assigned: ${result.summary.manually_assigned}\n`;
message += `‚Ä¢ Unassigned: ${result.summary.unassigned}\n`;
}

alert(message);
};


if (!isOpen) return null;

return React.createElement('div', {
className: 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50'
},
React.createElement('div', {
className: 'bg-white dark:bg-gray-800 rounded-lg p-6 max-w-4xl w-full mx-4 max-h-[90vh] overflow-y-auto'
},
// Modal Header (keeping your existing design)
React.createElement('div', {
className: 'flex items-center justify-between mb-4'
},
React.createElement('h2', {
className: 'text-2xl font-bold text-gray-900 dark:text-white'
}, `Upload ${type === 'leads' ? 'Leads' : 'Inventory'} (CSV/Excel)`),

React.createElement('button', {
onClick: onClose,
className: 'text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200'
}, '‚úï')
),

// NEW: Smart Client Detection Notice (only for leads)
type === 'leads' && React.createElement('div', {
className: 'mb-6 p-4 bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-700 rounded-lg'
},
React.createElement('h3', {
className: 'font-semibold text-blue-800 dark:text-blue-200 mb-2'
}, 'üîç Smart Client Detection Enabled'),
React.createElement('ul', {
className: 'text-blue-700 dark:text-blue-300 text-sm space-y-1'
},
React.createElement('li', null, '‚Ä¢ Automatically detects existing clients by phone number'),
React.createElement('li', null, '‚Ä¢ Auto-assigns leads to the same person who handled previous leads'),
React.createElement('li', null, '‚Ä¢ Groups leads by client with relationship tracking'),
React.createElement('li', null, '‚Ä¢ Preview your upload to review assignments before import')
)
),

// Instructions (keeping your existing design)
React.createElement('div', {
className: 'mb-6 p-4 bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-700 rounded-lg'
},
React.createElement('p', {
className: 'text-blue-800 dark:text-blue-200 mb-2'
}, 'üìã Upload a CSV or Excel file to bulk import your data.'),
React.createElement('p', {
className: 'text-blue-700 dark:text-blue-300 text-sm'
}, 'üí° Excel files include validation guidance and clear instructions!')
),

// Download Templates Section (keeping your existing design)
React.createElement('div', {
className: 'mb-6 p-4 bg-gray-50 dark:bg-gray-700 rounded-lg'
},
React.createElement('h3', {
className: 'font-semibold mb-3 text-gray-900 dark:text-white'
}, 'üì• Download Sample Templates:'),

React.createElement('div', {
className: 'grid grid-cols-1 md:grid-cols-3 gap-2'
},
// CSV Download
React.createElement('button', {
onClick: window.downloadSampleCSV,
className: 'bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded-lg text-sm flex items-center justify-center gap-2 transition-colors'
}, 'üìÑ CSV Template'),

// Excel Method 1 - UPDATED LABEL
type === 'leads' && React.createElement('button', {
onClick: window.downloadSampleExcel,
className: 'bg-emerald-500 hover:bg-emerald-600 text-white px-4 py-2 rounded-lg text-sm flex items-center justify-center gap-2 transition-colors'
}, 'üìä Excel (Advanced)'),

// Excel Method 2 - UPDATED LABEL
type === 'leads' && React.createElement('button', {
onClick: window.window.downloadSampleExcelV2,
className: 'bg-teal-500 hover:bg-teal-600 text-white px-4 py-2 rounded-lg text-sm flex items-center justify-center gap-2 transition-colors'
}, 'üìã Excel (Instructions)')
),

type === 'leads' && React.createElement('p', {
className: 'text-xs text-gray-600 dark:text-gray-400 mt-3 bg-yellow-50 dark:bg-yellow-900/20 p-2 rounded border-l-4 border-yellow-400'
}, 'üéØ Try "Excel (Instructions)" for the clearest guidance - includes validation options and examples!')
),

// File Upload Section (keeping your existing design)
React.createElement('div', {
className: 'mb-6 p-4 border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg'
},
React.createElement('h3', {
className: 'font-semibold mb-3 text-gray-900 dark:text-white'
}, 'üì§ Upload Your File:'),

React.createElement('input', {
type: 'file',
accept: '.csv,.xlsx,.xls,application/vnd.ms-excel,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
onChange: handleFileChange,
className: 'block w-full mb-3 text-gray-900 dark:text-white file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100'
}),

file && React.createElement('div', {
className: 'flex items-center gap-2 text-sm text-gray-600 dark:text-gray-400 bg-green-50 dark:bg-green-900/20 p-2 rounded'
},
React.createElement('span', null, '‚úÖ'),
React.createElement('span', null, `Selected: ${file.name} (${(file.size / 1024).toFixed(1)} KB)`)
)
),

// NEW: Preview Section (only for leads)
type === 'leads' && file && React.createElement('div', {
className: 'mb-6 p-4 bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-700 rounded-lg'
},
React.createElement('h3', {
className: 'font-semibold mb-3 text-yellow-800 dark:text-yellow-200'
}, 'üîç Smart Client Detection Preview'),
React.createElement('p', {
className: 'text-yellow-700 dark:text-yellow-300 text-sm mb-3'
}, 'Preview your upload to see which leads will be assigned based on existing client relationships.'),
React.createElement('button', {
onClick: handlePreview,
disabled: previewLoading,
className: 'bg-yellow-500 hover:bg-yellow-600 text-white px-4 py-2 rounded-lg text-sm flex items-center gap-2 disabled:opacity-50'
},
previewLoading && React.createElement('div', {
className: 'animate-spin rounded-full h-4 w-4 border-b-2 border-white'
}),
previewLoading ? 'Loading Preview...' : 'üîç Preview Upload'
)
),

// Upload Results (enhanced from your existing design)
uploadResult && React.createElement('div', {
className: `mb-6 p-4 rounded-lg ${
uploadResult.errorCount > 0 
? 'bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-700' 
: 'bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-700'
}`
},
React.createElement('div', {
className: 'flex items-center gap-2 mb-2'
},
React.createElement('span', {
className: 'text-lg'
}, uploadResult.errorCount > 0 ? '‚ö†Ô∏è' : '‚úÖ'),
React.createElement('p', {
className: `font-semibold ${
uploadResult.errorCount > 0 
? 'text-yellow-800 dark:text-yellow-200' 
: 'text-green-800 dark:text-green-200'
}`
}, uploadResult.message)
),

// Enhanced success metrics
uploadResult.successCount > 0 && React.createElement('div', {
className: 'text-sm text-green-700 dark:text-green-300 space-y-1'
},
React.createElement('p', null, `‚úÖ Successfully imported: ${uploadResult.successCount} records`),

// Smart client detection results (only for leads)
type === 'leads' && uploadResult.clientDetectionCount > 0 && React.createElement('p', null, 
`üîç Existing clients detected: ${uploadResult.clientDetectionCount}`),

type === 'leads' && uploadResult.autoAssignmentCount > 0 && React.createElement('p', null, 
`üéØ Auto-assignments applied: ${uploadResult.autoAssignmentCount}`),

type === 'leads' && uploadResult.clientAssignmentCount > 0 && React.createElement('p', null, 
`üìã Client-based assignments: ${uploadResult.clientAssignmentCount}`)
),

// Show client detection details button
type === 'leads' && uploadResult.clientDetectionResults && uploadResult.clientDetectionResults.length > 0 && 
React.createElement('button', {
onClick: () => setShowClientDetectionResults(true),
className: 'mt-2 text-blue-600 hover:text-blue-800 text-sm underline'
}, 'View Smart Client Detection Details ‚Üí'),

// Error section (keeping your existing design)
uploadResult.errors && uploadResult.errors.length > 0 && React.createElement('div', {
className: 'mt-3'
},
React.createElement('p', {
className: 'text-sm font-semibold text-red-700 dark:text-red-300 mb-2'
}, `‚ùå Errors found (${uploadResult.errors.length}):`),
React.createElement('div', {
className: 'max-h-32 overflow-y-auto bg-white dark:bg-gray-800 p-2 rounded border'
},
uploadResult.errors.map((error, index) => 
React.createElement('p', {
key: index,
className: 'text-xs text-red-600 dark:text-red-400 mb-1'
}, `Row ${error.row}: ${error.error}`)
)
)
)
),

// Action Buttons (keeping your existing design)
React.createElement('div', {
className: 'flex justify-end gap-3 pt-4 border-t border-gray-200 dark:border-gray-600'
},
React.createElement('button', {
onClick: onClose,
className: 'px-6 py-2 bg-gray-300 dark:bg-gray-600 text-gray-700 dark:text-gray-200 rounded-lg hover:bg-gray-400 dark:hover:bg-gray-700 transition-colors'
}, 'Cancel'),

React.createElement('button', {
onClick: handleUpload,
disabled: !file || uploading,
className: `px-6 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors ${
uploading ? 'animate-pulse' : ''
}`
}, uploading ? 'Uploading...' : 'Upload File')
)
)
);
};



// UPDATED: Upload Preview Modal Component with proper continue functionality
const UploadPreviewModal = () => {
if (!showPreview || !uploadPreview) return null;

return React.createElement('div', {
className: 'fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center z-50'
},
React.createElement('div', {
className: 'bg-white rounded-lg p-6 max-w-6xl max-h-5/6 overflow-auto'
},
React.createElement('div', {
className: 'flex justify-between items-center mb-4'
},
React.createElement('h3', {
className: 'text-lg font-semibold'
}, 'Bulk Upload Preview - Smart Client Detection'),
React.createElement('button', {
onClick: () => setShowPreview(false),
className: 'text-gray-400 hover:text-gray-600'
}, '‚úï')
),

// Summary
React.createElement('div', {
className: 'mb-6 p-4 bg-blue-50 rounded-lg'
},
React.createElement('h4', {
className: 'font-semibold mb-2'
}, 'üìä Upload Summary'),
React.createElement('div', {
className: 'grid grid-cols-2 md:grid-cols-4 gap-4 text-sm'
},
React.createElement('div', null,
React.createElement('span', { className: 'font-medium' }, 'Total Rows: '),
uploadPreview.total_rows
),
React.createElement('div', null,
React.createElement('span', { className: 'font-medium' }, 'Existing Clients: '),
uploadPreview.client_detection_summary.existing_clients_found
),
React.createElement('div', null,
React.createElement('span', { className: 'font-medium' }, 'New Clients: '),
uploadPreview.client_detection_summary.new_clients
),
React.createElement('div', null,
React.createElement('span', { className: 'font-medium' }, 'Will Auto-assign: '),
uploadPreview.client_detection_summary.will_be_client_assigned
)
)
),

// Preview Table
React.createElement('div', {
className: 'overflow-x-auto'
},
React.createElement('table', {
className: 'min-w-full table-auto border-collapse border'
},
React.createElement('thead', null,
React.createElement('tr', { className: 'bg-gray-50' },
React.createElement('th', { className: 'border p-2 text-left' }, 'Row'),
React.createElement('th', { className: 'border p-2 text-left' }, 'Name'),
React.createElement('th', { className: 'border p-2 text-left' }, 'Phone'),
React.createElement('th', { className: 'border p-2 text-left' }, 'CSV Assignment'),
React.createElement('th', { className: 'border p-2 text-left' }, 'Client Status'),
React.createElement('th', { className: 'border p-2 text-left' }, 'Final Assignment'),
React.createElement('th', { className: 'border p-2 text-left' }, 'Existing Leads')
)
),
React.createElement('tbody', null,
uploadPreview.preview.map((row, index) =>
React.createElement('tr', {
key: index,
className: row.client_detected ? 'bg-yellow-50' : 'bg-white'
},
React.createElement('td', { className: 'border p-2' }, row.row),
React.createElement('td', { className: 'border p-2' }, row.name),
React.createElement('td', { className: 'border p-2' }, row.phone),
React.createElement('td', { className: 'border p-2' }, row.assigned_to_in_csv || 'None'),
React.createElement('td', { className: 'border p-2' },
row.client_detected ? 
React.createElement('span', {
className: 'bg-yellow-200 text-yellow-800 px-2 py-1 rounded text-xs'
}, 'üìû Existing Client') :
React.createElement('span', {
className: 'bg-green-200 text-green-800 px-2 py-1 rounded text-xs'
}, 'üë§ New Client')
),
React.createElement('td', { className: 'border p-2' },
React.createElement('span', {
className: row.will_override_assignment ? 'bg-blue-200 text-blue-800 px-2 py-1 rounded text-xs' : ''
}, row.final_assigned_to)
),
React.createElement('td', { className: 'border p-2' },
row.existing_leads_count > 0 ? 
React.createElement('span', { className: 'text-sm' },
`${row.existing_leads_count} leads`,
row.existing_events.length > 0 && 
React.createElement('div', { className: 'text-xs text-gray-600' },
`Events: ${row.existing_events.join(', ')}`
)
) : 'None'
)
)
)
)
)
),

// Action Buttons
React.createElement('div', {
className: 'mt-6 flex justify-end space-x-3'
},
React.createElement('button', {
onClick: () => setShowPreview(false),
className: 'px-4 py-2 border border-gray-300 rounded-md hover:bg-gray-50'
}, 'Cancel'),
React.createElement('button', {
onClick: () => {
handleProceedFromPreview();
},
className: 'px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700'
}, 'Continue to Upload')
)
)
);
};



// Client Detection Results Modal Component
const ClientDetectionResultsModal = () => {
if (!showClientDetectionResults || !clientDetectionResults.length) return null;

return React.createElement('div', {
className: 'fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center z-50'
},
React.createElement('div', {
className: 'bg-white rounded-lg p-6 max-w-4xl max-h-5/6 overflow-auto'
},
React.createElement('div', {
className: 'flex justify-between items-center mb-4'
},
React.createElement('h3', {
className: 'text-lg font-semibold'
}, 'üîç Smart Client Detection Results'),
React.createElement('button', {
onClick: () => setShowClientDetectionResults(false),
className: 'text-gray-400 hover:text-gray-600'
}, '‚úï')
),

React.createElement('div', {
className: 'overflow-x-auto'
},
React.createElement('table', {
className: 'min-w-full table-auto border-collapse border'
},
React.createElement('thead', null,
React.createElement('tr', { className: 'bg-gray-50' },
React.createElement('th', { className: 'border p-2 text-left' }, 'Row'),
React.createElement('th', { className: 'border p-2 text-left' }, 'Lead Name'),
React.createElement('th', { className: 'border p-2 text-left' }, 'Phone'),
React.createElement('th', { className: 'border p-2 text-left' }, 'Existing Leads'),
React.createElement('th', { className: 'border p-2 text-left' }, 'Assigned To'),
React.createElement('th', { className: 'border p-2 text-left' }, 'Previous Events')
)
),
React.createElement('tbody', null,
clientDetectionResults.map((result, index) =>
React.createElement('tr', {
key: index,
className: 'bg-yellow-50'
},
React.createElement('td', { className: 'border p-2' }, result.row),
React.createElement('td', { className: 'border p-2' }, result.lead_name),
React.createElement('td', { className: 'border p-2' }, result.phone),
React.createElement('td', { className: 'border p-2' }, result.total_existing_leads),
React.createElement('td', { className: 'border p-2' }, result.assigned_to_from_detection),
React.createElement('td', { className: 'border p-2' },
result.existing_events?.length > 0 ?
React.createElement('div', { className: 'text-sm' },
result.existing_events.join(', ')
) : 'None'
)
)
)
)
)
),

React.createElement('div', {
className: 'mt-6 flex justify-end'
},
React.createElement('button', {
onClick: () => setShowClientDetectionResults(false),
className: 'px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700'
}, 'Close')
)
)
);
}; 


// Main application layout

const renderHelpGuide = () => {
if (!showHelpGuide) return null;

return React.createElement('div', { 
className: 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4',
onClick: () => setShowHelpGuide(false)
},
React.createElement('div', { 
className: 'bg-white dark:bg-gray-800 rounded-lg max-w-2xl w-full p-6',
onClick: (e) => e.stopPropagation()
},
React.createElement('div', { className: 'flex justify-between items-center mb-4' },
React.createElement('h2', { className: 'text-2xl font-bold text-gray-900 dark:text-white' }, 'How to Use FanToPark CRM'),
React.createElement('button', {
onClick: () => setShowHelpGuide(false),
className: 'text-gray-500 hover:text-gray-700'
}, '‚úï')
),
React.createElement('div', { className: 'space-y-4 text-gray-700 dark:text-gray-300' },
React.createElement('h3', { className: 'font-bold text-lg' }, 'Workflow Overview:'),
React.createElement('ol', { className: 'list-decimal list-inside space-y-2' },
React.createElement('li', null, 'Sales Team: Create and qualify leads (Hot/Warm/Cold)'),
React.createElement('li', null, 'Sales Team: Convert qualified leads to orders'),
React.createElement('li', null, 'Finance Team: Approve orders (or Sales Head for Payment Post Service)'),
React.createElement('li', null, 'Supply Team: Schedule and manage deliveries'),
React.createElement('li', null, 'Finance Team: Generate invoices and track payments')
),
React.createElement('div', { className: 'mt-4 pt-4 border-t' },
React.createElement('p', { className: 'font-medium' }, 'Quick Tips:'),
React.createElement('ul', { className: 'list-disc list-inside mt-2 space-y-1 text-sm' },
React.createElement('li', null, 'Use the dark mode toggle for comfortable viewing'),
React.createElement('li', null, 'Check "My Actions" tab for your pending tasks'),
React.createElement('li', null, 'All actions are logged and tracked automatically')
)
)
)
)
);
};



return React.createElement('div', { className: 'flex h-screen bg-gray-100 dark:bg-gray-900' },
renderSidebar(),
React.createElement('div', { className: 'flex-1 flex flex-col overflow-hidden' },
React.createElement('header', { className: 'bg-white dark:bg-gray-800 shadow-sm border-b dark:border-gray-700 px-6 py-4' },
React.createElement('div', { className: 'flex items-center justify-between' },
React.createElement('div', null,
React.createElement('h1', { className: 'text-lg font-semibold' }, 'Welcome, ' + (user?.name || 'Admin User')),
React.createElement('p', { className: 'text-sm text-gray-600 dark:text-gray-400' }, window.USER_ROLES[user?.role]?.label + ' ‚Ä¢ ' + user?.department)
),
React.createElement('div', { className: 'flex items-center space-x-4' },
React.createElement('span', { className: 'text-lg' }, 'üîî'),
React.createElement('button', {
onClick: () => setShowHelpGuide(true),
className: 'p-2 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors',
title: 'How to use CRM'
}, '‚ùì'),
React.createElement('button', {
onClick: () => {
setDarkMode(!darkMode);
document.documentElement.classList.toggle('dark');
localStorage.setItem('crm_dark_mode', !darkMode);
},
className: 'p-2 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors',
title: darkMode ? 'Switch to light mode' : 'Switch to dark mode'
}, darkMode ? '‚òÄÔ∏è' : 'üåô'),
React.createElement('div', { className: 'w-8 h-8 bg-blue-600 rounded-full flex items-center justify-center' },
React.createElement('span', { className: 'text-white text-sm' }, (user?.name || 'A')[0])
),
currentUser && currentUser.role === 'super_admin' && React.createElement('div', { 
className: 'flex items-center gap-2 ml-4'
},
React.createElement('button', {
onClick: () => {
const newMode = !testMode;
setTestMode(newMode);
localStorage.setItem('testMode', newMode.toString());
if (newMode) {
document.body.classList.add('test-mode-active');
} else {
document.body.classList.remove('test-mode-active');
}
},
className: 'relative inline-flex h-6 w-12 items-center rounded-full transition-colors ' + 
(testMode ? 'bg-red-600' : 'bg-gray-300'),
title: 'Toggle Test Mode'
},
React.createElement('span', {
className: 'inline-block h-4 w-4 transform rounded-full bg-white transition-transform ' +
(testMode ? 'translate-x-6' : 'translate-x-1')
})
),
testMode && React.createElement('span', { 
className: 'text-red-600 font-bold text-sm ml-2'
}, 'TEST MODE')
)
)
)
),
React.createElement('main', { className: 'flex-1 overflow-y-auto p-6' },
testMode && user.role === 'super_admin' && React.createElement('div', {
className: 'bg-red-100 border-2 border-red-500 text-red-700 p-4 rounded-lg mb-4 text-center font-bold animate-pulse'
}, 
'‚ö†Ô∏è TEST MODE ACTIVE - Delete buttons and test data fills are enabled!'
),
window.renderContent()
)
),
// Modal forms
ReminderDashboard(),  
renderInventoryForm(),                           
renderForm(),
showCSVUploadModal && React.createElement(CSVUploadModal, {
isOpen: showCSVUploadModal,
onClose: () => {
setShowCSVUploadModal(false);
setCSVUploadType('');
},
type: csvUploadType,
authToken: authToken
}),
renderAssignForm(),
renderBulkAssignModal(),                           
renderPaymentForm(),
renderLeadDetail(),
showInventoryDetail && renderInventoryDetail(),                   
renderAllocationForm(),
renderAllocationManagement(),
renderStadiumForm(),                           
renderChoiceModal(),
renderUserManagement(),
renderStatusProgressModal(),                           
renderUserForm(),
renderGSTInvoicePreview(),
renderOrderDetailModal(),
renderOrderAssignmentModal(),
renderOrderDetailModal(),
renderOrderAssignmentModal(),
renderDeliveryForm(),
renderOrderDetail(),
renderEditOrderForm(),
renderPaymentPostServiceForm(),
renderHelpGuide(),
showClientDetail && renderClientDetailModal(),
showEventDetail && renderEventDetailModal(),
showPreview && React.createElement(UploadPreviewModal),
showClientDetectionResults && React.createElement(ClientDetectionResultsModal),                           
showEventForm && renderEventFormModal() 
);
}

// Floating Test Mode Button for Super Admin
if (document.getElementById('root')) {
const checkAndAddTestButton = () => {
const user = JSON.parse(localStorage.getItem('crm_user') || '{}');
const authToken = localStorage.getItem('crm_auth_token');

if (user.role === 'super_admin' && authToken && !document.getElementById('test-mode-float')) {
const testModeState = localStorage.getItem('testMode') === 'true';
const floatDiv = document.createElement('div');
floatDiv.id = 'test-mode-float';
floatDiv.style.cssText = 'position:fixed;bottom:20px;right:20px;z-index:9999;';

const button = document.createElement('button');
button.style.cssText = 'padding:12px 24px;border-radius:8px;font-weight:bold;color:white;cursor:pointer;box-shadow:0 4px 6px rgba(0,0,0,0.1);' +
'background-color:' + (testModeState ? '#dc2626' : '#10b981') + ';';
button.textContent = testModeState ? 'üß™ TEST MODE ON' : 'üß™ TEST MODE OFF';
button.onclick = () => {
const currentState = localStorage.getItem('testMode') === 'true';
const newState = !currentState;
localStorage.setItem('testMode', String(newState));
alert('Test mode ' + (newState ? 'ENABLED' : 'DISABLED') + '. Page will reload.');
window.location.reload();
};



floatDiv.appendChild(button);
document.body.appendChild(floatDiv);
}
};



// Check on load and after login
setTimeout(checkAndAddTestButton, 1000);
window.addEventListener('storage', checkAndAddTestButton);
}



// Render the app
ReactDOM.render(React.createElement(App), document.getElementById('root'));

</script>

<div id="test-control-panel" style="position:fixed; bottom:80px; left:20px; background:#1f2937; color:white; padding:15px; border-radius:8px; box-shadow:0 4px 6px rgba(0,0,0,0.3); display:none; z-index:9999; max-height:400px; overflow-y:auto; min-width:200px;">
<h3 style="margin:0 0 10px 0; font-size:16px; text-align:center;">üß™ Test Mode Controls</h3>
<p style="margin:5px 0; font-size:12px; color:#10b981; text-align:center;">‚úÖ Test Mode Active</p>
<hr style="margin:10px 0; border:none; border-top:1px solid #4b5563;">
<div style="margin-bottom:10px;">
<h4 style="margin:5px 0; font-size:14px; color:#f59e0b;">Create Test Data:</h4>
<button onclick="(async function() {
const authToken = localStorage.getItem('crm_auth_token');
// Using global window.API_CONFIG.API_URL variable

try {
// Get today's date in YYYY-MM-DD format
const today = new Date().toISOString().split('T')[0];

// Get inventory items to pick a random event
const invResponse = await fetch(window.API_CONFIG.API_URL + '/inventory', {
headers: { 'Authorization': 'Bearer ' + authToken }
});
let eventName = 'General Inquiry';
if (invResponse.ok) {
const invData = await invResponse.json();
if (invData.data && invData.data.length > 0) {
eventName = invData.data[Math.floor(Math.random() * invData.data.length)].event_name;
}
}

const cities = ['Mumbai City North East', 'Delhi NCR', 'Bangalore City', 'Chennai Metro', 'Kolkata Central'];
const sources = ['LinkedIn', 'Facebook', 'Instagram', 'Website', 'Friends and Family', 'Through Champion'];
const salesPeople = ['Ankita', 'Varun', 'Pratik', 'Rahul'];
const incomeBrackets = ['‚Çπ10-25 Lakhs', '‚Çπ25-50 Lakhs', '‚Çπ50-100 Lakhs', 'Above ‚Çπ1 Crore'];

const testData = {
// Basic info
name: 'Test Contact ' + Math.floor(Math.random() * 1000),
email: 'test' + Math.floor(Math.random() * 1000) + '@example.com',
phone: '8' + Math.floor(Math.random() * 900000000 + 100000000),
company: Math.random() > 0.5 ? 'Test Company ' + Math.floor(Math.random() * 100) : '',

// Business fields
business_type: Math.random() > 0.5 ? 'B2B' : 'B2C',
source: sources[Math.floor(Math.random() * sources.length)],

// Required date field
date_of_enquiry: today,

// Sales fields
first_touch_base_done_by: salesPeople[Math.floor(Math.random() * salesPeople.length)],

// Location
city_of_residence: cities[Math.floor(Math.random() * cities.length)],
country_of_residence: 'India',

// Event interest
lead_for_event: eventName,
number_of_people: String(Math.floor(Math.random() * 5) + 1),

// Travel readiness
has_valid_passport: Math.random() > 0.3 ? 'Yes' : 'No',
visa_available: Math.random() > 0.5 ? 'Yes' : 'No',
attended_sporting_event_before: Math.random() > 0.4 ? 'Yes' : 'No',

// Financial
annual_income_bracket: incomeBrackets[Math.floor(Math.random() * incomeBrackets.length)],
potential_value: Math.floor(Math.random() * 200000) + 50000,

// Status fields
status: 'unassigned',
assigned_to: '',
last_quoted_price: 0,
notes: 'Test lead created via test mode',

// Timestamps
created_date: new Date().toISOString(),
updated_date: new Date().toISOString()
};



console.log('Creating lead:', testData);

const response = await fetch(window.API_CONFIG.API_URL + '/leads', {
method: 'POST',
headers: {
'Authorization': 'Bearer ' + authToken,
'Content-Type': 'application/json'
},
body: JSON.stringify(testData)
});

const result = await response.json();

if (response.ok) {
alert('Test lead created successfully!');
window.location.reload();
} else {
console.error('Failed:', result);
alert('Error: ' + (result.error || result.message || 'Failed to create lead'));
}
} catch (error) {
console.error('Error:', error);
alert('Error: ' + error.message);
}
})();" style="display:block; width:100%; margin:5px 0; padding:8px; background:#f59e0b; color:white; border:none; border-radius:4px; cursor:pointer; font-size:13px;">üß™ Create Test Lead</button>
<button onclick="(async function() {
const authToken = localStorage.getItem('crm_auth_token');
// Using global window.API_CONFIG.API_URL variable

try {
const testData = {
event_name: 'Test Cricket Match ' + Math.floor(Math.random() * 1000),
event_date: new Date(Date.now() + 30*24*60*60*1000).toISOString().split('T')[0],
event_type: 'cricket',
sports: 'Cricket',
venue: 'Test Stadium Mumbai',
category_of_ticket: 'VIP',
total_tickets: 200,
available_tickets: 200,
mrp_of_ticket: 5000,
buying_price: 4000,
selling_price: 6000,
day_of_match: 'Not Applicable',
stand: 'North Stand',
inclusions: 'Snacks, Beverages, Parking',
booking_person: 'Test Supplier',
procurement_type: 'pre_inventory',
notes: 'Test inventory',
paymentStatus: 'paid',
created_by: JSON.parse(localStorage.getItem('crm_user') || '{}').name || 'Test User',
created_date: new Date().toISOString()
};



console.log('Creating inventory:', testData);

const response = await fetch(window.API_CONFIG.API_URL + '/inventory', {
method: 'POST',
headers: {
'Authorization': 'Bearer ' + authToken,
'Content-Type': 'application/json'
},
body: JSON.stringify(testData)
});

const result = await response.json();

if (response.ok) {
alert('Test inventory created successfully!');
window.location.reload();
} else {
console.error('Failed:', result);
alert('Error: ' + (result.error || result.message || 'Failed to create inventory'));
}
} catch (error) {
console.error('Error:', error);
alert('Error: ' + error.message);
}
})();" style="display:block; width:100%; margin:5px 0; padding:8px; background:#f59e0b; color:white; border:none; border-radius:4px; cursor:pointer; font-size:13px;">üß™ Create Test Inventory</button>
</div>
<hr style="margin:10px 0; border:none; border-top:1px solid #4b5563;">
<div style="margin-bottom:10px;">
<h4 style="margin:5px 0; font-size:14px; color:#dc2626;">Delete All Data:</h4>
<button onclick="window.deleteAllIndividually('leads')" style="display:block; width:100%; margin:5px 0; padding:8px; background:#dc2626; color:white; border:none; border-radius:4px; cursor:pointer; font-size:13px;">üóëÔ∏è Delete All Leads</button>
<button onclick="window.deleteAllIndividually('inventory')" style="display:block; width:100%; margin:5px 0; padding:8px; background:#dc2626; color:white; border:none; border-radius:4px; cursor:pointer; font-size:13px;">üóëÔ∏è Delete All Inventory</button>
<button onclick="window.deleteAllIndividually('orders')" style="display:block; width:100%; margin:5px 0; padding:8px; background:#dc2626; color:white; border:none; border-radius:4px; cursor:pointer; font-size:13px;">üóëÔ∏è Delete All Orders</button>
<button onclick="window.deleteAllIndividually('deliveries')" style="display:block; width:100%; margin:5px 0; padding:8px; background:#dc2626; color:white; border:none; border-radius:4px; cursor:pointer; font-size:13px;">üóëÔ∏è Delete All Deliveries</button>
<button 
onclick="window.deleteAllFinancials()"
style="
width: 100%;
padding: 8px 16px;
background-color: #dc2626;
color: white;
border: none;
border-radius: 6px;
cursor: pointer;
font-size: 14px;
font-weight: 500;
display: flex;
align-items: center;
justify-content: center;
gap: 8px;
transition: background-color 0.2s;
"
onmouseover="this.style.backgroundColor='#b91c1c'"
onmouseout="this.style.backgroundColor='#dc2626'"
>
üóëÔ∏è Delete All Financials
</button>
</div>
<hr style="margin:10px 0; border:none; border-top:1px solid #4b5563;">
<button onclick="window.location.reload();" style="display:block; width:100%; margin:5px 0; padding:8px; background:#3b82f6; color:white; border:none; border-radius:4px; cursor:pointer; font-size:13px;">üîÑ Refresh Page</button>
<button onclick="document.getElementById('test-control-panel').style.display='none';" style="display:block; width:100%; margin:5px 0; padding:6px; background:#6b7280; color:white; border:none; border-radius:4px; cursor:pointer; font-size:12px;">‚úñ Hide Panel</button>
</div>
<script>
// Show test control panel if test mode is on and user is super admin
window.updateTestPanel = function() {
const testMode = localStorage.getItem('testMode') === 'true';
const user = JSON.parse(localStorage.getItem('crm_user') || '{}');
const panel = document.getElementById('test-control-panel');
if (testMode && user.role === 'super_admin' && panel) {
panel.style.display = 'block';
}
};



// Delete all function
window.testDeleteAll = async function(type) {
const authToken = localStorage.getItem('crm_auth_token');
// Using global window.API_CONFIG.API_URL variable

try {
const response = await fetch(window.API_CONFIG.API_URL + '/' + type, {
method: 'DELETE',
headers: {
'Authorization': 'Bearer ' + authToken,
'X-Delete-All': 'true',
'X-Test-Mode': 'true'
}
});

if (response.ok) {
alert('All ' + type + ' deleted successfully!');
window.location.reload();
} else {
alert('Error: ' + response.statusText);
}
} catch (error) {
alert('Error: ' + error.message);
}
};



// Check on load
setTimeout(window.updateTestPanel, 1000);
</script>


<script>
// Test data creation functions
window.fillTestLead = function() {
if (confirm('Create a test lead?')) {
// Directly create test lead data
const testData = {
name: 'Test User ' + Math.floor(Math.random() * 1000),
email: 'test' + Math.floor(Math.random() * 1000) + '@example.com',
phone: '98' + Math.floor(Math.random() * 90000000 + 10000000),
company: 'Test Company ' + Math.floor(Math.random() * 100),
lead_for_event: 'General Inquiry',
lead_source: 'Website',
notes: 'Test lead created via test mode'
};



// Call the API directly
const authToken = localStorage.getItem('crm_auth_token');
// Using global window.API_CONFIG.API_URL variable

fetch(window.API_CONFIG.API_URL + '/leads', {
method: 'POST',
headers: {
'Authorization': 'Bearer ' + authToken,
'Content-Type': 'application/json'
},
body: JSON.stringify(testData)
})
.then(response => response.json())
.then(data => {
alert('Test lead created successfully!');
window.location.reload();
})
.catch(error => {
alert('Error creating test lead: ' + error.message);
});
}
};



window.fillTestInventory = function() {
if (confirm('Create a test inventory item?')) {
const categories = ['Stall', 'Equipment', 'Service', 'Package'];
const testData = {
name: 'Test Item ' + Math.floor(Math.random() * 1000),
category: categories[Math.floor(Math.random() * categories.length)],
price: Math.floor(Math.random() * 90000) + 10000,
quantity: Math.floor(Math.random() * 50) + 1,
description: 'Test inventory item created via test mode',
size: '10x10 ft',
location: 'Zone ' + Math.floor(Math.random() * 5 + 1)
};



const authToken = localStorage.getItem('crm_auth_token');
// Using global window.API_CONFIG.API_URL variable

fetch(window.API_CONFIG.API_URL + '/inventory', {
method: 'POST',
headers: {
'Authorization': 'Bearer ' + authToken,
'Content-Type': 'application/json'
},
body: JSON.stringify(testData)
})
.then(response => response.json())
.then(data => {
alert('Test inventory item created successfully!');
window.location.reload();
})
.catch(error => {
alert('Error creating test inventory: ' + error.message);
});
}
};


</script>


<script>
// Working delete function that deletes individually
window.deleteAllIndividually = async function(type) {
if (!confirm('Delete ALL ' + type + '? This will delete them one by one.')) {
return;
}

const authToken = localStorage.getItem('crm_auth_token');
// Using global window.API_CONFIG.API_URL variable

try {
// Show loading
const loadingDiv = document.createElement('div');
loadingDiv.id = 'delete-loading';
loadingDiv.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:white;padding:20px;border-radius:8px;box-shadow:0 4px 6px rgba(0,0,0,0.1);z-index:10000;';
loadingDiv.innerHTML = '<h3>Fetching ' + type + '...</h3>';
document.body.appendChild(loadingDiv);

// Get all items
const response = await fetch(window.API_CONFIG.API_URL + '/' + type, {
method: 'GET',
headers: {
'Authorization': 'Bearer ' + authToken,
'Content-Type': 'application/json'
}
});

if (!response.ok) {
throw new Error('Failed to fetch ' + type);
}

const result = await response.json();
const items = result.data || [];

if (items.length === 0) {
document.body.removeChild(loadingDiv);
alert('No ' + type + ' to delete');
return;
}

// Update loading message
loadingDiv.innerHTML = '<h3>Deleting ' + type + '...</h3><p>Progress: <span id="delete-progress">0</span> / ' + items.length + '</p>';

let deleted = 0;
let failed = 0;

// Delete each item
for (const item of items) {
try {
const deleteUrl = window.API_CONFIG.API_URL + '/' + type + '/' + item.id;
console.log('Deleting:', deleteUrl);

const deleteResponse = await fetch(deleteUrl, {
method: 'DELETE',
headers: {
'Authorization': 'Bearer ' + authToken
}
});

if (deleteResponse.ok) {
deleted++;
console.log('Deleted:', item.id);
} else {
failed++;
console.log('Failed to delete:', item.id, deleteResponse.status);
}

document.getElementById('delete-progress').textContent = deleted;
} catch (error) {
console.error('Delete error:', error);
failed++;
}
}

// Remove loading
document.body.removeChild(loadingDiv);

// Show result
if (failed === 0) {
alert('Successfully deleted ' + deleted + ' ' + type + '!');
} else {
alert('Deleted ' + deleted + ' ' + type + ', but ' + failed + ' failed.');
}

// Reload
window.location.reload();

} catch (error) {
console.error('Error:', error);
alert('Error: ' + error.message);
const loadingDiv = document.getElementById('delete-loading');
if (loadingDiv) {
document.body.removeChild(loadingDiv);
}
}
};



// Working create functions
window.oldCreateTestLead = async function() {
// Get current date in YYYY-MM-DD format
const now = new Date();
const year = now.getFullYear();
const month = String(now.getMonth() + 1).padStart(2, '0');
const day = String(now.getDate()).padStart(2, '0');
const today = `${year}-${month}-${day}`;

// Create future date for follow up (3 days from now)
const futureDate = new Date(now.getTime() + (3 * 24 * 60 * 60 * 1000));
const futureYear = futureDate.getFullYear();
const futureMonth = String(futureDate.getMonth() + 1).padStart(2, '0');
const futureDay = String(futureDate.getDate()).padStart(2, '0');
const followUpDate = `${futureYear}-${futureMonth}-${futureDay}`;

const testData = {
name: 'Test User ' + Math.floor(Math.random() * 1000),
email: 'test' + Math.floor(Math.random() * 1000) + '@example.com',
phone: '98' + Math.floor(Math.random() * 90000000 + 10000000),
company: 'Test Company ' + Math.floor(Math.random() * 100),
lead_for_event: 'General Inquiry',
lead_source: 'Website',
lead_type: 'warm',
status: 'new',
date_of_enquiry: today,
follow_up_date: followUpDate,
notes: 'Test lead created via test mode',
requirements: 'Test requirements for stalls and equipment',
budget: Math.floor(Math.random() * 50000) + 10000,
event_date: followUpDate,
location: 'Test Location',
urgency: 'medium'
};



// Add created_by if user is logged in
try {
const user = JSON.parse(localStorage.getItem('crm_user') || '{}');
if (user.id) {
testData.created_by = user.id;
}
} catch (e) {
console.log('Could not get user ID');
}

const authToken = localStorage.getItem('crm_auth_token');
// Using global window.API_CONFIG.API_URL variable

console.log('Creating lead with data:', testData);
console.log('Date of enquiry:', testData.date_of_enquiry);

try {
const response = await fetch(window.API_CONFIG.API_URL + '/leads', {
method: 'POST',
headers: {
'Authorization': 'Bearer ' + authToken,
'Content-Type': 'application/json'
},
body: JSON.stringify(testData)
});

const result = await response.json();

if (response.ok) {
console.log('Lead created successfully:', result);
alert('Test lead created: ' + testData.name + '\nDate: ' + testData.date_of_enquiry);
window.location.reload();
} else {
console.error('Failed to create lead:', result);
alert('Error: ' + (result.error || result.message || 'Failed to create lead'));
}
} catch (error) {
console.error('Create lead error:', error);
alert('Error creating lead: ' + error.message);
}
};



window.oldCreateTestInventory = async function() {
const categories = ['Stall', 'Equipment', 'Service', 'Package'];
const testData = {
name: 'Test Item ' + Math.floor(Math.random() * 1000),
category: categories[Math.floor(Math.random() * categories.length)],
price: Math.floor(Math.random() * 90000) + 10000,
quantity: Math.floor(Math.random() * 50) + 1,
status: 'available',
description: 'Test inventory item created via test mode at ' + new Date().toLocaleString(),
size: '10x10 ft',
location: 'Zone ' + Math.floor(Math.random() * 5 + 1)
};



const authToken = localStorage.getItem('crm_auth_token');
// Using global window.API_CONFIG.API_URL variable

try {
const response = await fetch(window.API_CONFIG.API_URL + '/inventory', {
method: 'POST',
headers: {
'Authorization': 'Bearer ' + authToken,
'Content-Type': 'application/json'
},
body: JSON.stringify(testData)
});

const result = await response.json();

if (response.ok) {
console.log('Inventory created:', result);
alert('Test inventory created: ' + testData.name);
window.location.reload();
} else {
console.error('Failed to create inventory:', result);
alert('Error: ' + (result.error || 'Failed to create inventory'));
}
} catch (error) {
console.error('Create inventory error:', error);
alert('Error creating inventory: ' + error.message);
}
};



// Debug function
window.debugLeads = async function() {
const authToken = localStorage.getItem('crm_auth_token');
// Using global window.API_CONFIG.API_URL variable

const response = await fetch(window.API_CONFIG.API_URL + '/leads', {
method: 'GET',
headers: {
'Authorization': 'Bearer ' + authToken
}
});

const result = await response.json();
console.log('All leads:', result);
return result;
};




// Add floating button to show test panel if hidden
setTimeout(() => {
if (localStorage.getItem('testMode') === 'true') {
const showButton = document.createElement('button');
showButton.id = 'show-test-panel';
showButton.style.cssText = 'position:fixed;bottom:20px;left:20px;background:#1f2937;color:white;padding:10px;border-radius:50%;width:50px;height:50px;border:none;cursor:pointer;z-index:9998;font-size:20px;box-shadow:0 2px 4px rgba(0,0,0,0.2);';
showButton.innerHTML = 'üß™';
showButton.title = 'Show Test Panel';
showButton.onclick = () => {
const panel = document.getElementById('test-control-panel');
if (panel) {
panel.style.display = 'block';
showButton.style.display = 'none';
}
};


document.body.appendChild(showButton);

// Hide button if panel is visible
const checkPanel = setInterval(() => {
const panel = document.getElementById('test-control-panel');
if (panel && panel.style.display !== 'none') {
showButton.style.display = 'none';
} else {
showButton.style.display = 'block';
}
}, 500);
}
}, 1000);


// Debug function to see inventory structure
window.checkInventoryFields = async function() {
const authToken = localStorage.getItem('crm_auth_token');
// Using global window.API_CONFIG.API_URL variable

const response = await fetch(window.API_CONFIG.API_URL + '/inventory', {
method: 'GET',
headers: {
'Authorization': 'Bearer ' + authToken
}
});

const result = await response.json();
if (result.data && result.data.length > 0) {
console.log('Sample inventory structure:', result.data[0]);
console.log('Fields:', Object.keys(result.data[0]));
} else {
console.log('No inventory found');
}
return result;
};



console.log('Test mode functions loaded. Type debugLeads() to see all leads.');
</script>

<!-- TEMP FINANCIALS DELETE FUNCTION -->
<script>
window.deleteAllFinancials = async function() {
if (!confirm('Delete all financial records (payables and receivables)?')) return;

const authToken = localStorage.getItem('crm_auth_token');
// Using global window.API_CONFIG.API_URL variable

try {
console.log('Starting to delete all financials...');
let deletedPayables = 0;
let deletedReceivables = 0;

// Delete all payables
try {
const payablesRes = await fetch(`${window.API_CONFIG.API_URL}/api/payables`, {
headers: {
'Authorization': `Bearer ${authToken}`,
'Content-Type': 'application/json'
}
});

if (payablesRes.ok) {
const payablesData = await payablesRes.json();
const payables = payablesData.data || [];
console.log(`Found ${payables.length} payables to delete`);

for (const payable of payables) {
const delRes = await fetch(`${window.API_CONFIG.API_URL}/api/payables/${payable.id}`, {
method: 'DELETE',
headers: {
'Authorization': `Bearer ${authToken}`,
'Content-Type': 'application/json'
}
});
if (delRes.ok) {
deletedPayables++;
console.log(`Deleted payable: ${payable.id}`);
}
}
}
} catch (e) {
console.error('Error deleting payables:', e);
}

// Delete all receivables - FIXED endpoint
try {
console.log('Fetching receivables...');
const receivablesRes = await fetch(`${window.API_CONFIG.API_URL}/api/receivables`, {
headers: {
'Authorization': `Bearer ${authToken}`,
'Content-Type': 'application/json'
}
});

console.log('Receivables response status:', receivablesRes.status);

if (receivablesRes.ok) {
const receivablesData = await receivablesRes.json();
const receivables = receivablesData.data || [];
console.log(`Found ${receivables.length} receivables to delete`);

// Delete each receivable
for (const receivable of receivables) {
console.log(`Deleting receivable: ${receivable.id}`);
const delRes = await fetch(`${window.API_CONFIG.API_URL}/api/receivables/${receivable.id}`, {
method: 'DELETE',
headers: {
'Authorization': `Bearer ${authToken}`,
'Content-Type': 'application/json'
}
});

if (delRes.ok) {
deletedReceivables++;
console.log(`Successfully deleted receivable: ${receivable.id}`);
} else {
console.error(`Failed to delete receivable ${receivable.id}:`, delRes.status);
}
}
} else {
console.error('Failed to fetch receivables:', receivablesRes.status);
}
} catch (e) {
console.error('Error deleting receivables:', e);
}

alert(`Financial records deleted!\nPayables: ${deletedPayables}\nReceivables: ${deletedReceivables}`);
window.location.reload();

} catch (error) {
console.error('Error:', error);
alert('Error: ' + error.message);
}
};


</script>

</body>
</html>
<!-- Password: Updated: Sun Jun 29 11:38:10 AM UTC 2025 -->
<!-- Password: LATEST_DEPLOY: 2025-06-29 11:41:06 UTC -->
<!-- Password: Deployed: Sun Jun 29 12:22:47 PM UTC 2025 -->

<div id="test-control-panel" style="position:fixed; bottom:80px; right:20px; background:#1f2937; color:white; padding:15px; border-radius:8px; box-shadow:0 4px 6px rgba(0,0,0,0.3); display:none; z-index:9999;">
<h3 style="margin:0 0 10px 0; font-size:16px;">üß™ Test Mode Controls</h3>
<button onclick="if(confirm('Delete ALL leads?')) { window.testDeleteAll('leads'); }" style="display:block; width:100%; margin:5px 0; padding:8px; background:#dc2626; color:white; border:none; border-radius:4px; cursor:pointer;">üóëÔ∏è Delete All Leads</button>
<button onclick="if(confirm('Delete ALL inventory?')) { window.testDeleteAll('inventory'); }" style="display:block; width:100%; margin:5px 0; padding:8px; background:#dc2626; color:white; border:none; border-radius:4px; cursor:pointer;">üóëÔ∏è Delete All Inventory</button>
</div>
<script>
// Show test control panel if test mode is on and user is super admin
window.updateTestPanel = function() {
const testMode = localStorage.getItem('testMode') === 'true';
const user = JSON.parse(localStorage.getItem('crm_user') || '{}');
const panel = document.getElementById('test-control-panel');
if (testMode && user.role === 'super_admin' && panel) {
panel.style.display = 'block';
}
};



// Delete all function
window.testDeleteAll = async function(type) {
const authToken = localStorage.getItem('crm_auth_token');
// Using global window.API_CONFIG.API_URL variable

try {
const response = await fetch(window.API_CONFIG.API_URL + '/' + type, {
method: 'DELETE',
headers: {
'Authorization': 'Bearer ' + authToken,
'X-Delete-All': 'true',
'X-Test-Mode': 'true'
}
});

if (response.ok) {
alert('All ' + type + ' deleted successfully!');
window.location.reload();
} else {
alert('Error: ' + response.statusText);
}
} catch (error) {
alert('Error: ' + error.message);
}
};



// Check on load
setTimeout(window.updateTestPanel, 1000);
</script>


<script>
// Test data creation functions
window.fillTestLead = function() {
if (confirm('Create a test lead?')) {
// Directly create test lead data
const testData = {
name: 'Test User ' + Math.floor(Math.random() * 1000),
email: 'test' + Math.floor(Math.random() * 1000) + '@example.com',
phone: '98' + Math.floor(Math.random() * 90000000 + 10000000),
company: 'Test Company ' + Math.floor(Math.random() * 100),
lead_for_event: 'General Inquiry',
lead_source: 'Website',
notes: 'Test lead created via test mode'
};



// Call the API directly
const authToken = localStorage.getItem('crm_auth_token');
// Using global window.API_CONFIG.API_URL variable

fetch(window.API_CONFIG.API_URL + '/leads', {
method: 'POST',
headers: {
'Authorization': 'Bearer ' + authToken,
'Content-Type': 'application/json'
},
body: JSON.stringify(testData)
})
.then(response => response.json())
.then(data => {
alert('Test lead created successfully!');
window.location.reload();
})
.catch(error => {
alert('Error creating test lead: ' + error.message);
});
}
};



window.fillTestInventory = function() {
if (confirm('Create a test inventory item?')) {
const categories = ['Stall', 'Equipment', 'Service', 'Package'];
const testData = {
name: 'Test Item ' + Math.floor(Math.random() * 1000),
category: categories[Math.floor(Math.random() * categories.length)],
price: Math.floor(Math.random() * 90000) + 10000,
quantity: Math.floor(Math.random() * 50) + 1,
description: 'Test inventory item created via test mode',
size: '10x10 ft',
location: 'Zone ' + Math.floor(Math.random() * 5 + 1)
};



const authToken = localStorage.getItem('crm_auth_token');
// Using global window.API_CONFIG.API_URL variable

fetch(window.API_CONFIG.API_URL + '/inventory', {
method: 'POST',
headers: {
'Authorization': 'Bearer ' + authToken,
'Content-Type': 'application/json'
},
body: JSON.stringify(testData)
})
.then(response => response.json())
.then(data => {
alert('Test inventory item created successfully!');
window.location.reload();
})
.catch(error => {
alert('Error creating test inventory: ' + error.message);
});
}
};


</script>


<script>
// Working delete function that deletes individually
window.deleteAllIndividually = async function(type) {
if (!confirm('Delete ALL ' + type + '? This will delete them one by one.')) {
return;
}

const authToken = localStorage.getItem('crm_auth_token');
// Using global window.API_CONFIG.API_URL variable

try {
// Show loading
const loadingDiv = document.createElement('div');
loadingDiv.id = 'delete-loading';
loadingDiv.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:white;padding:20px;border-radius:8px;box-shadow:0 4px 6px rgba(0,0,0,0.1);z-index:10000;';
loadingDiv.innerHTML = '<h3>Fetching ' + type + '...</h3>';
document.body.appendChild(loadingDiv);

// Get all items
const response = await fetch(window.API_CONFIG.API_URL + '/' + type, {
method: 'GET',
headers: {
'Authorization': 'Bearer ' + authToken,
'Content-Type': 'application/json'
}
});

if (!response.ok) {
throw new Error('Failed to fetch ' + type);
}

const result = await response.json();
const items = result.data || [];

if (items.length === 0) {
document.body.removeChild(loadingDiv);
alert('No ' + type + ' to delete');
return;
}

// Update loading message
loadingDiv.innerHTML = '<h3>Deleting ' + type + '...</h3><p>Progress: <span id="delete-progress">0</span> / ' + items.length + '</p>';

let deleted = 0;
let failed = 0;

// Delete each item
for (const item of items) {
try {
const deleteUrl = window.API_CONFIG.API_URL + '/' + type + '/' + item.id;
console.log('Deleting:', deleteUrl);

const deleteResponse = await fetch(deleteUrl, {
method: 'DELETE',
headers: {
'Authorization': 'Bearer ' + authToken
}
});

if (deleteResponse.ok) {
deleted++;
console.log('Deleted:', item.id);
} else {
failed++;
console.log('Failed to delete:', item.id, deleteResponse.status);
}

document.getElementById('delete-progress').textContent = deleted;
} catch (error) {
console.error('Delete error:', error);
failed++;
}
}

// Remove loading
document.body.removeChild(loadingDiv);

// Show result
if (failed === 0) {
alert('Successfully deleted ' + deleted + ' ' + type + '!');
} else {
alert('Deleted ' + deleted + ' ' + type + ', but ' + failed + ' failed.');
}

// Reload
window.location.reload();

} catch (error) {
console.error('Error:', error);
alert('Error: ' + error.message);
const loadingDiv = document.getElementById('delete-loading');
if (loadingDiv) {
document.body.removeChild(loadingDiv);
}
}
};



// Working create functions
window.oldCreateTestLead = async function() {
const testData = {
name: 'Test User ' + Math.floor(Math.random() * 1000),
email: 'test' + Math.floor(Math.random() * 1000) + '@example.com',
phone: '98' + Math.floor(Math.random() * 90000000 + 10000000),
company: 'Test Company ' + Math.floor(Math.random() * 100),
lead_for_event: 'General Inquiry',
lead_source: 'Website',
lead_type: 'warm',
status: 'new',
notes: 'Test lead created via test mode at ' + new Date().toLocaleString()
};



const authToken = localStorage.getItem('crm_auth_token');
// Using global window.API_CONFIG.API_URL variable

try {
const response = await fetch(window.API_CONFIG.API_URL + '/leads', {
method: 'POST',
headers: {
'Authorization': 'Bearer ' + authToken,
'Content-Type': 'application/json'
},
body: JSON.stringify(testData)
});

const result = await response.json();

if (response.ok) {
console.log('Lead created:', result);
alert('Test lead created: ' + testData.name);
window.location.reload();
} else {
console.error('Failed to create lead:', result);
alert('Error: ' + (result.error || 'Failed to create lead'));
}
} catch (error) {
console.error('Create lead error:', error);
alert('Error creating lead: ' + error.message);
}
};



window.oldCreateTestInventory = async function() {
const categories = ['Stall', 'Equipment', 'Service', 'Package'];
const testData = {
name: 'Test Item ' + Math.floor(Math.random() * 1000),
category: categories[Math.floor(Math.random() * categories.length)],
price: Math.floor(Math.random() * 90000) + 10000,
quantity: Math.floor(Math.random() * 50) + 1,
status: 'available',
description: 'Test inventory item created via test mode at ' + new Date().toLocaleString(),
size: '10x10 ft',
location: 'Zone ' + Math.floor(Math.random() * 5 + 1)
};



const authToken = localStorage.getItem('crm_auth_token');
// Using global window.API_CONFIG.API_URL variable

try {
const response = await fetch(window.API_CONFIG.API_URL + '/inventory', {
method: 'POST',
headers: {
'Authorization': 'Bearer ' + authToken,
'Content-Type': 'application/json'
},
body: JSON.stringify(testData)
});

const result = await response.json();

if (response.ok) {
console.log('Inventory created:', result);
alert('Test inventory created: ' + testData.name);
window.location.reload();
} else {
console.error('Failed to create inventory:', result);
alert('Error: ' + (result.error || 'Failed to create inventory'));
}
} catch (error) {
console.error('Create inventory error:', error);
alert('Error creating inventory: ' + error.message);
}
};



// Debug function
window.debugLeads = async function() {
const authToken = localStorage.getItem('crm_auth_token');
// Using global window.API_CONFIG.API_URL variable

const response = await fetch(window.API_CONFIG.API_URL + '/leads', {
method: 'GET',
headers: {
'Authorization': 'Bearer ' + authToken
}
});

const result = await response.json();
console.log('All leads:', result);
return result;
};




// Add floating button to show test panel if hidden
setTimeout(() => {
if (localStorage.getItem('testMode') === 'true') {
const showButton = document.createElement('button');
showButton.id = 'show-test-panel';
showButton.style.cssText = 'position:fixed;bottom:20px;left:20px;background:#1f2937;color:white;padding:10px;border-radius:50%;width:50px;height:50px;border:none;cursor:pointer;z-index:9998;font-size:20px;box-shadow:0 2px 4px rgba(0,0,0,0.2);';
showButton.innerHTML = 'üß™';
showButton.title = 'Show Test Panel';
showButton.onclick = () => {
const panel = document.getElementById('test-control-panel');
if (panel) {
panel.style.display = 'block';
showButton.style.display = 'none';
}
};


document.body.appendChild(showButton);

// Hide button if panel is visible
const checkPanel = setInterval(() => {
const panel = document.getElementById('test-control-panel');
if (panel && panel.style.display !== 'none') {
showButton.style.display = 'none';
} else {
showButton.style.display = 'block';
}
}, 500);
}
}, 1000);


// Debug function to see inventory structure
window.checkInventoryFields = async function() {
const authToken = localStorage.getItem('crm_auth_token');
// Using global window.API_CONFIG.API_URL variable

const response = await fetch(window.API_CONFIG.API_URL + '/inventory', {
method: 'GET',
headers: {
'Authorization': 'Bearer ' + authToken
}
});

const result = await response.json();
if (result.data && result.data.length > 0) {
console.log('Sample inventory structure:', result.data[0]);
console.log('Fields:', Object.keys(result.data[0]));
} else {
console.log('No inventory found');
}
return result;
};



console.log('Test mode functions loaded. Type debugLeads() to see all leads.');


// Test date formatting
window.testDateFormat = function() {
const now = new Date();
const year = now.getFullYear();
const month = String(now.getMonth() + 1).padStart(2, '0');
const day = String(now.getDate()).padStart(2, '0');
const today = `${year}-${month}-${day}`;

console.log('Current date:', now);
console.log('Formatted date:', today);
console.log('Type:', typeof today);

return today;
};



// Function to manually create a lead with custom data
window.createCustomLead = async function(leadData) {
const authToken = localStorage.getItem('crm_auth_token');
// Using global window.API_CONFIG.API_URL variable

console.log('Creating lead with custom data:', leadData);

try {
const response = await fetch(window.API_CONFIG.API_URL + '/leads', {
method: 'POST',
headers: {
'Authorization': 'Bearer ' + authToken,
'Content-Type': 'application/json'
},
body: JSON.stringify(leadData)
});

const result = await response.json();
console.log('Response:', result);

if (response.ok) {
alert('Lead created successfully!');
return result;
} else {
alert('Error: ' + (result.error || result.message));
return null;
}
} catch (error) {
console.error('Error:', error);
alert('Error: ' + error.message);
return null;
}
};





// Analyze existing lead structure
window.analyzeLeadStructure = async function() {
const authToken = localStorage.getItem('crm_auth_token');
// Using global window.API_CONFIG.API_URL variable

try {
// Get existing leads
const response = await fetch(window.API_CONFIG.API_URL + '/leads', {
method: 'GET',
headers: {
'Authorization': 'Bearer ' + authToken
}
});

const result = await response.json();
console.log('Leads response:', result);

if (result.data && result.data.length > 0) {
const lead = result.data[0];
console.log('Sample lead:', lead);
console.log('Lead fields:', Object.keys(lead));
console.log('Field types:');
for (const key in lead) {
console.log(`  ${key}: ${typeof lead[key]} = ${lead[key]}`);
}

// Check date fields specifically
if (lead.date_of_enquiry) {
console.log('date_of_enquiry format:', lead.date_of_enquiry);
}

return lead;
} else {
console.log('No existing leads found');
return null;
}
} catch (error) {
console.error('Error analyzing leads:', error);
return null;
}
};



// Create lead with minimal required fields
window.createMinimalLead = async function() {
const authToken = localStorage.getItem('crm_auth_token');
// Using global window.API_CONFIG.API_URL variable

// Start with absolute minimum fields
const minimalData = {
name: 'Minimal Test ' + Math.floor(Math.random() * 1000),
email: 'minimal' + Math.floor(Math.random() * 1000) + '@test.com',
phone: '9876543210',
status: 'new'
};



console.log('Creating minimal lead:', minimalData);

try {
const response = await fetch(window.API_CONFIG.API_URL + '/leads', {
method: 'POST',
headers: {
'Authorization': 'Bearer ' + authToken,
'Content-Type': 'application/json'
},
body: JSON.stringify(minimalData)
});

const result = await response.json();
console.log('Response status:', response.status);
console.log('Response:', result);

if (response.ok) {
alert('Minimal lead created successfully!');
return result;
} else {
console.error('Failed:', result);
alert('Failed: ' + (result.error || result.message || 'Unknown error'));
return null;
}
} catch (error) {
console.error('Error:', error);
alert('Error: ' + error.message);
return null;
}
};



// Fixed create test lead based on backend requirements
window.oldCreateTestLead = async function() {
const authToken = localStorage.getItem('crm_auth_token');
// Using global window.API_CONFIG.API_URL variable

// First analyze existing lead to understand structure
console.log('Analyzing existing lead structure...');
const existingLead = await analyzeLeadStructure();

// Create test data matching the structure
const testData = {
name: 'Test User ' + Math.floor(Math.random() * 1000),
email: 'test' + Math.floor(Math.random() * 1000) + '@example.com',
phone: '98' + Math.floor(Math.random() * 90000000 + 10000000),
company: 'Test Company ' + Math.floor(Math.random() * 100),
lead_for_event: 'General Inquiry',
lead_source: 'Website',
lead_type: 'warm',
status: 'new',
notes: 'Test lead created via test mode',
requirements: 'Test requirements'
};



// If we found date fields in existing lead, add them
if (existingLead && existingLead.date_of_enquiry) {
// Copy the date format from existing lead
const dateFormat = existingLead.date_of_enquiry;
console.log('Using date format from existing lead:', dateFormat);

// If it's a timestamp, use current timestamp
if (typeof dateFormat === 'object' || dateFormat.includes('T')) {
testData.date_of_enquiry = new Date().toISOString();
} else {
// Otherwise use YYYY-MM-DD format
const now = new Date();
testData.date_of_enquiry = now.getFullYear() + '-' + 
String(now.getMonth() + 1).padStart(2, '0') + '-' + 
String(now.getDate()).padStart(2, '0');
}
}

console.log('Creating lead with data:', testData);

try {
const response = await fetch(window.API_CONFIG.API_URL + '/leads', {
method: 'POST',
headers: {
'Authorization': 'Bearer ' + authToken,
'Content-Type': 'application/json'
},
body: JSON.stringify(testData)
});

const result = await response.json();

if (response.ok) {
console.log('Lead created successfully:', result);
alert('Test lead created: ' + testData.name);
window.location.reload();
} else {
console.error('Failed to create lead:', result);

// If date_of_enquiry is the issue, try without it
if (result.error && result.error.includes('date_of_enquiry')) {
console.log('Retrying without date_of_enquiry...');
delete testData.date_of_enquiry;

const retry = await fetch(window.API_CONFIG.API_URL + '/leads', {
method: 'POST',
headers: {
'Authorization': 'Bearer ' + authToken,
'Content-Type': 'application/json'
},
body: JSON.stringify(testData)
});

const retryResult = await retry.json();

if (retry.ok) {
alert('Test lead created (without date): ' + testData.name);
window.location.reload();
} else {
alert('Error: ' + (retryResult.error || retryResult.message || 'Failed to create lead'));
}
} else {
alert('Error: ' + (result.error || result.message || 'Failed to create lead'));
}
}
} catch (error) {
console.error('Create lead error:', error);
alert('Error creating lead: ' + error.message);
}
};





// Create test lead following form business logic
window.oldCreateTestLead = async function() {
const authToken = localStorage.getItem('crm_auth_token');
// Using global window.API_CONFIG.API_URL variable

try {
// First, get the active events (same as form does)
console.log('Fetching active events...');
const eventsResponse = await fetch(window.API_CONFIG.API_URL + '/events?status=active', {
method: 'GET',
headers: {
'Authorization': 'Bearer ' + authToken
}
});

let activeEvent = null;
if (eventsResponse.ok) {
const eventsResult = await eventsResponse.json();
if (eventsResult.data && eventsResult.data.length > 0) {
activeEvent = eventsResult.data[0].name;
console.log('Found active event:', activeEvent);
}
}

// Get lead sources and statuses from form options if they exist
const leadSources = ['Website', 'Social Media', 'Referral', 'Direct Contact', 'Exhibition', 'Cold Call'];
const leadTypes = ['hot', 'warm', 'cold'];
const urgencyLevels = ['high', 'medium', 'low'];

// Create test data following form structure
const testData = {
name: 'Test User ' + Math.floor(Math.random() * 1000),
email: 'test' + Math.floor(Math.random() * 1000) + '@example.com',
phone: '98' + Math.floor(Math.random() * 90000000 + 10000000),
company: 'Test Company ' + Math.floor(Math.random() * 100),
lead_for_event: activeEvent || 'General Inquiry', // Use active event if found
lead_source: leadSources[Math.floor(Math.random() * leadSources.length)],
lead_type: leadTypes[Math.floor(Math.random() * leadTypes.length)],
status: 'unassigned', // Use unassigned as default like the form
notes: 'Test lead created via test mode on ' + new Date().toLocaleString(),
requirements: 'Looking for ' + Math.floor(Math.random() * 5 + 1) + ' stalls and equipment',
budget: Math.floor(Math.random() * 100000) + 25000,
urgency: urgencyLevels[Math.floor(Math.random() * urgencyLevels.length)],
location: 'Test Location ' + ['Delhi', 'Mumbai', 'Bangalore', 'Chennai'][Math.floor(Math.random() * 4)]
};



// Add date fields if needed
const now = new Date();
const dateStr = now.getFullYear() + '-' + 
String(now.getMonth() + 1).padStart(2, '0') + '-' + 
String(now.getDate()).padStart(2, '0');

// Check if date_of_enquiry is needed by trying to get existing lead structure
const leadsCheck = await fetch(window.API_CONFIG.API_URL + '/leads?limit=1', {
method: 'GET',
headers: {
'Authorization': 'Bearer ' + authToken
}
});

if (leadsCheck.ok) {
const leadsResult = await leadsCheck.json();
if (leadsResult.data && leadsResult.data.length > 0) {
const sampleLead = leadsResult.data[0];
// If existing leads have date_of_enquiry, add it in the same format
if (sampleLead.date_of_enquiry) {
if (typeof sampleLead.date_of_enquiry === 'object') {
// Firestore timestamp format
testData.date_of_enquiry = {
_seconds: Math.floor(now.getTime() / 1000),
_nanoseconds: 0
};


} else {
testData.date_of_enquiry = dateStr;
}
}

// Copy the created_by format if it exists
if (sampleLead.created_by) {
const user = JSON.parse(localStorage.getItem('crm_user') || '{}');
testData.created_by = user.id || user.email || 'admin';
}
}
}

console.log('Creating lead with business logic data:', testData);

// Create the lead
const response = await fetch(window.API_CONFIG.API_URL + '/leads', {
method: 'POST',
headers: {
'Authorization': 'Bearer ' + authToken,
'Content-Type': 'application/json'
},
body: JSON.stringify(testData)
});

const result = await response.json();

if (response.ok) {
console.log('Lead created successfully:', result);
alert('Test lead created successfully!\n' +
'Name: ' + testData.name + '\n' +
'Event: ' + testData.lead_for_event + '\n' +
'Status: ' + testData.status + '\n' +
'Budget: ‚Çπ' + testData.budget.toLocaleString());
window.location.reload();
} else {
console.error('Failed to create lead:', result);

// If it's still about date_of_enquiry, try without it
if (result.error && result.error.includes('date_of_enquiry')) {
delete testData.date_of_enquiry;
console.log('Retrying without date_of_enquiry...');

const retry = await fetch(window.API_CONFIG.API_URL + '/leads', {
method: 'POST',
headers: {
'Authorization': 'Bearer ' + authToken,
'Content-Type': 'application/json'
},
body: JSON.stringify(testData)
});

const retryResult = await retry.json();
if (retry.ok) {
alert('Test lead created successfully (without date)!');
window.location.reload();
} else {
alert('Error: ' + (retryResult.error || 'Failed to create lead'));
}
} else {
alert('Error: ' + (result.error || result.message || 'Failed to create lead'));
}
}
} catch (error) {
console.error('Error:', error);
alert('Error creating lead: ' + error.message);
}
};



// Function to see what status options exist in the form
window.checkFormOptions = function() {
// This would analyze the form to see what options are available
console.log('Checking form options...');

// Look for select elements and their options
const selects = document.querySelectorAll('select');
selects.forEach(select => {
if (select.options && select.options.length > 0) {
console.log('Select field:', select.name || 'unknown');
Array.from(select.options).forEach(opt => {
console.log('  Option:', opt.value, '-', opt.text);
});
}
});
};





// Create test inventory following form business logic
window.oldCreateTestInventory = async function() {
const authToken = localStorage.getItem('crm_auth_token');
// Using global window.API_CONFIG.API_URL variable

try {
// First check existing inventory to understand structure
console.log('Checking existing inventory structure...');
const invResponse = await fetch(window.API_CONFIG.API_URL + '/inventory?limit=1', {
method: 'GET',
headers: {
'Authorization': 'Bearer ' + authToken
}
});

let sampleInventory = null;
if (invResponse.ok) {
const invResult = await invResponse.json();
if (invResult.data && invResult.data.length > 0) {
sampleInventory = invResult.data[0];
console.log('Sample inventory:', sampleInventory);
}
}

// Define proper business values
const categories = ['Stall', 'Equipment', 'Service', 'Package'];
const sizes = ['3x3', '6x6', '9x9', '10x10', '12x12', '15x15', '20x20', 'Custom'];
const locations = ['Hall A', 'Hall B', 'Hall C', 'Outdoor Area', 'Food Court', 'Main Entrance'];
const units = ['Per Day', 'Per Event', 'Per Hour', 'Per Unit'];
const statuses = ['available', 'booked', 'maintenance', 'unavailable'];

// Generate realistic inventory data
const category = categories[Math.floor(Math.random() * categories.length)];
const basePrice = category === 'Stall' ? 15000 : 
category === 'Equipment' ? 5000 : 
category === 'Service' ? 10000 : 25000;

const quantity = category === 'Service' ? 1 : Math.floor(Math.random() * 20) + 5;

const testData = {
name: 'Test ' + category + ' ' + Math.floor(Math.random() * 1000),
category: category,
price: basePrice + Math.floor(Math.random() * 10000),
quantity: quantity,
available_quantity: quantity, // Initially all available
status: 'available', // New inventory is available
description: 'High quality ' + category.toLowerCase() + ' suitable for exhibitions and events. ' +
'Includes all standard amenities and facilities.',
size: category === 'Stall' ? sizes[Math.floor(Math.random() * sizes.length)] : 'Standard',
location: locations[Math.floor(Math.random() * locations.length)],
unit: units[Math.floor(Math.random() * units.length)],
min_booking_quantity: 1,
max_booking_quantity: category === 'Service' ? 1 : Math.min(quantity, 10),
features: category === 'Stall' ? 'Power outlet, Lighting, Table, Chairs, Fascia board' :
category === 'Equipment' ? 'Professional grade, Well maintained, Delivery included' :
category === 'Service' ? 'Professional staff, Experienced team, Quality assured' :
'Complete package with all inclusions',
terms_conditions: 'Standard rental terms apply. Advance booking required. Cancellation policy applicable.',
specifications: category === 'Stall' ? 
JSON.stringify({
power_supply: '15 Amp',
height: '8 feet',
type: 'Octanorm',
flooring: 'Carpet'
}) :
JSON.stringify({
brand: 'Premium',
condition: 'Excellent',
year: '2024'
}),
// Ensure no undefined values
tickets_available: 0, // Not applicable for inventory
booking_start_date: null,
booking_end_date: null,
images: [],
tags: [category.toLowerCase(), 'test', 'available']
};



// Add created_by from current user
const user = JSON.parse(localStorage.getItem('crm_user') || '{}');
if (user.id) {
testData.created_by = user.id;
}

// Add timestamps
const now = new Date();
testData.created_date = now.toISOString();
testData.updated_date = now.toISOString();

// If sample inventory exists, match any additional fields
if (sampleInventory) {
// Check for any fields we might have missed
Object.keys(sampleInventory).forEach(key => {
if (testData[key] === undefined && 
!['id', 'created_at', 'updated_at'].includes(key)) {
// Set appropriate default based on type
if (typeof sampleInventory[key] === 'number') {
testData[key] = 0;
} else if (typeof sampleInventory[key] === 'boolean') {
testData[key] = false;
} else if (typeof sampleInventory[key] === 'string') {
testData[key] = '';
} else if (Array.isArray(sampleInventory[key])) {
testData[key] = [];
} else if (sampleInventory[key] === null) {
testData[key] = null;
}
console.log('Added missing field:', key, 'with default:', testData[key]);
}
});
}

console.log('Creating inventory with business logic data:', testData);

// Create the inventory
const response = await fetch(window.API_CONFIG.API_URL + '/inventory', {
method: 'POST',
headers: {
'Authorization': 'Bearer ' + authToken,
'Content-Type': 'application/json'
},
body: JSON.stringify(testData)
});

const result = await response.json();

if (response.ok) {
console.log('Inventory created successfully:', result);
alert('Test inventory created successfully!\n' +
'Name: ' + testData.name + '\n' +
'Category: ' + testData.category + '\n' +
'Price: ‚Çπ' + testData.price.toLocaleString() + ' ' + testData.unit + '\n' +
'Quantity: ' + testData.quantity + '\n' +
'Location: ' + testData.location);
window.location.reload();
} else {
console.error('Failed to create inventory:', result);
alert('Error: ' + (result.error || result.message || 'Failed to create inventory'));

// Log which fields might be causing issues
if (result.error) {
console.log('Error details:', result.error);
console.log('Sent data:', testData);
}
}
} catch (error) {
console.error('Error:', error);
alert('Error creating inventory: ' + error.message);
}
};



// Function to analyze inventory fields
window.analyzeInventoryStructure = async function() {
const authToken = localStorage.getItem('crm_auth_token');
// Using global window.API_CONFIG.API_URL variable

try {
const response = await fetch(window.API_CONFIG.API_URL + '/inventory', {
method: 'GET',
headers: {
'Authorization': 'Bearer ' + authToken
}
});

const result = await response.json();
if (result.data && result.data.length > 0) {
const item = result.data[0];
console.log('Sample inventory item:', item);
console.log('Fields:', Object.keys(item));
console.log('Field types:');
Object.keys(item).forEach(key => {
const value = item[key];
console.log(`  ${key}: ${typeof value} = ${value === null ? 'null' : value}`);
});
return item;
} else {
console.log('No inventory items found');
return null;
}
} catch (error) {
console.error('Error:', error);
re


// Test functions with correct field names from your actual forms
window.createTestInventory = async function() {
const authToken = localStorage.getItem('crm_auth_token');
// Using global window.API_CONFIG.API_URL variable

try {
// Using exact field names from inventoryFormFields
const testData = {
// Required fields
event_name: 'Test Cricket Match ' + Math.floor(Math.random() * 1000),
event_date: new Date(Date.now() + 30*24*60*60*1000).toISOString().split('T')[0], // 30 days from now
event_type: ['football', 'cricket', 'tennis', 'formula1', 'olympics', 'basketball', 'badminton', 'hockey'][Math.floor(Math.random() * 8)],
sports: ['Cricket', 'Football', 'Tennis', 'Formula 1', 'Olympics', 'Basketball', 'Badminton', 'Hockey', 'Golf', 'Wrestling'][Math.floor(Math.random() * 10)],
venue: 'Test Stadium ' + ['Mumbai', 'Delhi', 'Bangalore', 'Chennai', 'Kolkata'][Math.floor(Math.random() * 5)],

// Ticket details
category_of_ticket: ['VIP', 'Premium', 'Gold', 'Silver', 'Bronze', 'General', 'Corporate Box', 'Hospitality'][Math.floor(Math.random() * 8)],
total_tickets: Math.floor(Math.random() * 500) + 100,
available_tickets: Math.floor(Math.random() * 500) + 100,
mrp_of_ticket: Math.floor(Math.random() * 5000) + 1000,
buying_price: Math.floor(Math.random() * 4000) + 800,
selling_price: Math.floor(Math.random() * 6000) + 1500,

// Optional fields
day_of_match: 'Not Applicable',
stand: 'North Stand',
inclusions: 'Snacks, Beverages, Parking',
booking_person: 'Test Supplier ' + Math.floor(Math.random() * 100),
procurement_type: ['pre_inventory', 'on_demand', 'partnership', 'direct_booking'][Math.floor(Math.random() * 4)],
notes: 'Test inventory created via test mode',

// Payment fields
paymentStatus: 'paid',
supplierName: 'Test Supplier Company',

// System fields
created_by: JSON.parse(localStorage.getItem('crm_user') || '{}').name || 'Test User',
created_date: new Date().toISOString()
};



console.log('Creating inventory with correct fields:', testData);

const response = await fetch(window.API_CONFIG.API_URL + '/inventory', {
method: 'POST',
headers: {
'Authorization': 'Bearer ' + authToken,
'Content-Type': 'application/json'
},
body: JSON.stringify(testData)
});

const result = await response.json();

if (response.ok) {
alert('Test inventory created!\n' +
'Event: ' + testData.event_name + '\n' +
'Sports: ' + testData.sports + '\n' +
'Venue: ' + testData.venue + '\n' +
'Category: ' + testData.category_of_ticket + '\n' +
'Available: ' + testData.available_tickets + ' tickets');
window.location.reload();
} else {
console.error('Failed:', result);
alert('Error: ' + (result.error || result.message || 'Failed to create inventory'));
}
} catch (error) {
console.error('Error:', error);
alert('Error: ' + error.message);
}
};



window.createTestLead = async function() {
const authToken = localStorage.getItem('crm_auth_token');
// Using global window.API_CONFIG.API_URL variable

try {
// Using exact field names from leadFormFields
const testData = {
// Basic fields (required)
name: 'Test Contact ' + Math.floor(Math.random() * 1000),
email: 'test' + Math.floor(Math.random() * 1000) + '@example.com',
phone: '98' + Math.floor(Math.random() * 90000000 + 10000000),
company: 'Test Company ' + Math.floor(Math.random() * 100),
business_type: ['B2C', 'B2B'][Math.floor(Math.random() * 2)],

// Lead details
source: ['Facebook', 'Instagram', 'LinkedIn', 'Friends and Family', 'Through Champion', 
'Website', 'Existing Client', 'Contacted on Social Media', 'Middlemen'][Math.floor(Math.random() * 9)],

// Business fields
potential_value: Math.floor(Math.random() * 500000) + 50000,
notes: 'Test lead interested in event tickets',

// System fields
status: 'unassigned', // Using lowercase as per your code
created_by: JSON.parse(localStorage.getItem('crm_user') || '{}').name || 'Test User',
created_date: new Date().toISOString()
};



console.log('Creating lead with correct fields:', testData);

const response = await fetch(window.API_CONFIG.API_URL + '/leads', {
method: 'POST',
headers: {
'Authorization': 'Bearer ' + authToken,
'Content-Type': 'application/json'
},
body: JSON.stringify(testData)
});

const result = await response.json();

if (response.ok) {
alert('Test lead created!\n' +
'Name: ' + testData.name + '\n' +
'Company: ' + testData.company + '\n' +
'Source: ' + testData.source);
window.location.reload();
} else {
console.error('Failed:', result);
alert('Error: ' + (result.error || result.message || 'Failed to create lead'));
}
} catch (error) {
console.error('Error:', error);
alert('Error: ' + error.message);
}
};



console.log('Test functions loaded with correct field names');

return null;
}
};



</script>

<!-- TEMP FINANCIALS DELETE FUNCTION -->
<script>
window.deleteAllFinancials = async function() {
if (!confirm('Delete all financial records (payables and receivables)?')) return;

const authToken = localStorage.getItem('crm_auth_token');
// Using global window.API_CONFIG.API_URL variable

try {
console.log('Starting to delete all financials...');
let deletedPayables = 0;
let deletedReceivables = 0;

// Delete all payables
try {
const payablesRes = await fetch(`${window.API_CONFIG.API_URL}/api/payables`, {
headers: {
'Authorization': `Bearer ${authToken}`,
'Content-Type': 'application/json'
}
});

if (payablesRes.ok) {
const payablesData = await payablesRes.json();
const payables = payablesData.data || [];
console.log(`Found ${payables.length} payables to delete`);

for (const payable of payables) {
const delRes = await fetch(`${window.API_CONFIG.API_URL}/api/payables/${payable.id}`, {
method: 'DELETE',
headers: {
'Authorization': `Bearer ${authToken}`,
'Content-Type': 'application/json'
}
});
if (delRes.ok) {
deletedPayables++;
console.log(`Deleted payable: ${payable.id}`);
}
}
}
} catch (e) {
console.error('Error deleting payables:', e);
}

// Delete all receivables - FIXED endpoint
try {
console.log('Fetching receivables...');
const receivablesRes = await fetch(`${window.API_CONFIG.API_URL}/api/receivables`, {
headers: {
'Authorization': `Bearer ${authToken}`,
'Content-Type': 'application/json'
}
});

console.log('Receivables response status:', receivablesRes.status);

if (receivablesRes.ok) {
const receivablesData = await receivablesRes.json();
const receivables = receivablesData.data || [];
console.log(`Found ${receivables.length} receivables to delete`);

// Delete each receivable
for (const receivable of receivables) {
console.log(`Deleting receivable: ${receivable.id}`);
const delRes = await fetch(`${window.API_CONFIG.API_URL}/api/receivables/${receivable.id}`, {
method: 'DELETE',
headers: {
'Authorization': `Bearer ${authToken}`,
'Content-Type': 'application/json'
}
});

if (delRes.ok) {
deletedReceivables++;
console.log(`Successfully deleted receivable: ${receivable.id}`);
} else {
console.error(`Failed to delete receivable ${receivable.id}:`, delRes.status);
}
}
} else {
console.error('Failed to fetch receivables:', receivablesRes.status);
}
} catch (e) {
console.error('Error deleting receivables:', e);
}

alert(`Financial records deleted!\nPayables: ${deletedPayables}\nReceivables: ${deletedReceivables}`);
window.location.reload();

} catch (error) {
console.error('Error:', error);
alert('Error: ' + error.message);
}
};


</script>

</body>
</html>
